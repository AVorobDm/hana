<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Boost.Hana: boost::hana::List Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_list.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="#nested-classes">Instances and minimal complete definitions</a> &#124;
<a href="structboost_1_1hana_1_1_list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::List Struct Reference<div class="ingroups"><a class="el" href="group__group-typeclasses.html">Type classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>General purpose index-based sequence. </p>
<h3>Laws</h3>
<p>For any two <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code>s <code>xs</code> and <code>ys</code>, the following statement must hold:</p>
<div class="fragment"><div class="line">xs == ys <span class="keywordflow">if</span> and only <span class="keywordflow">if</span> to&lt;Tuple&gt;(xs) == to&lt;Tuple&gt;(ys)</div>
</div><!-- fragment --><p>This is basically saying that all <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> instances are isomorphic to the instance defined by the <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence. ">Tuple</a></code> data type, and it therefore makes sense to define comparison for any two instances of <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd><ul>
<li>How to implement iterate and repeat?</li>
<li>There is a strong relationship between this and <code>MonadPlus</code>. Actually, they might be just the same. Check this out.</li>
<li>Implement the following methods:<ul>
<li><code>intersperse</code>, <code>intercalate</code>, <code>transpose</code>, <code>subsequences</code></li>
<li><code>split_at</code>, <code>break</code>, <code>inits</code>, <code>tails</code></li>
</ul>
</li>
<li>Consider implementing the following methods:<ul>
<li><code>nub_by</code>, <code>nub</code>, <code>delete_by</code>, <code>insert</code></li>
<li><code>set_difference_by</code>, <code>set_union_by</code>, <code>set_intersection_by</code></li>
</ul>
</li>
<li>Since we can benchmark the isomorphic instances, put the benchmarks in the documentation. </li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a></td></tr>
<tr class="memdesc:a30a6926751dfcafbe2bb67738e2da3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two lists together.  <a href="#a30a6926751dfcafbe2bb67738e2da3c4">More...</a><br /></td></tr>
<tr class="separator:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51732ddadf982e47f5757b092294df12"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a51732ddadf982e47f5757b092294df12">cons</a></td></tr>
<tr class="memdesc:a51732ddadf982e47f5757b092294df12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to the head of a list.  <a href="#a51732ddadf982e47f5757b092294df12">More...</a><br /></td></tr>
<tr class="separator:a51732ddadf982e47f5757b092294df12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929370eddd43bb1a4a11b00a7880eadb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a></td></tr>
<tr class="memdesc:a929370eddd43bb1a4a11b00a7880eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list containing only the elements satisfying a <code>predicate</code>.  <a href="#a929370eddd43bb1a4a11b00a7880eadb">More...</a><br /></td></tr>
<tr class="separator:a929370eddd43bb1a4a11b00a7880eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad855f1d86e9bf0d31d67c191412a9082"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#ad855f1d86e9bf0d31d67c191412a9082">group_by</a></td></tr>
<tr class="memdesc:ad855f1d86e9bf0d31d67c191412a9082"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group type class is used for Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary...">Group</a> the elements of a list into subgroups of adjacent elements that are "equal" with respect to a predicate.  <a href="#ad855f1d86e9bf0d31d67c191412a9082">More...</a><br /></td></tr>
<tr class="separator:ad855f1d86e9bf0d31d67c191412a9082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a></td></tr>
<tr class="memdesc:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group type class is used for Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary...">Group</a> the elements of a list into subgroups of adjacent equal elements.  <a href="#a83d9b8f0f293c6fe7cfccd2359dec330">More...</a><br /></td></tr>
<tr class="separator:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733fdb2e8686033466beea8323e53a26"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a></td></tr>
<tr class="memdesc:a733fdb2e8686033466beea8323e53a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element of a non-empty list.  <a href="#a733fdb2e8686033466beea8323e53a26">More...</a><br /></td></tr>
<tr class="separator:a733fdb2e8686033466beea8323e53a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e061315d04d18ef407084906ffba4"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a711e061315d04d18ef407084906ffba4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a711e061315d04d18ef407084906ffba4">make&lt; L, when&lt; is_a&lt; List, L &gt;)&gt; &gt;</a></td></tr>
<tr class="memdesc:a711e061315d04d18ef407084906ffba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> with the given elements in it.  <a href="#a711e061315d04d18ef407084906ffba4">More...</a><br /></td></tr>
<tr class="separator:a711e061315d04d18ef407084906ffba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e654b583265053e4dde63fff0c0aea"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a04e654b583265053e4dde63fff0c0aea"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a04e654b583265053e4dde63fff0c0aea">nil</a> = List::instance&lt;L&gt;::nil_impl()</td></tr>
<tr class="memdesc:a04e654b583265053e4dde63fff0c0aea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nil&lt;L&gt;</code> is an empty list of data type <code>L</code>.  <a href="#a04e654b583265053e4dde63fff0c0aea">More...</a><br /></td></tr>
<tr class="separator:a04e654b583265053e4dde63fff0c0aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b65dd69bb016d647801718e840816"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a788b65dd69bb016d647801718e840816">partition</a></td></tr>
<tr class="memdesc:a788b65dd69bb016d647801718e840816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a list based on a <code>predicate</code>.  <a href="#a788b65dd69bb016d647801718e840816">More...</a><br /></td></tr>
<tr class="separator:a788b65dd69bb016d647801718e840816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a></td></tr>
<tr class="memdesc:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all the permutations of the given list.  <a href="#a45ec7767d19eb7eaabb71ead3796a7f1">More...</a><br /></td></tr>
<tr class="separator:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4471413ccc3835db5e48658683b8aba0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a4471413ccc3835db5e48658683b8aba0">reverse</a></td></tr>
<tr class="memdesc:a4471413ccc3835db5e48658683b8aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a list.  <a href="#a4471413ccc3835db5e48658683b8aba0">More...</a><br /></td></tr>
<tr class="separator:a4471413ccc3835db5e48658683b8aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb039a3d46931ef17fef56c77d8256c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a></td></tr>
<tr class="memdesc:adfb039a3d46931ef17fef56c77d8256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldl</code>, but returns a list of reduced values from the left.  <a href="#adfb039a3d46931ef17fef56c77d8256c">More...</a><br /></td></tr>
<tr class="separator:adfb039a3d46931ef17fef56c77d8256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62411eb57e86f3cb7394f22fd3651355"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a></td></tr>
<tr class="memdesc:a62411eb57e86f3cb7394f22fd3651355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanl</code> that has no starting value argument.  <a href="#a62411eb57e86f3cb7394f22fd3651355">More...</a><br /></td></tr>
<tr class="separator:a62411eb57e86f3cb7394f22fd3651355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb725e66aedc0c19c38b38a00302abf4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a></td></tr>
<tr class="memdesc:abb725e66aedc0c19c38b38a00302abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldr</code>, but returns a list of reduced values from the right.  <a href="#abb725e66aedc0c19c38b38a00302abf4">More...</a><br /></td></tr>
<tr class="separator:abb725e66aedc0c19c38b38a00302abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5948df39fe904d509f1bb073d53e3965"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a></td></tr>
<tr class="memdesc:a5948df39fe904d509f1bb073d53e3965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanr</code> that has no starting value argument.  <a href="#a5948df39fe904d509f1bb073d53e3965">More...</a><br /></td></tr>
<tr class="separator:a5948df39fe904d509f1bb073d53e3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18968c488a8b0cdc2697296024da9293"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a18968c488a8b0cdc2697296024da9293">slice</a></td></tr>
<tr class="memdesc:a18968c488a8b0cdc2697296024da9293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a sublist delimited by the given indices.  <a href="#a18968c488a8b0cdc2697296024da9293">More...</a><br /></td></tr>
<tr class="separator:a18968c488a8b0cdc2697296024da9293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplParams" colspan="2">template&lt;std::size_t from, std::size_t to&gt; </td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#afa204f71aac9f461d8574653295c67ba">slice_c</a></td></tr>
<tr class="memdesc:afa204f71aac9f461d8574653295c67ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>slice</code>; provided for convenience.  <a href="#afa204f71aac9f461d8574653295c67ba">More...</a><br /></td></tr>
<tr class="separator:afa204f71aac9f461d8574653295c67ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95183c155c6180b31d4965aa203957d0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a95183c155c6180b31d4965aa203957d0">snoc</a></td></tr>
<tr class="memdesc:a95183c155c6180b31d4965aa203957d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to the end of a list.  <a href="#a95183c155c6180b31d4965aa203957d0">More...</a><br /></td></tr>
<tr class="separator:a95183c155c6180b31d4965aa203957d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1454689bf6d2264bc428dc1d039db"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a58c1454689bf6d2264bc428dc1d039db">sort</a></td></tr>
<tr class="memdesc:a58c1454689bf6d2264bc428dc1d039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list based on the <code>less</code> <a class="el" href="structboost_1_1hana_1_1_orderable.html#strict_weak_ordering">strict weak ordering</a>.  <a href="#a58c1454689bf6d2264bc428dc1d039db">More...</a><br /></td></tr>
<tr class="separator:a58c1454689bf6d2264bc428dc1d039db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a></td></tr>
<tr class="memdesc:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list based on the given <code>predicate</code>.  <a href="#a6ed2907b48fcba3dd1059b4b0bfde624">More...</a><br /></td></tr>
<tr class="separator:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663fc84c23656a41d4dfcb586f0085c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#ab663fc84c23656a41d4dfcb586f0085c">span</a></td></tr>
<tr class="memdesc:ab663fc84c23656a41d4dfcb586f0085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a list satisfying a predicate, and the rest of the list.  <a href="#ab663fc84c23656a41d4dfcb586f0085c">More...</a><br /></td></tr>
<tr class="separator:ab663fc84c23656a41d4dfcb586f0085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20028c5115dcf38063d322f27b4ee1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a2c20028c5115dcf38063d322f27b4ee1">take</a></td></tr>
<tr class="memdesc:a2c20028c5115dcf38063d322f27b4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list containing the first <code>n</code> elements of a list.  <a href="#a2c20028c5115dcf38063d322f27b4ee1">More...</a><br /></td></tr>
<tr class="separator:a2c20028c5115dcf38063d322f27b4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a63f9ab281c8e979adfd7f6678383c46b">take_c</a></td></tr>
<tr class="memdesc:a63f9ab281c8e979adfd7f6678383c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>take</code>; provided for convenience.  <a href="#a63f9ab281c8e979adfd7f6678383c46b">More...</a><br /></td></tr>
<tr class="separator:a63f9ab281c8e979adfd7f6678383c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a></td></tr>
<tr class="memdesc:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements until the <code>predicate</code> is satisfied.  <a href="#a27aa67fa9ffc3d89b23a6dce018013d4">More...</a><br /></td></tr>
<tr class="separator:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86916c5c62a42f01f85450b366ef6eff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a></td></tr>
<tr class="memdesc:a86916c5c62a42f01f85450b366ef6eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements while the <code>predicate</code> is satisfied.  <a href="#a86916c5c62a42f01f85450b366ef6eff">More...</a><br /></td></tr>
<tr class="separator:a86916c5c62a42f01f85450b366ef6eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8c7ea5db04febb890469a024fcd58b"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a2c8c7ea5db04febb890469a024fcd58b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a2c8c7ea5db04febb890469a024fcd58b">unfoldl</a></td></tr>
<tr class="memdesc:a2c8c7ea5db04febb890469a024fcd58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldl</code> for lists.  <a href="#a2c8c7ea5db04febb890469a024fcd58b">More...</a><br /></td></tr>
<tr class="separator:a2c8c7ea5db04febb890469a024fcd58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#ab8e70b7be1022d132ff5369d7b1b6c2c">unfoldr</a></td></tr>
<tr class="memdesc:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldr</code> for lists.  <a href="#ab8e70b7be1022d132ff5369d7b1b6c2c">More...</a><br /></td></tr>
<tr class="separator:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5308d966fbf95d317511a706d6d20a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#abe5308d966fbf95d317511a706d6d20a">unzip</a></td></tr>
<tr class="memdesc:abe5308d966fbf95d317511a706d6d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzip a list of lists.  <a href="#abe5308d966fbf95d317511a706d6d20a">More...</a><br /></td></tr>
<tr class="separator:abe5308d966fbf95d317511a706d6d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a></td></tr>
<tr class="memdesc:a23b6ac9e78577d70b9108a80e6b1534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one list or more.  <a href="#a23b6ac9e78577d70b9108a80e6b1534c">More...</a><br /></td></tr>
<tr class="separator:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a></td></tr>
<tr class="memdesc:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one list or more with a given function.  <a href="#a5eadaf63535ebb8cdd8d9e4c16b9bacd">More...</a><br /></td></tr>
<tr class="separator:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Instances and minimal complete definitions</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list_1_1instance_3_01_boost_mpl_vector_01_4.html">instance&lt; BoostMplVector &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> instance for Boost.MPL vectors.  <a href="structboost_1_1hana_1_1_list_1_1instance_3_01_boost_mpl_vector_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list_1_1instance_3_01_integer_list_01_4.html">instance&lt; IntegerList &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list_1_1instance_3_01_tuple_01_4.html">instance&lt; Tuple &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> for the <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence. ">Tuple</a></code> data type.  <a href="structboost_1_1hana_1_1_list_1_1instance_3_01_tuple_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_list_1_1mcd.html">mcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal complete definition: <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code>, <code><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="Iterable represents data structures supporting external iteration. ">Iterable</a></code>, <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="Data structures that can be folded, i.e. summarized into a single value. ">Foldable</a></code>, <code>cons</code>, and <code>nil</code>  <a href="structboost_1_1hana_1_1_list_1_1mcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a30a6926751dfcafbe2bb67738e2da3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto concat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        static_assert(detail::std::is_same&lt;</div>
<div class="line">            <a class="code" href="group__group-core.html#gae3cedd3772d00ac7c4de9dc3d719f321">datatype_t</a>&lt;decltype(xs)&gt;, <a class="code" href="group__group-core.html#gae3cedd3772d00ac7c4de9dc3d719f321">datatype_t</a>&lt;decltype(ys)&gt;</div>
<div class="line">        &gt;::value,</div>
<div class="line">        <span class="stringliteral">&quot;boost::hana::concat: both arguments must have the same data type&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::concat_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(ys)&gt;(ys)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Concatenate two lists together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two instances of <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> with <em>the same data type</em>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(tuple(1, <span class="charliteral">&#39;2&#39;</span>), tuple(3.3, 4_c)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c)</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a51732ddadf982e47f5757b092294df12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cons</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::cons_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(x)&gt;(x),</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Prepend an element to the head of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An element to prepend to the list.</td></tr>
    <tr><td class="paramname">xs</td><td>The list to which an element is prepended.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, tuple()) == tuple(1));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, <a class="code" href="structboost_1_1hana_1_1_list.html#a51732ddadf982e47f5757b092294df12">cons</a>(<span class="charliteral">&#39;2&#39;</span>, <a class="code" href="structboost_1_1hana_1_1_list.html#a51732ddadf982e47f5757b092294df12">cons</a>(3.3, tuple()))) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a929370eddd43bb1a4a11b00a7880eadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::filter_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a list containing only the elements satisfying a <code>predicate</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to filter.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for each element <code>x</code> in the list and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether that element should be <b>kept</b> in the resulting list. In the current version of the library, the <code>predicate</code> has to return a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(tuple(1, 2.0, 3, 4.0), trait_&lt;std::is_integral&gt;)</div>
<div class="line">            ==</div>
<div class="line">            tuple(1, 3)</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="filter.time.png" alt="filter.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="ad855f1d86e9bf0d31d67c191412a9082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto group_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::group_by_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate),</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group type class is used for Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary...">Group</a> the elements of a list into subgroups of adjacent elements that are "equal" with respect to a predicate. </p>
<p>Specifically, <code>group_by</code> takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist contains only elements for which the predicate is satisfied when applied to two adjacent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A binary function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are <em>adjacent</em> elements in the list, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether both elements should be in the same group (sublist) of the result. The result returned by <code>predicate</code> has to be a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>. Also, <code>predicate</code> has to define an <a class="el" href="structboost_1_1hana_1_1_comparable.html#equivalence_relation">equivalence relation</a> as defined by the <code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> type class.</td></tr>
    <tr><td class="paramname">xs</td><td>The list to split into groups.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#ad855f1d86e9bf0d31d67c191412a9082">group_by</a>(equal ^<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>^ decltype_,</div>
<div class="line">                tuple(1, 2, 3, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, 4.4, 5.5)</div>
<div class="line">            )</div>
<div class="line">            == tuple(</div>
<div class="line">                tuple(1, 2, 3),</div>
<div class="line">                tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>),</div>
<div class="line">                tuple(4.4, 5.5)</div>
<div class="line">            )</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a83d9b8f0f293c6fe7cfccd2359dec330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto group</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::group_impl(detail::std::forward&lt;decltype(xs)&gt;(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group type class is used for Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary...">Group</a> the elements of a list into subgroups of adjacent equal elements. </p>
<p>Specifically, <code>group(xs)</code> is equivalent to <code>group_by(equal, xs)</code>. For this method to work, comparing adjacent elements have to return a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to split into groups.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(tuple(int_&lt;1&gt;, long_&lt;1&gt;, type&lt;int&gt;, char_&lt;&#39;x&#39;&gt;, char_&lt;&#39;x&#39;&gt;))</div>
<div class="line">            ==</div>
<div class="line">            tuple(</div>
<div class="line">                tuple(int_&lt;1&gt;, long_&lt;1&gt;),</div>
<div class="line">                tuple(type&lt;int&gt;),</div>
<div class="line">                tuple(char_&lt;&#39;x&#39;&gt;, char_&lt;&#39;x&#39;&gt;)</div>
<div class="line">            )</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a733fdb2e8686033466beea8323e53a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::init_impl(detail::std::forward&lt;decltype(xs)&gt;(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the last element of a non-empty list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>(tuple(1)) == tuple());</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a711e061315d04d18ef407084906ffba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto make&lt; L, <a class="el" href="structboost_1_1hana_1_1when.html">when</a>&lt; is_a&lt; <a class="el" href="structboost_1_1hana_1_1_list.html">List</a>, L &gt;)&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;L&gt;::make_impl(</div>
<div class="line">            std::forward&lt;decltype(xs)&gt;(xs)...</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create a <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> with the given elements in it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>The data type representing the <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> to create. This can be any instance of the <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> type class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs...</td><td>The elements to put in the constructed list. The elements will appear in the resulting list in the same order as passed to <code>make</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(make&lt;Tuple&gt;() == tuple());</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="make.time.png" alt="make.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a04e654b583265053e4dde63fff0c0aea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto nil = List::instance&lt;L&gt;::nil_impl()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nil&lt;L&gt;</code> is an empty list of data type <code>L</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>The data type of the empty list wanted. This must be an instance of the <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code> type class.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(nil&lt;Tuple&gt; == tuple());</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a788b65dd69bb016d647801718e840816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::partition_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Partition a list based on a <code>predicate</code>. </p>
<p>Specifically, returns an unspecified <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> whose first element is a list of the elements satisfying the predicate, and whose second element is a list of the elements that do not satisfy the predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to be partitioned.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for each element <code>x</code> in the list and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>. If the result of <code>predicate</code> is true-valued, then <code>x</code> is added to the list in the first component of the resulting <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>. Otherwise, <code>x</code> is added to the list in the second component. In the current version of the library, the <code>predicate</code> has to return a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a788b65dd69bb016d647801718e840816">partition</a>(integer_list&lt;int, 1, 2, 3, 4, 5, 6, 7&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">                <span class="keywordflow">return</span> x % int_&lt;2&gt; != int_&lt;0&gt;;</div>
<div class="line">            })</div>
<div class="line">            ==</div>
<div class="line">            pair(</div>
<div class="line">                integer_list&lt;int, 1, 3, 5, 7&gt;,</div>
<div class="line">                integer_list&lt;int, 2, 4, 6&gt;</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a788b65dd69bb016d647801718e840816">partition</a>(type_list&lt;void, int, float, char, double&gt;, trait&lt;std::is_floating_point&gt;)</div>
<div class="line">            ==</div>
<div class="line">            pair(</div>
<div class="line">                type_list&lt;float, double&gt;,</div>
<div class="line">                type_list&lt;void, int, char&gt;</div>
<div class="line">            )</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45ec7767d19eb7eaabb71ead3796a7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto permutations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::permutations_impl(detail::std::forward&lt;decltype(xs)&gt;(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a list of all the permutations of the given list. </p>
<p>The permutations are not guaranteed to be in any specific order.</p>
<dl class="section note"><dt>Note</dt><dd>Implementation taken from <a href="http://stackoverflow.com/a/2184129/627587">http://stackoverflow.com/a/2184129/627587</a>.</dd></dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> is_permutation_of = curry&lt;2&gt;([](<span class="keyword">auto</span> xs, <span class="keyword">auto</span> perm) {</div>
<div class="line">            <span class="keywordflow">return</span> elem(<a class="code" href="structboost_1_1hana_1_1_list.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a>(xs), perm);</div>
<div class="line">        });</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            all(</div>
<div class="line">                tuple(</div>
<div class="line">                    tuple(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0),</div>
<div class="line">                    tuple(<span class="charliteral">&#39;1&#39;</span>, 3.0, 2),</div>
<div class="line">                    tuple(2, <span class="charliteral">&#39;1&#39;</span>, 3.0),</div>
<div class="line">                    tuple(2, 3.0, <span class="charliteral">&#39;1&#39;</span>),</div>
<div class="line">                    tuple(3.0, <span class="charliteral">&#39;1&#39;</span>, 2),</div>
<div class="line">                    tuple(3.0, 2, <span class="charliteral">&#39;1&#39;</span>)</div>
<div class="line">                ),</div>
<div class="line">                is_permutation_of(tuple(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0))</div>
<div class="line">            )</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="permutations.time.png" alt="permutations.time.png"/>
</div>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>We got a performance problem here. Generating the permutations of a list of more than 3 elements takes a long time (&gt;6s). </dd></dl>

</div>
</div>
<a class="anchor" id="a4471413ccc3835db5e48658683b8aba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::reverse_impl(detail::std::forward&lt;decltype(xs)&gt;(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Reverse a list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a4471413ccc3835db5e48658683b8aba0">reverse</a>(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(3.3, <span class="charliteral">&#39;2&#39;</span>, 1));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adfb039a3d46931ef17fef56c77d8256c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::scanl_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(state)&gt;(state),</div>
<div class="line">            detail::std::forward&lt;decltype(f)&gt;(f)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Similar to <code>foldl</code>, but returns a list of reduced values from the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to scan.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. This will always be the first element of the resulting list.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the list.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a>(tuple(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>), 1, show) == tuple(</div>
<div class="line">            1,</div>
<div class="line">            <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;(((1 + 2) + 3) + 4)&quot;</span></div>
<div class="line">        ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="scanl.time.png" alt="scanl.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a62411eb57e86f3cb7394f22fd3651355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::scanl1_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(f)&gt;(f)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Variant of <code>scanl</code> that has no starting value argument. </p>
<p>While <code>foldl1</code> may not be called with an empty structure, <code>scanl1</code> can be called with an empty list, in which case it will simply return an empty list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to scan.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the list.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a>(tuple(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), show) == tuple(</div>
<div class="line">            1,</div>
<div class="line">            <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span></div>
<div class="line">        ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="scanl1.time.png" alt="scanl1.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="abb725e66aedc0c19c38b38a00302abf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::scanr_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(state)&gt;(state),</div>
<div class="line">            detail::std::forward&lt;decltype(f)&gt;(f)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Similar to <code>foldr</code>, but returns a list of reduced values from the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to scan.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. This will always be the last element of the resulting list.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the list.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a>(tuple(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), 4, show) == tuple(</div>
<div class="line">            <span class="stringliteral">&quot;(1 + (2 + (3 + 4)))&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;(2 + (3 + 4))&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;(3 + 4)&quot;</span>,</div>
<div class="line">            4</div>
<div class="line">        ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="scanr.time.png" alt="scanr.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a5948df39fe904d509f1bb073d53e3965"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::scanr1_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(f)&gt;(f)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Variant of <code>scanr</code> that has no starting value argument. </p>
<p>While <code>foldr1</code> may not be called with an empty structure, <code>scanr1</code> can be called with an empty list, in which case it will simply return an empty list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to scan.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the list.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a>(tuple(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), show) == tuple(</div>
<div class="line">            <span class="stringliteral">&quot;(1 + (2 + 3))&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;(2 + 3)&quot;</span>,</div>
<div class="line">            <span class="charliteral">&#39;3&#39;</span></div>
<div class="line">        ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="scanr1.time.png" alt="scanr1.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a18968c488a8b0cdc2697296024da9293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; from, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::slice_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(from)&gt;(from),</div>
<div class="line">            detail::std::forward&lt;decltype(<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>)&gt;(<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Extract a sublist delimited by the given indices. </p>
<p>Specifically, <code>slice(xs, from, to)</code> is a list containing all the elements of <code>xs</code> at indices in the half-open interval delimited by [<code>from</code>, <code>to</code>). Note that the indices are 0-based. For this operation to be valid, <code>xs</code> must contain at least <code>to + 1</code> elements, and it must be true that <code>from &lt;= to</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to slice.</td></tr>
    <tr><td class="paramname">from</td><td>The index of the first element in the slice. <code>from</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant type class is used for Constants holding a compile-time value of an integral typ...">IntegralConstant</a></code>.</td></tr>
    <tr><td class="paramname">to</td><td>One-past the index of the last element in the slice. <code>to</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant type class is used for Constants holding a compile-time value of an integral typ...">IntegralConstant</a></code> such that <code>from &lt;= to</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a18968c488a8b0cdc2697296024da9293">slice</a>(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, type&lt;float&gt;), int_&lt;1&gt;, int_&lt;3&gt;)</div>
<div class="line">            ==</div>
<div class="line">            tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">        );</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>Should this be <code>slice(xs, from, length)</code> instead? </dd></dl>

</div>
</div>
<a class="anchor" id="afa204f71aac9f461d8574653295c67ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t from, std::size_t to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_list.html#a18968c488a8b0cdc2697296024da9293">slice</a>(std::forward&lt;decltype(xs)&gt;(xs), size_t&lt;from&gt;, size_t&lt;to&gt;);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>slice</code>; provided for convenience. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            slice_c&lt;1, 3&gt;(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, type&lt;float&gt;))</div>
<div class="line">            ==</div>
<div class="line">            tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a95183c155c6180b31d4965aa203957d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto snoc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::snoc_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(x)&gt;(x)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Append an element to the end of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to which an element is appended.</td></tr>
    <tr><td class="paramname">x</td><td>An element to append to the list.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(tuple(), 1) == tuple(1));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(tuple(1, <span class="charliteral">&#39;2&#39;</span>), 3.3) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(tuple(), 1), <span class="charliteral">&#39;2&#39;</span>), 3.3) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a58c1454689bf6d2264bc428dc1d039db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::sort_impl(detail::std::forward&lt;decltype(xs)&gt;(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sort a list based on the <code>less</code> <a class="el" href="structboost_1_1hana_1_1_orderable.html#strict_weak_ordering">strict weak ordering</a>. </p>
<p>The elements in the list must all be <code><a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable type class is used for data types defining a strict weak ordering. ">Orderable</a></code>. In the current version of the library, the <code>less</code> method of the <code><a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable type class is used for data types defining a strict weak ordering. ">Orderable</a></code> instance must be a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(tuple(1_c, -2_c, 3_c, 0_c)) == tuple(-2_c, 0_c, 1_c, 3_c)</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="sort.time.png" alt="sort.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a6ed2907b48fcba3dd1059b4b0bfde624"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::sort_by_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate),</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sort a list based on the given <code>predicate</code>. </p>
<p>The sort is guaranteed to be stable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code> for two elements <code>x</code> and <code>y</code> of the list, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> should appear <b>before</b> <code>y</code> in the resulting list. More specifically, the <code>predicate</code> must define a <a class="el" href="structboost_1_1hana_1_1_orderable.html#strict_weak_ordering">strict weak ordering</a> on the elements of the list. In the current version of the library, <code>predicate</code> must return a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> when called with any two elements of the list.</td></tr>
    <tr><td class="paramname">xs</td><td>The list to sort.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>&gt;<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>, tuple(1_c, -2_c, 3_c, 0_c))</div>
<div class="line">            ==</div>
<div class="line">            tuple(3_c, 1_c, 0_c, -2_c)</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab663fc84c23656a41d4dfcb586f0085c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto span</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::span_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a list satisfying a predicate, and the rest of the list. </p>
<p>The first element of the returned <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a list for which all elements satisfy the given predicate. The second element of the returned <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a list containing the remainder of the argument. Both or either lists may be empty, depending on the input argument. Specifically, <code>span(xs, predicate)</code> is equivalent to </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_list.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, predicate) == pair(</div>
<div class="line">                        <a class="code" href="structboost_1_1hana_1_1_list.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(xs, predicate),</div>
<div class="line">                        drop_while(xs, predicate)</div>
<div class="line">                       )</div>
</div><!-- fragment --><p> except that <code>pair</code> may be an arbitrary <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to break into two parts.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the list, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a>. In the current implementation of the library,</code>predicate<code>has to return a [compile-time] (@ref Logical_terminology)</code>Logical`.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> xs = tuple(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;4&gt;);</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;3&gt;)</div>
<div class="line">            ==</div>
<div class="line">            pair(tuple(int_&lt;1&gt;, int_&lt;2&gt;), tuple(int_&lt;3&gt;, int_&lt;4&gt;))</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;0&gt;)</div>
<div class="line">            ==</div>
<div class="line">            pair(tuple(), xs)</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;5&gt;)</div>
<div class="line">            ==</div>
<div class="line">            pair(xs, tuple())</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c20028c5115dcf38063d322f27b4ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; n, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::take_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(n)&gt;(n),</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a list containing the first <code>n</code> elements of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1_integral.html" title="Represents a compile-time value of an integral type. ">Integral</a></code> representing the number of elements to keep in the resulting list. If <code>n</code> is greater than the length of the input list, the whole list is returned.</td></tr>
    <tr><td class="paramname">xs</td><td>The list to take the elements from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(0_c, tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple());</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(1_c, tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(1));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(2_c, tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(3_c, tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(4_c, tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="take.time.png" alt="take.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a63f9ab281c8e979adfd7f6678383c46b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_list.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(size_t&lt;n&gt;, std::forward&lt;decltype(xs)&gt;(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>take</code>; provided for convenience. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(take_c&lt;2&gt;(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27aa67fa9ffc3d89b23a6dce018013d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_until</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::take_until_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Take elements until the <code>predicate</code> is satisfied. </p>
<p>Specifically, returns the longest prefix of a list in which all elements do not satisfy the predicate. This is effectively equivalent to <code>take_while</code> with a negated predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to take the elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the list, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether the resulting list should stop at the element before <code>x</code>. In the current version of the library, <code>predicate</code> has to return a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a>(integer_list&lt;int, 3, 2, 1, 0&gt;, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 2_c)</div>
<div class="line">            ==</div>
<div class="line">            integer_list&lt;int, 3, 2&gt;</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="take_until.time.png" alt="take_until.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a86916c5c62a42f01f85450b366ef6eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_while</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::take_while_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Take elements while the <code>predicate</code> is satisfied. </p>
<p>Specifically, returns the longest prefix of a list in which all elements satisfy the given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The list to take elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the list, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> should be included in the resulting list. In the current version of the library, <code>predicate</code> has to return a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(integer_list&lt;int, 0, 1, 2, 3&gt;, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 2_c)</div>
<div class="line">            ==</div>
<div class="line">            integer_list&lt;int, 0, 1&gt;</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="take_while.time.png" alt="take_while.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a2c8c7ea5db04febb890469a024fcd58b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unfoldl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;L&gt;::unfoldl_impl(</div>
<div class="line">            std::forward&lt;decltype(f)&gt;(f),</div>
<div class="line">            std::forward&lt;decltype(<a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>)&gt;(<a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Dual to <code>foldl</code> for lists. </p>
<p>While <code>foldl</code> reduces a list to a summary value, <code>unfoldl</code> builds a list from a seed value and a function. In some cases, <code>unfoldl</code> can undo a <code>foldl</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_list.html#a2c8c7ea5db04febb890469a024fcd58b">unfoldl</a>(g, foldl(xs, z, f))</div>
</div><!-- fragment --><p>if the following holds </p><div class="fragment"><div class="line">g(f(y, x)) == just(pair(y, x))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function called as <code>f(init)</code>, where <code>init</code> is an initial value, and returning<ol type="1">
<li><code>nothing</code> if it is done producing the list.</li>
<li><code>just(pair(init, x))</code> if it isn't, where <code>init</code> is the new initial value used in the next call to <code>f</code> and <code>x</code> is an element to be appended to the resulting list. Also note that <code>pair</code> may actually be replaced by any instance of the <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> type class.</li>
</ol>
</td></tr>
    <tr><td class="paramname">init</td><td>An initial value to build the list from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x - int_&lt;1&gt;, x)));</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            unfoldl&lt;IntegerList&gt;(f, int_&lt;10&gt;)</div>
<div class="line">            ==</div>
<div class="line">            integer_list&lt;int, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab8e70b7be1022d132ff5369d7b1b6c2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unfoldr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;L&gt;::unfoldr_impl(</div>
<div class="line">            std::forward&lt;decltype(f)&gt;(f),</div>
<div class="line">            std::forward&lt;decltype(<a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>)&gt;(<a class="code" href="structboost_1_1hana_1_1_list.html#a733fdb2e8686033466beea8323e53a26">init</a>)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Dual to <code>foldr</code> for lists. </p>
<p>While <code>foldr</code> reduces a list to a summary value, <code>unfoldr</code> builds a list from a seed value and a function. In some cases, <code>unfoldr</code> can undo a <code>foldr</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_list.html#ab8e70b7be1022d132ff5369d7b1b6c2c">unfoldr</a>(g, foldr(xs, z, f))</div>
</div><!-- fragment --><p>if the following holds </p><div class="fragment"><div class="line">g(f(x, y)) == just(pair(x, y))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function called as <code>f(init)</code>, where <code>init</code> is an initial value, and returning<ol type="1">
<li><code>nothing</code> if it is done producing the list.</li>
<li><code>just(pair(x, init))</code> if it isn't, where <code>init</code> is the new initial value used in a recursive call to <code>f</code> and <code>x</code> is an element prepended to the resulting list. Also note that <code>pair</code> may actually be replaced by any instance of the <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> type class.</li>
</ol>
</td></tr>
    <tr><td class="paramname">init</td><td>An initial value to build the list from.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x, x - int_&lt;1&gt;)));</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            unfoldr&lt;IntegerList&gt;(f, int_&lt;10&gt;)</div>
<div class="line">            ==</div>
<div class="line">            integer_list&lt;int, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&gt;</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe5308d966fbf95d317511a706d6d20a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unzip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::unzip_impl(detail::std::forward&lt;decltype(xs)&gt;(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Unzip a list of lists. </p>
<p>Specifically, takes a list of the form </p><div class="fragment"><div class="line">[s1, s2, ..., sn]</div>
</div><!-- fragment --><p> where each <code>si</code> is a list, and returns a list equivalent to <code>zip(s1, s2, ..., sn)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A list of lists to unzip.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(tuple(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), tuple(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6)))</div>
<div class="line">            ==</div>
<div class="line">            tuple(tuple(1, <span class="charliteral">&#39;4&#39;</span>), tuple(<span class="charliteral">&#39;2&#39;</span>, 5.5), tuple(3.3, 6))</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(tuple(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), tuple(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6, <span class="stringliteral">&quot;ignored&quot;</span>)))</div>
<div class="line">            ==</div>
<div class="line">            tuple(tuple(1, <span class="charliteral">&#39;4&#39;</span>), tuple(<span class="charliteral">&#39;2&#39;</span>, 5.5), tuple(3.3, 6))</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23b6ac9e78577d70b9108a80e6b1534c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ...ys) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::zip_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(ys)&gt;(ys)...</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Zip one list or more. </p>
<p>This is equivalent to <code>zip_with(make&lt;L&gt;, xs, ys...)</code>, where <code>L</code> is the data type of <code>xs</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys...</td><td>The lists to zip together.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(tuple(1, <span class="charliteral">&#39;a&#39;</span>), tuple(2, 3.3))</div>
<div class="line">            ==</div>
<div class="line">            tuple(tuple(1, 2), tuple(<span class="charliteral">&#39;a&#39;</span>, 3.3))</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(tuple(1, <span class="charliteral">&#39;a&#39;</span>), tuple(2, 3.3), tuple(3, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">            ==</div>
<div class="line">            tuple(tuple(1, 2, 3), tuple(<span class="charliteral">&#39;a&#39;</span>, 3.3, <span class="charliteral">&#39;c&#39;</span>))</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5eadaf63535ebb8cdd8d9e4c16b9bacd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip_with</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ...ys) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> List::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::zip_with_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(f)&gt;(f),</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(ys)&gt;(ys)...</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Zip one list or more with a given function. </p>
<p>Specifically, returns a list whose i-th element is <code>f(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the i-th element of the k-th list passed as an argument. The returned list stops when the shortest input sequence is exhausted.</p>
<p>In other words, <code>zip_with(f, s1, ..., sn)</code> is a list of the form </p><div class="fragment"><div class="line">f(s1[0], ..., sn[0])</div>
<div class="line">f(s1[1], ..., sn[1])</div>
<div class="line">...</div>
<div class="line">f(s1[k], ..., sn[k])</div>
</div><!-- fragment --><p> where <code>k</code> is the length of the shortest list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function called as <code>f(s1[k], ..., sn[k])</code>, where <code>si[k]</code> are elements of the zipped lists as explained above.</td></tr>
    <tr><td class="paramname">xs,ys...</td><td>The lists to zip with the given function.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_list.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> * <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>, tuple(1, 2, 3, 4), tuple(5, 6, 7, 8, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">            ==</div>
<div class="line">            tuple(5, 12, 21, 32)</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="zip_with.time.png" alt="zip_with.time.png"/>
</div>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>Consider allowing only two lists and achieving the variadic behavior in some other way. This would make it possible to automatically curry <code>zip_with</code>. It might be possible to achieve the variadic behavior with e.g. <a class="el" href="structboost_1_1hana_1_1_applicative.html" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a> Functors? </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_list.html">List</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
