<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Boost.Hana: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a></li>
<li class="level1"><a href="#tutorial-introduction">Introduction</a><ul><li class="level2"><a href="#tutorial-introduction-warning">A word of warning</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-quick_start">Quick start</a><ul><li class="level2"><a href="#tutorial-quick_start-value_computations">Value computations</a></li>
<li class="level2"><a href="#tutorial-quick_start-type_computations">Type computations</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-basic_concepts">Basic concepts</a><ul><li class="level2"><a href="#tutorial-basic_concepts-heterogeneity">Heterogeneity</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-constant">Constants, or setting constexpr straight</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-side_effects">Constants and side effects</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-assertions">A zoo of assertions</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-comparing">Comparing objects</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-mapping">Transforming collections</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-folding">Folding collections</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-searching">Searching in collections</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-iteration">Iterating through collections</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-list">The List type class</a></li>
<li class="level2"><a href="#tutorial-basic_concepts-adapting">Adapting user-defined structs</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-external_libraries">Integration with external libraries</a><ul><li class="level2"><a href="#tutorial-external_libraries-stl">The standard library</a></li>
<li class="level2"><a href="#tutorial-external_libraries-fusion">Boost.Fusion</a></li>
<li class="level2"><a href="#tutorial-external_libraries-mpl">Boost.MPL</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-performance_considerations">Performance considerations</a><ul><li class="level2"><a href="#tutorial-performance_considerations-compile_time">Compile-time performance</a></li>
<li class="level2"><a href="#tutorial-performance_considerations-run_time">Runtime performance</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-extending">Extending the library</a><ul><li class="level2"><a href="#tutorial-extending-tag_dispatching">Basic tag dispatching</a></li>
<li class="level2"><a href="#tutorial-extending-datatypes">Data types</a></li>
<li class="level2"><a href="#tutorial-extending-typeclasses">Type classes</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-header_organization">Header organization</a></li>
<li class="level1"><a href="#tutorial-mastering">Mastering the library</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> The seed that became this library was planted in late 2012, when I first started to reimplement the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> using C++11 in a project named <a href="http://github.com/ldionne/mpl11">MPL11</a>. In spring 2014, I applied to <a href="http://www.google-melange.com/gsoc/homepage/google/gsoc2014">Google Summer of Code</a> with that project for the Boost organization and got in. The goal was to polish the MPL11 and get it in Boost by the end of the summer. In May, before GSoC was started full steam, I presented the project at <a href="http://cppnow.org">C++Now</a> and had insightful conversations with several attendees. The idea that it was possible to unify the <a href="http://www.boost.org/doc/libs/release/libs/fusion/doc/html/index.html">Boost.Fusion</a> and the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> libraries made its way and I became convinced of it after writing the first prototype for what is now Boost.Hana. We are now in late July and the plan is to request an official review to get the library in Boost by the end of GSoC; we'll see how that works out.</p>
<p>Let the fun begin.</p>
<h1><a class="anchor" id="tutorial-introduction"></a>
Introduction</h1>
<hr/>
<p> Boost.Hana is a library of combinators tailored towards the manipulation of heterogeneous collections (think <code>std::tuple</code>). It provides high level operations to manipulate those collections in compile-time efficient ways and with a great level of expressiveness. One of its main purpose is to unify type-level (think <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a>) and heterogeneous value-level programming (think <a href="http://www.boost.org/doc/libs/release/libs/fusion/doc/html/index.html">Boost.Fusion</a>) under a single consistent interface, allowing the compile-time and the runtime worlds to interact in new, useful ways. This unification also has the nice side effect of increasing code reuse and easing the learning curve for metaprogramming.</p>
<p>The core of Hana is a powerful compile-time dispatching system allowing the library to be extended in a ad-hoc manner. This extension system is used within Hana to provide all the functionality of the library in a modular way. It makes Hana very easy to extend, and in fact the library provides interoperation with Boost.Fusion, Boost.MPL and some components of the standard library out of the box.</p>
<h2><a class="anchor" id="tutorial-introduction-warning"></a>
A word of warning</h2>
<p>Programming with heterogeneous objects is inherently functional &ndash; since it is impossible to modify the type of an object, a new object must be introduced instead, which rules out mutation. Unlike previous metaprogramming libraries like Boost.MPL and Boost.Fusion, I have decided to embrace this and as a result, Hana uses an almost purely functional style of programming. However, this style of programming influences not only the internal implementation; it also leaks into the interface. Hence, if you continue beyond this point, be prepared to see quite a bit of functional programming along the way.</p>
<p>In particular, unlike previous metaprogramming libraries, the design of Hana is not based on that of the STL. Instead, it is inspired by several standard and non standard modules written for the Haskell programming language. Through experience, I have found this to be much more expressive, flexible and easy to use while not sacrificing any performance given the compile-time/runtime-but-heterogeneous setting. However, as a result, many concepts used in Hana will be unfamiliar to C++ programmers without a knowledge of FP, to whom I say: be assured that the reward is totally worth it.</p>
<h1><a class="anchor" id="tutorial-quick_start"></a>
Quick start</h1>
<hr/>
<p> This section assumes the reader is already familiar with basic metaprogramming and the <a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14 standard</a>. First, let's include the library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hana_8hpp.html">boost/hana.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
</div><!-- fragment --><p> Unless specified otherwise, the documentation assumes that the above lines are present before examples and code snippets. Also note that finer grained headers are provided and will be explained in the <a class="el" href="index.html#tutorial-header_organization">Header organization</a> section, but for now that'll do.</p>
<h2><a class="anchor" id="tutorial-quick_start-value_computations"></a>
Value computations</h2>
<p>Let's create an heterogeneous list, which is essentially the same as a <code>std::tuple</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> xs = <a class="code" href="structboost_1_1hana_1_1_tuple.html#a6607b420b861d7abc8df34cb6900da19">tuple</a>(1, <span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>});</div>
</div><!-- fragment --><p> There are several operations that can be performed on lists; here's a couple so you get the feeling:</p>
<div class="fragment"><div class="line">assert(<a class="code" href="structboost_1_1hana_1_1_iterable.html#a5379264e83af65af8802eeec0d49e5f0">last</a>(xs) == <span class="stringliteral">&quot;345&quot;</span>);</div>
<div class="line"></div>
<div class="line">assert(<a class="code" href="structboost_1_1hana_1_1_iterable.html#ab15783aae10d4373e2399abe728f3f96">tail</a>(xs) == <a class="code" href="structboost_1_1hana_1_1_tuple.html#a6607b420b861d7abc8df34cb6900da19">tuple</a>(<span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>}));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_iterable.html#a4193ecf811f29479c60022564afa512a">is_empty</a>(xs));</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::cout &lt;&lt; x;</div>
<div class="line">});</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p><b>Note</b><br />
<code>BOOST_HANA_CONSTANT_ASSERT</code> is a compile-time assertion; the details are explained later in the tutorial. </p>
</blockquote>
<p>You have probably observed how the <code>auto</code> keyword is used when defining <code>xs</code>  and how the actual type of <code>list(...)</code> is not written anywhere. This will be the case a lot in Hana. In particular, <code>list</code> is a <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Generic_lambdas">generic lambda</a> taking a variable number of arguments and returning an object of an unspecified type, but which is nonetheless a valid sequence for Hana. It is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> list = [](<span class="keyword">auto</span> ...xs) {</div>
<div class="line">    <span class="keywordflow">return</span> unspecified; <span class="comment">// magic going on here</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>So the actual type of <code>list(...)</code> is completely unspecified; this will also be the case for most objects defined by Hana. It does not mean that you can't name that type, but simply that you can't do anything useful with it.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> wow_that_is_so_useless = <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(xs);</div>
</div><!-- fragment --><p> However, you will never need the actual type of an object to do something useful with it, so don't let it bother you.</p>
<p>Another interesting observation in the previous example is that <code>is_empty</code> returns a value that's known at compile-time even though the list it was called on is not a constant expression (it's not declared with <code>constexpr</code> and it contains an object of the non-literal type <code>std::string</code> anyways). Indeed, the size of the sequence is known at compile-time regardless of its contents, so it only makes sense that Hana does not throw away this information. If that seems surprising to you, think about <code>std::tuple</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ys = std::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>});</div>
<div class="line"></div>
<div class="line">static_assert(std::tuple_size&lt;<a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(ys)&gt;::<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a> != 0, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Since the size of the tuple is encoded in it's type, it's always available at compile-time regardless of whether the tuple is <code>constexpr</code> or not. How this works in Hana will be explained in detail later, but the trick is that <code>is_empty</code> returns something like a <code>std::integral_constant</code>, which can always be converted to an integral value at compile-time.</p>
<h2><a class="anchor" id="tutorial-quick_start-type_computations"></a>
Type computations</h2>
<p>One of the initial goals of the library was to unify type level programming with value level programming. So in principle, it should be possible to manipulate types and sequences of types, and then to perform type computations on those just as one would do with the Boost.MPL. Indeed, it's possible. First, we create a list containing types:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ts = <a class="code" href="structboost_1_1hana_1_1_tuple.html#a6607b420b861d7abc8df34cb6900da19">tuple</a>(type&lt;int*&gt;, type&lt;void&gt;, type&lt;char const&gt;);</div>
</div><!-- fragment --><p> Let me clarify what's going on. First, the list does not <em>actually</em> contain types; it only contains objects that represent types for Hana. So those <code>type&lt;...&gt;</code> guys are actually objects! In fact, they are <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Variable_templates">variable templates</a> defined roughly as:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">constexpr unspecified <a class="code" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a>{};</div>
</div><!-- fragment --><p>Like for <code>list(...)</code>, the actual C++ type of <code>type&lt;...&gt;</code> is left unspecified, but you won't need it anyways. Since <code>type&lt;T&gt;</code> is an object (the fact that it's declared with <code>constexpr</code> is irrelevant), it makes perfect sense to create an heterogeneous sequence of these guys. Let's see what kind of operations we can do with our list:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_iterable.html#a5379264e83af65af8802eeec0d49e5f0">last</a>(ts) == type&lt;char const&gt;);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_iterable.html#ab15783aae10d4373e2399abe728f3f96">tail</a>(ts) == <a class="code" href="structboost_1_1hana_1_1_tuple.html#a6607b420b861d7abc8df34cb6900da19">tuple</a>(type&lt;void&gt;, type&lt;char const&gt;));</div>
</div><!-- fragment --><p> Ok, so we can store types in heterogeneous sequences and then manipulate those sequences as-if they contained regular heterogeneous objects (which is in fact the case). That's neat, but types are still not very useful when they are in the form of a weird object with an unspecified type that's only understood by Hana. In other words, we'd like to be able to take the <code>T</code> out of a <code>type&lt;T&gt;</code> object, and as a real C++ type that is. That's possible; it turns out that while <code>type&lt;T&gt;</code> has an unspecified type, it is still guaranteed to have a nested alias to <code>T</code> named <code>type</code>:</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(type&lt;char const&gt;)::<a class="code" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a>,</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span></div>
<div class="line">&gt;::<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Hence, in Boost.MPL parlance, <code>decltype(type&lt;T&gt;)</code> is a nullary metafunction returning <code>T</code>. Now that we can retrieve the actual C++ type out of those objects, we can do pretty much anything we want. For example, let's print the name of each type in our list, a bit like we did for our list of values above:</p>
<div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(ts, [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(t)::<a class="code" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a>;</div>
<div class="line">    std::cout &lt;&lt; <span class="keyword">typeid</span>(T).name();</div>
<div class="line">});</div>
</div><!-- fragment --><p> Are we able to apply type transformations? Sure:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> add_pointer = [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(t)::<a class="code" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a>;</div>
<div class="line">    <span class="keywordflow">return</span> type&lt;typename std::add_pointer&lt;T&gt;::type&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>add_pointer</code> just takes an object of the form <code>type&lt;T&gt;</code> and returns an object of the form <code>type&lt;T*&gt;</code>. Let's make sure it works as expected:</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(add_pointer(type&lt;char const&gt;))::<a class="code" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a>,</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>*</div>
<div class="line">&gt;::<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Since this pattern of defining functions that are equivalent to some metafunction is recurrent (and quite generic), Hana provides utilities to make this automatically. One of these, <code>metafunction</code>, takes an arbitrary metafunction (in the Boost.MPL sense of it) and promotes it to a regular function working on <code>type&lt;...&gt;</code>s:</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(metafunction&lt;std::add_pointer&gt;(type&lt;char const&gt;))::<a class="code" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a>,</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>*</div>
<div class="line">&gt;::<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Specifically, <code>metafunction</code> is a variable template defined roughly as</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">class </span>f&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="structboost_1_1hana_1_1_type.html#ae9bfabe7d39900f3ac536b008ef2ad39">metafunction</a> = [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(t)::<a class="code" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a>;</div>
<div class="line">    <span class="keywordflow">return</span> type&lt;typename f&lt;T&gt;::type&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>except that the real implementation in Hana works for an arbitrary number of <code>t</code> arguments, which is omitted here for simplicity. Hence, <code>metafunction&lt;f&gt;</code> is a function taking a <code>type&lt;T&gt;</code> and returning a <code>type&lt;R&gt;</code>, where <code>R</code> is the result of applying the <code>f</code> metafunction to <code>T</code>. This way, we can take arbitrary metafunctions working on normal C++ types, apply them to our <code>type&lt;...&gt;</code> objects, and then go back to normal C++ types with <code>decltype(...)::type</code> if we want. At this point, a nice insight is that the Boost.MPL is in fact equivalent to the subset of Hana that works with <code>type&lt;...&gt;</code>s!</p>
<p>This is it for the quick start. Of course, there is much more available like associative sequences, sets, ranges and even an heterogeneous <code>std::optional</code> called <code>Maybe</code>, but you can read on if you want to know more.</p>
<h1><a class="anchor" id="tutorial-basic_concepts"></a>
Basic concepts</h1>
<hr/>
<p> This section introduces the basic concepts of the library in a friendly way. In particular, it does not present everything available in the library and it should not be seen as a replacement for the reference documentation, but merely as a complement and introduction to it. The terms <a class="el" href="index.html#tutorial-extending-typeclasses">type class</a> and <a class="el" href="index.html#tutorial-extending-datatypes">data type</a> will be used in this section without having been defined precisely. For now, it suffices that you think of the former as abstract interfaces specifying a set of operations called <em>methods</em>, and of the latter as actual implementations of those interfaces, with the particularity that a data type may "implement" several such interfaces.</p>
<h2><a class="anchor" id="tutorial-basic_concepts-heterogeneity"></a>
Heterogeneity</h2>
<p>The purpose of Hana is to manipulate heterogeneous objects. Before we dive any deeper in the library, let's ask a fundamental question: does it even make sense to manipulate heterogeneous objects?</p>
<p>For the sake of the explanation, let me make the following claim: a function template that compiles with an argument of every possible type must have a trivial implementation, in the sense that it must do nothing with its argument except perhaps return it. Hence, for a function template to do something interesting, it must fail to compile for some set of arguments. While I won't try to prove that claim formally &ndash; it might be false in some corner cases &ndash;, think about it for a moment. Let's say I want to apply a function to each element of an heterogeneous sequence:</p>
<div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(list(x, y, z), f)</div>
</div><!-- fragment --><p>The first observation is that <code>f</code> must have a templated call operator because <code>x</code>, <code>y</code> and <code>z</code> have different types. The second observation is that without knowing anything specific about the types of <code>x</code>, <code>y</code> and <code>z</code>, it is impossible for <code>f</code> to do anything meaningful. For example, could it print its argument? Of course not, since it does not know whether <code>std::cout &lt;&lt; x</code> is well-formed! In order to do something meaningful, the function has to put constraints on its arguments, it has to define a domain. In other words, it can't be <em>fully</em> polymorphic, at least not conceptually.</p>
<p>So while we're manipulating types that are technically heterogeneous, they still conceptually need something in common, or it wouldn't be possible to do anything meaningful with them. We'll still say that we're manipulating heterogeneous objects, but always keep in mind that the objects we manipulate must have something in common, and hence be homogeneous in <em>some regard</em>.</p>
<h2><a class="anchor" id="tutorial-basic_concepts-constant"></a>
Constants, or setting constexpr straight</h2>
<p>In C++, the border between compile-time and runtime is hazy, a fact that is even more true with the introduction of <a href="http://en.wikipedia.org/wiki/C%2B%2B11#constexpr_.E2.80.93_Generalized_constant_expressions">generalized constant expressions</a> in C++11. However, being able to manipulate heterogeneous objects is all about understanding that border and then crossing it at one's will. The goal of this section is to set things straight with <code>constexpr</code>; to understand which problems it can solve and which ones it can't. Let's start off with a <a href="http://www.gotw.ca/gotw/index.htm">GOTW</a> style question: do you think the following code should compile, and why?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">constexpr T assert_positive(T i) {</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keywordtype">int</span> i = 2;</div>
<div class="line">    assert_positive(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The right answer is "no". The error given by Clang goes like</p>
<div class="fragment"><div class="line">error: static_assert expression is not an <a class="code" href="structboost_1_1hana_1_1_integral.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a> constant expression</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">                  ^~~~~</div>
</div><!-- fragment --><p>The problem is that when you are in a function (<code>constexpr</code> or otherwise), you can't use an argument as a constant expression, even if the argument turns out to be a constant expression when you call the function. If you are surprised, consider the following code; the function is not a template anymore, which doesn't change anything with respect to the <code>constexpr</code>-ness of the argument if you think about it. Yet, the answer is now obvious:</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> assert_positive(<span class="keywordtype">int</span> i) {</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keywordtype">int</span> i = 2;</div>
<div class="line">    assert_positive(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Actually, since the body of <code>assert_positive</code> is not dependent anymore, Clang does not even reach <code>main</code> before giving the same error as before. Now, this is not a big problem for static assertions because we have <a href="http://stackoverflow.com/a/8626450/627587">another way</a> of reporting errors inside <code>constexpr</code> functions. However, it also means that we can't use an argument as a non-type template parameter, since that requires a constant expression. In other words, we can't create types that are dependent on the <em>value</em> of an argument in C++, which is nothing new if you think about it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> i&gt;</div>
<div class="line"><span class="keyword">struct </span>foo { };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i) {</div>
<div class="line">    foo&lt;i&gt; x; <span class="comment">// obviously won&#39;t work</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In particular, this means that the return type of a function can't depend on the value of its arguments; it may only depend on their type, and <code>constexpr</code> can't change this fact. This is of utmost importance to us, because we're interested in manipulating heterogeneous objects and eventually returning them from functions. Some of these functions might want to return an object of type <code>T</code> in one case and an object of type <code>U</code> in the other; from our little analysis, we now know that these "cases" will have to depend on information encoded in the <em>types</em> of the arguments, not in their <em>values</em>.</p>
<p>To represent this fact, Hana defines the concept of a <code>Constant</code>, which is an object from which a constant expression may always be obtained, regardless of the <code>constexpr</code>-ness of the object. <code>Constant</code>s provide a way to obtain that constant expression through the use of the <code>value</code> function. Specifically, for any <code>Constant</code> <code>c</code>, the following program must be valid:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keywordtype">void</span> f(X x) {</div>
<div class="line">    constexpr <span class="keyword">auto</span> y = <a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    f(c);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This law that must be respected by <code>Constant</code>s expresses the minimal requirement that we're able to retrieve a constant expression from an object, even if that object isn't a constant expression. There is no restriction on what the type of the constant expression might be, but it should be documented. Hana provides a model of this concept called an <code>Integral</code>; it encodes a compile-time value of an integral type, and you can think of it as a <code>std::integral_constant</code>. To create an <code>Integral</code>, we use the <code>integral</code> variable template:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> two = integral&lt;int, 2&gt;;</div>
<div class="line"><span class="keyword">auto</span> yes = integral&lt;bool, true&gt;;</div>
</div><!-- fragment --><p> <code>integral</code> is defined roughly as</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T v&gt;</div>
<div class="line">constexpr unspecified <a class="code" href="structboost_1_1hana_1_1_integral.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>{};</div>
</div><!-- fragment --><p>where the type of <code>integral&lt;...&gt;</code>, while being unspecified, actually looks a lot like a <code>std::integral_constant</code>. Indeed, an <code>Integral</code> is guaranteed to have the same members as an equivalent <code>std::integral_constant</code>, so they can be used as such</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Two = <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(two);</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;Two::type, Two&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;Two::value_type, int&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(Two::value == 2               &amp;&amp;</div>
<div class="line">              static_cast&lt;int&gt;(two) == 2    &amp;&amp;</div>
<div class="line">              two() == 2                    &amp;&amp;</div>
<div class="line">              <a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(two) == 2</div>
<div class="line">, <span class="stringliteral">&quot;these are all constant expressions&quot;</span>);</div>
</div><!-- fragment --><p> Shorthands to create <code>Integral</code>s of the most common integral types are also provided, so the following is equivalent to the previous example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> two = int_&lt;2&gt;;</div>
<div class="line"><span class="keyword">auto</span> yes = bool_&lt;true&gt;;</div>
</div><!-- fragment --><p> Additionally, <code>Integral</code>s can be created with the help of <a href="http://en.wikipedia.org/wiki/C%2B%2B11#User-defined_literals">user-defined literals</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals; <span class="comment">// &lt;-- mandatory to use the _c suffix!</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(1234_c == llong&lt;1234&gt;);</div>
<div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(-1234_c == llong&lt;-1234&gt;);</div>
</div><!-- fragment --><p> However, this syntax only allows creating <code>Integral</code>s with an underlying value of type <code>long long</code>. Another feature of <code>Integral</code>s is that they overload common operators so that <code>integral&lt;...&gt;</code>s can be used with an intuitive syntax:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(int_&lt;1&gt; == integral&lt;int, 1&gt;);</div>
<div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(int_&lt;1&gt; + long_&lt;2&gt; == long_&lt;3&gt;);</div>
<div class="line"><a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!(bool_&lt;true&gt; &amp;&amp; bool_&lt;false&gt;));</div>
</div><!-- fragment --><p> It is important to realize that these operators return <code>Integral</code>s, not normal values of an integral type. Specifically, for an operator <code>@</code>,</p>
<div class="fragment"><div class="line">integral&lt;X, x&gt; @ integral&lt;Y, y&gt; == integral&lt;decltype(x @ y), x @ y&gt;</div>
</div><!-- fragment --><p>This is very important because it allows all the information that's known at compile-time (i.e. <code>Constant</code>s) to be conserved as long as it's only used with other values known at compile-time. If we did not encode the result of these operations in the type of the returned object, we would lose the ability to e.g. make the return type of a function dependent on that object. It is also interesting to observe that whenever an <code>Integral</code> is used with a normal runtime value, the result will be a runtime value (because of the implicit conversion). Hence, we get the following table</p>
<table class="doxtable">
<tr>
<th align="center">left operand </th><th align="center">right operand </th><th align="center">result  </th></tr>
<tr>
<td align="center"><code>Constant</code> </td><td align="center"><code>Constant</code> </td><td align="center"><code>Constant</code> </td></tr>
<tr>
<td align="center"><code>Constant</code> </td><td align="center">runtime </td><td align="center">runtime </td></tr>
<tr>
<td align="center">runtime </td><td align="center"><code>Constant</code> </td><td align="center">runtime </td></tr>
<tr>
<td align="center">runtime </td><td align="center">runtime </td><td align="center">runtime </td></tr>
</table>
<h2><a class="anchor" id="tutorial-basic_concepts-side_effects"></a>
Constants and side effects</h2>
<p>Let me ask a tricky question. Is the following code valid?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) { <span class="keywordflow">return</span> x; }</div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(identity(bool_&lt;true&gt;)), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>The answer is "no", but the reason might not be obvious at first. Even more puzzling is that the following code is perfectly valid:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) { <span class="keywordflow">return</span> x; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> x = identity(bool_&lt;true&gt;);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(x), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To understand why the compiler can't possibly evaluate the first assertion at compile-time, notice that <code>identity</code> was not marked <code>constexpr</code> and consider the following alternative (but valid) definition for <code>identity</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Good luck in evaluating this at compile-time!&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The signature of the function did not change; the function could even have been defined in a separate source file. However, it is now obvious that the compiler can't evaluate that expression at compile-time. On the other hand, when we write</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Good luck in evaluating this at compile-time!&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> x = identity(bool_&lt;true&gt;);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(x), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> we're telling the compiler to perform those potential side effects during the dynamic initialization phase! Then, we use <code>value</code> to return the compile-time value associated to its argument. Also note that <code>value</code> takes a <code>const&amp;</code> to its argument; if it tried taking it by value, we would be reading from a non-<code>constexpr</code> variable to do the copying, and that could hide side-effects.</p>
<p>Normally, this would not be a big issue because the expressions we want to call <code>value</code> with should be constant expressions anyway, so there would be no need to introduce a dummy variable. However, Hana uses lambdas pretty heavily, and unfortunately lambdas can't appear in constant expressions in the current language. Hence, some expressions like</p>
<div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>(list(1, 2, 3))</div>
</div><!-- fragment --><p>are not constant expressions because they use lambdas internally. In other words, while that expression is a <code>Constant</code>, it is not <code>constexpr</code>.</p>
<h2><a class="anchor" id="tutorial-basic_concepts-assertions"></a>
A zoo of assertions</h2>
<p>The goal of this section is to explain different types of assertions that you will encounter in the documentation. While these assertions are not meant to be used in user code, you will encounter them in the documentation and in the examples, so it is important to understand their purpose.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd>Write this, but how to avoid duplicating the reference documentation?</dd></dl>
<h2><a class="anchor" id="tutorial-basic_concepts-comparing"></a>
Comparing objects</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000049">Todo:</a></b></dt><dd>Use Type and List (both compile-time and runtime).</dd></dl>
<h2><a class="anchor" id="tutorial-basic_concepts-mapping"></a>
Transforming collections</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000050">Todo:</a></b></dt><dd>Use Maybe and List.</dd></dl>
<h2><a class="anchor" id="tutorial-basic_concepts-folding"></a>
Folding collections</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000051">Todo:</a></b></dt><dd>Use Range, List</dd></dl>
<h2><a class="anchor" id="tutorial-basic_concepts-searching"></a>
Searching in collections</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000052">Todo:</a></b></dt><dd>Use Map, Set, List</dd></dl>
<h2><a class="anchor" id="tutorial-basic_concepts-iteration"></a>
Iterating through collections</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000053">Todo:</a></b></dt><dd>Use List</dd></dl>
<h2><a class="anchor" id="tutorial-basic_concepts-list"></a>
The List type class</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000054">Todo:</a></b></dt><dd>Use List</dd></dl>
<h2><a class="anchor" id="tutorial-basic_concepts-adapting"></a>
Adapting user-defined structs</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000055">Todo:</a></b></dt><dd>Use a hand-crafted example</dd></dl>
<h1><a class="anchor" id="tutorial-external_libraries"></a>
Integration with external libraries</h1>
<hr/>
<h2><a class="anchor" id="tutorial-external_libraries-stl"></a>
The standard library</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000056">Todo:</a></b></dt><dd></dd></dl>
<h2><a class="anchor" id="tutorial-external_libraries-fusion"></a>
Boost.Fusion</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000057">Todo:</a></b></dt><dd></dd></dl>
<h2><a class="anchor" id="tutorial-external_libraries-mpl"></a>
Boost.MPL</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000058">Todo:</a></b></dt><dd></dd></dl>
<h1><a class="anchor" id="tutorial-performance_considerations"></a>
Performance considerations</h1>
<hr/>
 <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000059">Todo:</a></b></dt><dd></dd></dl>
<h2><a class="anchor" id="tutorial-performance_considerations-compile_time"></a>
Compile-time performance</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000060">Todo:</a></b></dt><dd></dd></dl>
<h2><a class="anchor" id="tutorial-performance_considerations-run_time"></a>
Runtime performance</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000061">Todo:</a></b></dt><dd></dd></dl>
<h1><a class="anchor" id="tutorial-extending"></a>
Extending the library</h1>
<hr/>
<p> As advertised, the core of Hana is a powerful compile-time dispatching system making it painless to extend the library in a ad-hoc manner. The following sections explain this system and how you can use it to extend the library without hassle. The dispatching system is built around two core concepts; <em>type classes</em> and <em>data types</em>.</p>
<h2><a class="anchor" id="tutorial-extending-tag_dispatching"></a>
Basic tag dispatching</h2>
<p>Tag dispatching is a generic programming technique for picking the right implementation of a function depending on the type of the arguments passed to the function. While this technique is not used as-is in the library, it is explained here because it forms the conceptual basis for Hana's compile-time dispatching system.</p>
<p>The usual mechanism for overriding a function's behavior is overloading. Unfortunately, this mechanism is not always convenient when dealing with families of related types having different C++ types, or with objects of unspecified types as is often the case in Hana. For example, consider trying to overload a function for all Boost.Fusion vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <span class="keyword">function</span>(boost::fusion::vector&lt;T...&gt; v) {</div>
<div class="line">    <span class="comment">// whatever</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>If you know Boost.Fusion, then you probably know that it won't work. This is because Boost.Fusion vectors are not necessarily specializations of the <code>boost::fusion::vector</code> template. Fusion vectors also exist in numbered forms, which are all of different types:</p>
<div class="fragment"><div class="line">boost::fusion::vector1&lt;T&gt;</div>
<div class="line">boost::fusion::vector2&lt;T, U&gt;</div>
<div class="line">boost::fusion::vector3&lt;T, U, V&gt;</div>
<div class="line">...</div>
</div><!-- fragment --><p>This is an implementation detail required by the lack of variadic templates in C++03 that leaks into the interface. This is unfortunate, but we need a way to work around it. And it gets worse; I said earlier that <code>list</code>, <code>type</code> and other Boost.Hana components did not specify their type at all &ndash; specifying those types would be too restrictive for the implementation &ndash;, so it would be outright impossible to overload functions for those. To work around this, we use an infrastructure with three distinct components:</p>
<ol type="1">
<li>A metafunction associating a single tag to every type in a family of related types. Hana calls those tags <em>data types</em>, and the metafunction is called <code>datatype</code>. The next section explains these in depth.</li>
<li>A function belonging to the public interface of the library, for which we'd like to be able to provide a customized implementation.</li>
<li>An implementation for the function, parameterized with the data type(s) of the argument(s) passed to the function.</li>
</ol>
<p>When the public interface function is called, it will use the metafunction on its argument(s) (or a subset thereof) to obtain their data type(s) and redirect to the implementation associated to those data type(s). For example, a basic setup for tag dispatching of a function that prints its argument to a stream would look like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Datatype&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::ostream&amp; os, X x) {</div>
<div class="line">        <span class="comment">/* possibly some default implementation */</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(std::ostream&amp; os, X x) {</div>
<div class="line">    <span class="keyword">using</span> Datatype = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt;X&gt;::type</a>;</div>
<div class="line">    <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">print_impl&lt;Datatype&gt;::apply</a>(os, x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl&lt;UserDefinedDatatype&gt; {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::ostream&amp; os, X x) {</div>
<div class="line">        <span class="comment">/* a custom implementation for some data type */</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="tutorial-extending-datatypes"></a>
Data types</h2>
<blockquote class="doxtable">
<p><b>Note</b><br />
Since I'm going to use the word "type" a lot, I'll sometimes use the term "C++ type" to make it clear that I'm really speaking about the stuff returned by <code>decltype(...)</code> as opposed to "data types", which are the subject of this section. So whenever you see "C++ type", think <code>decltype</code>. </p>
</blockquote>
<p>Concretely, data types are implemented as empty structs or classes:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyDatatype;</div>
</div><!-- fragment --><p>This is very similar to the tags present in Boost.MPL and Boost.Fusion, except Hana data types are not limited to represent sequences only. To carry the association between a C++ type and its data type, we use the <code>datatype</code> metafunction, which takes a normal C++ type and returns the data type associated to it. Since several different C++ types can share a common data type, we can now associate, for example, all the <code>boost::fusion::vectorN</code>s to a single type representing them all, say <code>BoostFusionVector</code>.</p>
<p>There are several ways to specify the data type of a C++ type. If it's a user-defined type, one can define a nested <code>hana_dataype</code> alias inside of it:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyUserDefinedType {</div>
<div class="line">    <span class="keyword">using</span> hana_datatype = MyDatatype;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Sometimes, however, the C++ type can't be modified (if it's in a foreign library) or simply can't have nested types (if it's not a struct or class). In those cases, using a nested alias is impossible and so ad-hoc customization is also supported by specializing <code>datatype</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>i_cant_modify_this;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>datatype&lt;i_cant_modify_this&gt; {</div>
<div class="line">        <span class="keyword">using</span> type = MyDatatype;</div>
<div class="line">    };</div>
<div class="line">}}</div>
</div><!-- fragment --><p><code>datatype</code> can also be specialized for all C++ types satisfying some boolean condition using <code>when</code>. <code>when</code> accepts a single compile-time boolean and enables the specialization of <code>datatype</code> if and only if that boolean is <code>true</code>. This is similar to the well known C++ idiom of using a dummy template parameter with <code>std::enable_if</code> and relying on SFINAE. For <code>boost::fusion::vector</code>, we would then do</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BoostFusionVector;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>datatype&lt;T, when&lt;is_a_boost_fusion_vector&lt;T&gt;::value&gt;&gt; {</div>
<div class="line">        <span class="keyword">using</span> type = BoostFusionVector;</div>
<div class="line">    };</div>
<div class="line">}}</div>
</div><!-- fragment --><p>where <code>is_a_boost_fusion_vector</code> is some metafunction returning whether a type is a Fusion vector.</p>
<p>One last thing about <code>datatype</code>; when it is not specialized and when the given C++ type does not have a nested <code>hana_dataype</code> alias, <code>datatype</code> returns the type itself after stripping it from all cv- qualifiers and references. This is <em>super</em> useful, mainly for two reasons. First, it allows Hana to adopt a reasonable default behavior for some operations involving types that have no clue about data types and all that stuff. For example, Hana allows comparing any two types for which a valid <code>operator==</code> is defined out of the box. Second, it also means that you can ignore data types completely if you don't need their functionality; just use the normal C++ type of your objects and everything will "just work".</p>
<p>By the way, <code>datatype_t&lt;T&gt;</code> is an alias to <code>datatype&lt;T&gt;::type</code> saving you from writing <code>typename datatype&lt;T&gt;::type</code> all over the place in dependent contexts; you can use whichever you prefer.</p>
<h2><a class="anchor" id="tutorial-extending-typeclasses"></a>
Type classes</h2>
<p>Type classes arise from the observation that some groups of operations are often semantically related. For example, if one were to define the concept of an object that can be printed to a stream, it would also make sense to provide a way to get a string representation of that object. Furthermore, given a way to print an object to a stream, one can obtain a string representation easily by using a <code>std::stringstream</code>, and the converse is also true. Since defining any one of those operations also provides an implementation for the other, we would like to be able to only define one to avoid code duplication, while retaining the ability to override both for efficiency.</p>
<p>Type classes make it possible to do all of this. Concretely, type classes are just bundles of related operations, called <em>methods</em> or <em>type class methods</em>. Instead of doing per-function dispatching as in the previous section, we simply dispatch to the implementation of a function inside a type class. For example, a basic setup for type class dispatching would look like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>default_implementation {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, X x) {</div>
<div class="line">            <span class="comment">/* possibly some default implementation */</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">        <span class="keyword">static</span> std::string to_string_impl(X x) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;possibly some default implementation&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(std::ostream&amp; os, X x) {</div>
<div class="line">    <span class="keyword">using</span> Datatype = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt;X&gt;::type</a>;</div>
<div class="line">    Printable::instance&lt;Datatype&gt;::print_impl(os, x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">std::string to_string(X x) {</div>
<div class="line">    <span class="keyword">using</span> Datatype = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt;X&gt;::type</a>;</div>
<div class="line">    <span class="keywordflow">return</span> Printable::instance&lt;Datatype&gt;::to_string_impl(x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;UserDefinedDatatype&gt; {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, X x) {</div>
<div class="line">        <span class="comment">/* a custom implementation for some data type */</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(X x) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;a custom implementation for some data type&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Grouping operations into type classes has several advantages. First, it allows advanced customization of the default behavior of methods &ndash; this will be explained below. Second, it ties the concepts used in the library &ndash; which otherwise only live in the documentation &ndash; to actual C++ constructs.</p>
<blockquote class="doxtable">
<p><b>Note</b><br />
It is interesting to observe that type class dispatching is strictly more general than basic tag dispatching, the latter being equivalent to type class dispatching where all type classes have a single method. </p>
</blockquote>
<p>Let's now explain the above snippet in detail. A type class is just a C++ structure or class calling the <code>BOOST_HANA_TYPECLASS</code> macro in its definition at public scope:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The <code>BOOST_HANA_TYPECLASS</code> macro creates a nested template named <code>instance</code>, so that name is reserved inside a type class to avoid clashes. Other arbitrary members can be put in the type class, but it is probably a good idea to keep anything unrelated out for the sake of separating concerns:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This is valid, but it&#39;s probably not a good idea unless those are</span></div>
<div class="line">    <span class="comment">// strongly related to the type class.</span></div>
<div class="line">    <span class="keywordtype">int</span> foo;</div>
<div class="line">    <span class="keywordtype">void</span> bar()<span class="keyword"> const </span>{ };</div>
<div class="line">    <span class="keyword">struct </span>baz { };</div>
<div class="line">};</div>
</div><!-- fragment --><p>As you will see later with minimal complete definitions, it is often useful to put other <em>related</em> members in a type class; don't hesitate to do it when it makes sense. The nested <code>instance</code> member of <code>Printable</code> is used when dispatching to the right implementation of a method. It should contain the method implementations for a specific data type. From now on, I will refer to the set of all data types for which <code>Printable::instance</code> is specialized as the <em>instances of <code>Printable</code></em>, and I will refer to the act of specializing <code>Printable::instance</code> as the act of <em>instantiating <code>Printable</code></em>.</p>
<p>To make a type an instance of <code>Printable</code>, we must implement the <code>print</code> and <code>to_string</code> methods:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;int&gt; {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, <span class="keywordtype">int</span> i) {</div>
<div class="line">        os &lt;&lt; i;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(<span class="keywordtype">int</span> i) {</div>
<div class="line">        <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; i).str();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note that we could have chosen a name different from <code>*_impl</code> inside the type class, but this naming convention has the advantage of being clear and avoiding name clashes inside the instance. In particular, we would not want to use <code>Printable::instance&lt;int&gt;::print</code>, because using <code>print</code> inside the instance would then refer to the implementation instead of <code>::print</code>, which is unexpected. This naming convention is used for all the type classes in Boost.Hana. Now that we have made <code>int</code> an instance of <code>Printable</code>, we can write:</p>
<div class="fragment"><div class="line">print(std::cout, 2);</div>
<div class="line"><a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(to_string(2) == <span class="stringliteral">&quot;2&quot;</span>);</div>
</div><!-- fragment --><p> So far so good, but you probably don't want to write an instance for each arithmetic type, right?. Fortunately, I didn't want to either so it is possible to instantiate a type class for all types satisfying a predicate using <code>when</code>, just like for the <code>datatype</code> metafunction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, when&lt;<a class="code" href="namespacestd.html">std</a>::is_arithmetic&lt;T&gt;<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">::value</a>&gt;&gt; {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T x) {</div>
<div class="line">        os &lt;&lt; x;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(T x) {</div>
<div class="line">        std::ostringstream os;</div>
<div class="line">        os &lt;&lt; x;</div>
<div class="line">        <span class="keywordflow">return</span> os.str();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> As expected, we can now write</p>
<div class="fragment"><div class="line">print(std::cout, 2.2);</div>
<div class="line"><a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(to_string(2.2) == <span class="stringliteral">&quot;2.2&quot;</span>);</div>
</div><!-- fragment --><p> Ok, we managed to cut down the number of instances quite a bit, but we still can't print a <code>std::string</code> without writing an explicit instance for <code>std::string</code>, which is a bummer. Again, laziness won me over and so it is possible to instantiate a type class for all types making some expression well-formed (think SFINAE):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, when&lt;<a class="code" href="group__group-core.html#ga2ffb2ad0341b5ec4e6fd83431e2a81ae">is_valid</a>&lt;</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(<a class="code" href="namespacestd.html">std</a>::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt;&gt; {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T x) {</div>
<div class="line">        os &lt;&lt; x;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(T x) {</div>
<div class="line">        std::ostringstream os;</div>
<div class="line">        os &lt;&lt; x;</div>
<div class="line">        <span class="keywordflow">return</span> os.str();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>is_valid</code> is always equivalent to <code>true</code>, but it takes an arbitrary number of types and relies on the fact that SFINAE will kick in and remove the specialization if any of the types is not well-formed. Note that <code>is_valid</code> can also be used when specializing the <code>datatype</code> metafunction. As expected, we can now write</p>
<div class="fragment"><div class="line">print(std::cout, std::string{<span class="stringliteral">&quot;foo&quot;</span>});</div>
<div class="line"><a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(to_string(std::string{<span class="stringliteral">&quot;foo&quot;</span>}) == <span class="stringliteral">&quot;foo&quot;</span>);</div>
</div><!-- fragment --><p> Note that instances provided without <code>when</code> (i.e. an explicit or partial specialization in the case of a parametric data type) have the priority over instances provided with it. This is to allow types to instantiate a type class even if an instance for the same type class is provided through a predicate. This design choice was made assuming that a specialization (even partial) is usually meant to be more specific than a catch-all instance enabled by a predicate.</p>
<p>All is good so far, but notice how we have to write an implementation for <code>to_string</code> every time, and how the implementation is always the same. It should be possible to remove this code duplication, and it is indeed. To do so, we introduce the notion of a <em>minimial complete definition</em>, often abbreviated <em>MCD</em>. The minimal complete definition of a type class is the minimal set of methods that must be implemented to instantiate it. In the case of <code>Printable</code>, we can always implement <code>to_string</code> in terms of <code>print</code>, so <code>print</code> is a MCD of <code>Printable</code>. To avoid code duplication, the default implementation of <code>to_string</code> is provided as a member of the type class and is inheritted by instances that would like to get that default implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>mcd {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">        <span class="keyword">static</span> std::string to_string_impl(X x) {</div>
<div class="line">            std::ostringstream os;</div>
<div class="line">            print(os, x);</div>
<div class="line">            <span class="keywordflow">return</span> os.str();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, when&lt;<a class="code" href="group__group-core.html#ga2ffb2ad0341b5ec4e6fd83431e2a81ae">is_valid</a>&lt;</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(<a class="code" href="namespacestd.html">std</a>::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt;&gt; : Printable::mcd {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T x)</div>
<div class="line">    { os &lt;&lt; x; }</div>
<div class="line">};</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p><b>Note</b><br />
For simplicity, the term minimal complete definition can refer either to a minimal set of required methods or to the member of the type class providing the corresponding default implementations. </p>
</blockquote>
<p>It is possible for a type class to have several minimal complete definitions. For example, one could observe that <code>print</code> can also be implemented in terms of <code>to_string</code>. If we wanted to do so, we could provide both minimal complete definitions by putting them into suitably named members of the <code>Printable</code> type class:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// requires to_string only</span></div>
<div class="line">    <span class="keyword">struct </span>to_string_mcd {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, X x) {</div>
<div class="line">            os &lt;&lt; to_string(x);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// requires print only</span></div>
<div class="line">    <span class="keyword">struct </span>print_mcd {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">        <span class="keyword">static</span> std::string to_string_impl(X x) {</div>
<div class="line">            std::ostringstream os;</div>
<div class="line">            print(os, x);</div>
<div class="line">            <span class="keywordflow">return</span> os.str();</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p> Either minimal complete definitions could now be used to instantiate <code>Printable</code>. By convention, in Boost.Hana, the minimal complete definition is always named <code>mcd</code> when there is a single one. A nested type named <code>mcd</code> is also provided when there are no default implementations to provide for consistency and for extensibility, as will be explained next. If there is more than one possible mcd, each mcd is in a different nested type with a descriptive name. In all cases, the minimal complete definition(s) are documented.</p>
<p>It is recommended to always inherit from a minimal complete definition, even when the default implementations are not actually used:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;<a class="code" href="namespacestd.html">std</a>::string&gt;</div>
<div class="line">    : Printable::print_mcd <span class="comment">// could also be to_string_mcd, it doesn&#39;t matter</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, std::string x)</div>
<div class="line">    { os &lt;&lt; x; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(std::string x)</div>
<div class="line">    { <span class="keywordflow">return</span> x; }</div>
<div class="line">};</div>
</div><!-- fragment --><p> This allows methods to be added to the type class without breaking the instance, provided the type class does not change its minimal complete definition(s). This is the reason why a minimal complete definition is always provided, even when it is empty.</p>
<p>To show the full power of type classes and introduce the <code>is_a</code> utility, let's define a <code>Printable</code> instance for <code>std::vector</code>s containing any <code>Printable</code> type.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;<a class="code" href="namespacestd.html">std</a>::vector&lt;T&gt;, when&lt;is_a&lt;Printable, T&gt;()&gt;&gt;</div>
<div class="line">    : Printable::print_mcd</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, std::vector&lt;T&gt; v) {</div>
<div class="line">        os &lt;&lt; <span class="charliteral">&#39;[&#39;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = begin(v); it != end(v); ) {</div>
<div class="line">            print(os, *it); <span class="comment">// recursively print the contents</span></div>
<div class="line">            <span class="keywordflow">if</span> (++it != end(v))</div>
<div class="line">                os &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        os &lt;&lt; <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>is_a</code> is a variable template taking a type class and a data type and returning whether the data type is an instance of the given type class. The result is returned as a boolean <code>Integral</code>, which explains the trailing <code>()</code> to convert the result to a <code>bool</code> at compile-time. We can now print nested containers:</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; v{{1, 2, 3}, {3, 4, 5}};</div>
<div class="line">print(std::cout, v); <span class="comment">// prints &quot;[[1, 2, 3], [3, 4, 5]]&quot;</span></div>
</div><!-- fragment --><p> <code>is_a</code> can also be used as a function object and with more than one data type; see the <a class="el" href="group__group-core.html#group-core-is_a">reference documentation</a> for details. Another thing that can be done with type classes is to provide a default instance for all data types. To do so, a nested <code>default_instance</code> template must be defined in the type class:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// definitions omitted</span></div>
<div class="line">    <span class="keyword">struct </span>to_string_mcd { };</div>
<div class="line">    <span class="keyword">struct </span>print_mcd { };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>default_instance : print_mcd {</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T)</div>
<div class="line">        { os &lt;&lt; <span class="stringliteral">&quot;&lt;&quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span>; }</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>default_instance</code> should be just like a normal instance. Note that this feature should seldom be used because methods with a meaningful behavior for all data types are rare. This feature is provided for flexibility, but it should be a hint to reconsider your type class design if you are about to use it. Anyway, with such a default type class, it is now possible to print anything, but it might not always be meaningful:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo { };</div>
<div class="line"><span class="comment">// prints some implementation-defined stuff representing foo</span></div>
<div class="line">print(std::cout, foo{});</div>
</div><!-- fragment --><p> One last thing that can be done with type classes is to explicitly disable instances. This can be useful if, for example, an instance for <code>Printable</code> is provided for some type but you would prefer to have a compile-time error if one tries to print an object of that type. To disable the faulty instance, simply specialize it and inherit from <code>disable</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>UserDefined { };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;UserDefined&gt; : disable { };</div>
</div><!-- fragment --><p> Now, trying to print an object of data type <code>UserDefined</code> will result in a compile-time error.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000062">Todo:</a></b></dt><dd><ul>
<li>Document type classes with operators.</li>
<li>Document how to instantiate <em>unary</em> type classes from inside a data type.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="tutorial-header_organization"></a>
Header organization</h1>
<hr/>
<p> The library is designed to be very modular while keeping the number of headers that must be included to get basic functionality reasonably low. The structure of the library is influenced by the structure of type classes and data types. Once you are familiar with the type classes and data types provided with the library, the header structure should feel intuitive.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000063">Todo:</a></b></dt><dd>Update this for the new core/ hierarchy and try to merge this with the file list generated by Doxygen.</dd></dl>
<ul>
<li><code><a class="el" href="hana_8hpp.html" title="Includes all the library components except the adapters for external libraries. ">boost/hana.hpp</a></code><br />
 This is the master header of the library. It includes the whole public interface of the library except adapters for external libraries, which must be included separately.</li>
<li><code>boost/hana/</code><ul>
<li><code>boost/hana/core/</code><ul>
<li><code><a class="el" href="datatype_8hpp.html" title="Defines boost::hana::datatype and boost::hana::datatype_t. ">boost/hana/core/datatype.hpp</a></code><br />
 This file defines everything required to define a new data type. This includes the <code>datatype</code> metafunction, <code>when</code>, <code>is_valid</code> and <code>operators</code>. By contract, all the other files in <code>boost/hana/core/</code> include this one, so there is no need to include it when something else in <code>boost/hana/core/</code> is already included.</li>
<li><code><a class="el" href="typeclass_8hpp.html" title="Defines BOOST_HANA_TYPECLASS and BOOST_HANA_BINARY_TYPECLASS. ">boost/hana/core/typeclass.hpp</a></code><br />
 This file defines everything required to define a new type class. This includes the <code>BOOST_HANA_{UNARY,BINARY}_TYPECLASS</code> macros and <code>disable</code>.</li>
<li><code><a class="el" href="is__a_8hpp.html" title="Defines boost::hana::is_a, boost::hana::is_an, and boost::hana::are. ">boost/hana/core/is_a.hpp</a></code><br />
 This file defines the <code>is_a</code> utility and friends.</li>
<li><code><a class="el" href="core_2convert_8hpp.html" title="Defines boost::hana::convert and boost::hana::to. ">boost/hana/core/convert.hpp</a></code><br />
 This file defines the conversion utilities <code>to</code> and <code>convert</code>.</li>
</ul>
</li>
<li><code><a class="el" href="core_8hpp.html" title="Defines the Core module. ">boost/hana/core.hpp</a></code> This file includes everything in <code>boost/hana/core/</code>.</li>
<li><code>boost/hana/[typeclass].hpp</code><br />
 A file of this type includes the whole definition of a type class <code>[typeclass]</code>. This includes all the type class methods, minimal complete definitions and laws related to the type class.</li>
<li><code>boost/hana/[typeclass]/[typeclass].hpp</code><br />
 A file of this type includes the definition of the type class structure (but not its members like <code>mcd</code>, <code>laws</code>, etc..) and the associated type class methods. It also defines the operators associated to its methods and the default-provided instances for builtin types, if there are any. Note that default-provided instances for non-builtin types are not defined in this header. This header is included by all other headers inside its directory.</li>
<li><code>boost/hana/[typeclass]/[mcd].hpp</code><br />
 A file of this type defines a minimal complete definition named <code>[mcd]</code> along with default-provided instances for non-builtin types, if any. It is possible for a type class to have several minimal complete definitions, in which case there are several such headers with a proper name.</li>
<li><code>boost/hana/[typeclass]/instance.hpp</code><br />
 Some type classes are such that all instances are forced to be isomorphic. In that case, it sometimes makes sense to provide an implementation of the unique instance. When such an instance is provided, it is defined in this header.</li>
<li><code>boost/hana/[datatype].hpp</code><br />
 A file of this type defines a data type named <code>[datatype]</code>. It defines all the type class instances associated to that data type, so that one only has to include the data type's header to get the full functionality it supports.</li>
<li><p class="startli"><code>boost/hana/ext/</code><br />
 This directory contains adapters for external libraries. This is the only part of the public interface which is not included by the master header, because that would make the master header dependent on those external libraries. Note that only the strict minimum required to adapt the external component is included in these headers (e.g. a forward declaration). This means that the definition of the external component should still be included when one wants to use it. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2tuple_8hpp.html">boost/hana/ext/std/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span> <span class="comment">// still required to create a tuple</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr std::tuple&lt;int, char, float&gt; xs{1, <span class="charliteral">&#39;2&#39;</span>, 3.0f};</div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(head(xs) == 1);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>boost/hana/sandbox/</code><br />
 This directory contains experimental code on which no guarantee whatsoever is made. It might not even compile and it will definitely not be stable.</li>
<li><code>boost/hana/detail/</code><br />
 This directory contains utilities required internally. Nothing in <code>detail/</code> is guaranteed to be stable, so you should not use it.</li>
</ul>
</li>
</ul>
<h3>Example</h3>
<p>Let's say I want to include <code>set</code>. I only have to include its header and I can use all the methods it supports right away:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="foreign_8hpp.html">boost/hana/foreign.hpp</a>&gt;</span> <span class="comment">// for comparing builtin types</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> xs = set(1, 2.2, <span class="charliteral">&#39;x&#39;</span>);</div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(elem(xs, <span class="charliteral">&#39;x&#39;</span>));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="tutorial-mastering"></a>
Mastering the library</h1>
<hr/>
<p> You now have everything you need to start using the library. From here on, mastering the library is only a matter of understanding and knowing how to use the general purpose type classes and data types provided with it, which is best done by looking at the reference documentation. At some point, you will probably also want to create your own type classes and data types that fit your needs better; go ahead, the library was intended to be used that way.</p>
<p>The structure of the reference (available in the menu to the left) goes as follow:</p><ul>
<li><a class="el" href="group__group-core.html">Core</a><br />
 Documentation for the core module, which contains everything needed to implement type classes, data types and related utilities. This is relevant if you need to extend the library, but otherwise the tutorial pretty much covered it all.</li>
<li><a class="el" href="group__group-functional.html">Functional</a><br />
 General purpose function objects that are generally useful in a purely functional setting. These are not tied to any type class or data type (currently).</li>
<li><a class="el" href="group__group-typeclasses.html">Type classes</a><br />
 Documentation for all the type classes provided with the library. Each type class is documented as follows:<ul>
<li>The methods it provides</li>
<li>The minimal complete definition(s) required to instantiate it</li>
<li>The laws that must be respected by its instances</li>
<li>Any additional type class specific information</li>
</ul>
</li>
<li><a class="el" href="group__group-datatypes.html">Data types</a><br />
 Documentation for all the data types provided with the library. Each data type is documented as follows:<ul>
<li>The type classes it instantiates, and how it does so</li>
<li>Methods tied to the data type but not to any type class</li>
<li>Any data type specific information</li>
</ul>
</li>
<li><a class="el" href="group__group-details.html">Details</a><br />
 Why did I document implementation details? That's a good question.</li>
</ul>
<p>I hope you enjoy using the library as much as I enjoyed writing it!</p>
<p>&ndash; Louis </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
