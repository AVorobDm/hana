<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a></li>
<li class="level1"><a href="#tutorial-introduction">Introduction</a></li>
<li class="level1"><a href="#tutorial-quickstart">Quick start</a><ul><li class="level2"><a href="#tutorial-quickstart-cheatsheet">Cheatsheet</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-heterogeneity">Heterogeneity and generalized types</a></li>
<li class="level1"><a href="#tutorial-type_computations">Type computations</a></li>
<li class="level1"><a href="#tutorial-constant">Constants, or setting constexpr straight</a><ul><li class="level2"><a href="#tutorial-constant-side_effects">Side effects</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-external_libraries">Integration with external libraries</a><ul><li class="level2"><a href="#tutorial-external_libraries-stl">The standard library</a></li>
<li class="level2"><a href="#tutorial-external_libraries-fusion">Boost.Fusion</a></li>
<li class="level2"><a href="#tutorial-external_libraries-mpl">Boost.MPL</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-performance_considerations">Performance considerations</a><ul><li class="level2"><a href="#tutorial-performance_considerations-compile_time">Compile-time performance</a></li>
<li class="level2"><a href="#tutorial-performance_considerations-run_time">Runtime performance</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-extending">Extending the library</a><ul><li class="level2"><a href="#tutorial-extending-tag_dispatching">Tag dispatching</a></li>
<li class="level2"><a href="#tutorial-extending-creating_concepts">Creating new concepts</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-header_organization">Header organization</a></li>
<li class="level1"><a href="#tutorial-using_the_reference">Using the reference</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> The seed that became this library was planted in late 2012, when I first started to reimplement the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> using C++11 in a project named <a href="http://github.com/ldionne/mpl11">MPL11</a>. In spring 2014, I applied to <a href="http://www.google-melange.com/gsoc/homepage/google/gsoc2014">Google Summer of Code</a> with that project for the Boost organization and got in. The goal was to polish the MPL11 and get it in Boost by the end of the summer. In May, before GSoC was started full steam, I presented the project at <a href="http://cppnow.org">C++Now</a> and had insightful conversations with several attendees. The idea that it was possible to unify the <a href="http://www.boost.org/doc/libs/release/libs/fusion/doc/html/index.html">Boost.Fusion</a> and the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> libraries made its way and I became convinced of it after writing the first prototype for what is now Boost.Hana. After working on Hana and polishing many rough edges during several months, Hana will soon go through informal and then formal reviews with the goal of being part of Boost.</p>
<p>Let the fun begin.</p>
<h1><a class="anchor" id="tutorial-introduction"></a>
Introduction</h1>
<hr/>
<p> Hana is a small (~ 13 KLOC), header-only replacement for Boost.MPL and Boost.Fusion, with more features as well. It boasts faster compile time performance than Boost.MPL or Boost.Fusion, and runtime performance on par or better than Boost.Fusion. It provides a unified way of manipulating types and values for a smoother metaprogramming experience. It is easy to extend in a ad-hoc manner and it provides out-of-the-box inter-operation with Boost.Fusion, Boost.MPL and the standard library. Hana is written against the C++14 standard.</p>
<p><b>Motivation</b><br />
For users that want to do extensive metaprogramming, Boost.MPL is clearly a very valuable tool. Its greatest weakness is that its liberal use leads to long compile times. For users that want to compute on sequences of heterogeneously-typed values, Boost.Fusion is also a very valuable tool. It also suffers from long compile times when used extensively.</p>
<p>The C++11 and C++14 standards have made many metaprogramming tasks a lot easier and more straightforward to accomplish. Hana thus provides the functionality of Boost.MPL and Boost.Fusion with more straightforward (and thus more compile-time efficient) implementations.</p>
<p><b>Warning: functional programming ahead</b><br />
Programming with heterogeneous objects is inherently functional &ndash; since it is impossible to modify the type of an object, a new object must be introduced instead, which rules out mutation. Unlike previous metaprogramming libraries like Boost.MPL and Boost.Fusion, I have decided to embrace this and as a result, Hana uses an almost purely functional style of programming. However, this style of programming influences not only the internal implementation; it also leaks into the interface. Hence, if you continue beyond this point, be prepared to see quite a bit of functional programming along the way.</p>
<p>In particular, unlike previous metaprogramming libraries, the design of Hana is not based on that of the STL. Instead, it is inspired by several standard and non standard modules written for the Haskell programming language. Through experience, I have found this to be much more expressive, flexible and easy to use while not sacrificing any performance given the heterogeneously typed setting. However, as a result, many concepts used in Hana will be unfamiliar to C++ programmers without a knowledge of FP, to whom I say: be assured that the reward is totally worth it.</p>
<h1><a class="anchor" id="tutorial-quickstart"></a>
Quick start</h1>
<hr/>
<p> This tutorial assumes the reader is already familiar with basic metaprogramming and the <a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14 standard</a>. First, let's include the library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hana_8hpp.html">boost/hana.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
</div><!-- fragment --><p> Unless specified otherwise, the documentation assumes that the above lines are present before examples and code snippets. Also note that finer grained headers are provided and will be explained in the <a class="el" href="index.html#tutorial-header_organization">Header organization</a> section. If you are reading this documentation, chances are you already know <code>std::tuple</code> and <code>std::make_tuple</code>. Hana provides its own <code>tuple</code> and <code>make_tuple</code> implementations:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> xs = make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>});</div>
</div><!-- fragment --><p> <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> is the usual way of creating a tuple in Hana. Simply put, <code>make</code> is used all around Hana to create different types of objects, thus generalizing the <code>std::make_xxx</code> family of functions. You have probably observed how the <code>auto</code> keyword is used when defining <code>xs</code>; it is often useful to let the compiler deduce the type of a tuple, but sometimes it is necessary to specify it. This is of course also possible:</p>
<div class="fragment"><div class="line">_tuple&lt;int, char, std::string&gt; xs{1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>};</div>
</div><!-- fragment --><p> Hana also provides several basic operations and higher level algorithms that can be performed on heterogeneous sequences. For example, here are a couple of basic operations; the higher level algorithms will be explained later:</p>
<div class="fragment"><div class="line"><span class="comment">// BOOST_HANA_RUNTIME_CHECK is equivalent to assert</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(last(xs) == <span class="stringliteral">&quot;345&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(tail(xs) == make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>}));</div>
<div class="line"></div>
<div class="line">static_assert(!is_empty(xs), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(length(xs) == 3u, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(at(int_&lt;1&gt;, xs) == <span class="charliteral">&#39;2&#39;</span>);</div>
</div><!-- fragment --><p> An interesting observation in the previous example is that <code>is_empty</code> and <code>length</code> both return a constant expression, even though the tuple they were called on is not a constant expression (it couldn't be one because it contains a <code>std::string</code>). Indeed, the size of the sequence is known at compile-time regardless of its contents, so it only makes sense that Hana does not throw away this information. If that seems surprising, think about <code>std::tuple</code>:</p>
<div class="fragment"><div class="line">std::tuple&lt;int, char, std::string&gt; xs{1, <span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>}};</div>
<div class="line">static_assert(std::tuple_size&lt;decltype(xs)&gt;::value != 0, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Since the size of the tuple is encoded in it's type, it's always available at compile-time regardless of whether the tuple is <code>constexpr</code> or not. How this works in Hana will be explained in detail later, but the trick is that <code>is_empty</code> returns something like a <code>std::integral_constant</code>, which can always be converted to an integral value at compile-time. Hana also provides high level algorithms to manipulate tuples and other heterogeneous containers. One example is <code>transform</code> (analogous to <code>std::transform</code>), which takes a sequence and a function, maps the function over each element of the sequence and returns the result in a new sequence:</p>
<div class="fragment"><div class="line"><span class="comment">// BOOST_HANA_CONSTEXPR_CHECK is equivalent to assert, but it would be</span></div>
<div class="line"><span class="comment">// equivalent to static_assert if lambdas could appear in constant expressions.</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    transform(make&lt;Tuple&gt;(1, 2, 3), [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; }) ==</div>
<div class="line">    make&lt;Tuple&gt;(2, 3, 4)</div>
<div class="line">);</div>
</div><!-- fragment --><p> Unlike with Boost.Fusion, Hana algorithms always return a new sequence containing the result. Instead, Boost.Fusion returned views which held the original sequence by reference. This could lead to subtle lifetime issues, which can be avoided by using value semantics. Hana uses perfect forwarding heavily to ensure the best runtime performance possible. Other useful algorithms worth mentionning are:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    count(make&lt;Tuple&gt;(1, 2, 3, 4, 5), [](<span class="keywordtype">int</span> i) {</div>
<div class="line">        <span class="keywordflow">return</span> i &gt; 2;</div>
<div class="line">    }) == 3u</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    filter(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, <span class="keyword">nullptr</span>, 7.3f), [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> std::is_floating_point&lt;decltype(x)&gt;{};</div>
<div class="line">    }) == make&lt;Tuple&gt;(3.0, 7.3f)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>std::literals; <span class="comment">// the s user-defined literal creates std::strings</span></div>
<div class="line"><span class="keyword">auto</span> pangram = make&lt;Tuple&gt;(</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;The&quot;</span>s, <span class="stringliteral">&quot;quick&quot;</span>s, <span class="stringliteral">&quot;brown&quot;</span>s),</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;fox&quot;</span>s, <span class="stringliteral">&quot;jumps&quot;</span>s, <span class="stringliteral">&quot;over&quot;</span>s, <span class="stringliteral">&quot;the&quot;</span>s, <span class="stringliteral">&quot;lazy&quot;</span>s),</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;dog&quot;</span>s)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    flatten(pangram) ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;The&quot;</span>, <span class="stringliteral">&quot;quick&quot;</span>, <span class="stringliteral">&quot;brown&quot;</span>, <span class="stringliteral">&quot;fox&quot;</span>, <span class="stringliteral">&quot;jumps&quot;</span>, <span class="stringliteral">&quot;over&quot;</span>, <span class="stringliteral">&quot;the&quot;</span>, <span class="stringliteral">&quot;lazy&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment --><p> There are many more operations and algorithms that can be performed on sequences; they are documented by their respective concept (<a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a>, <a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a>, <a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a>, <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a>, etc...).</p>
<h2><a class="anchor" id="tutorial-quickstart-cheatsheet"></a>
Cheatsheet</h2>
<p>For quick reference, here's a cheatsheet of the most useful functions and algorithms. Always keep in mind that the algorithms return their result as a new sequence and no in-place mutation is ever performed.</p>
<table class="doxtable">
<tr>
<th align="center">function </th><th align="center">concept </th><th align="center">description  </th></tr>
<tr>
<td align="center"><code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;(x1, ..., xN)</code> </td><td align="center">None </td><td align="center">Returns a tuple containing the given elements. </td></tr>
<tr>
<td align="center"><code>transform(sequence, f)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="center">Apply a function to each element of a sequence and return the result. </td></tr>
<tr>
<td align="center"><code>adjust(sequence, predicate, f)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="center">Apply a function to each element of a sequence satisfying some predicate and return the result. </td></tr>
<tr>
<td align="center"><code>replace(sequence, predicate, value)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="center">Replace the elements of a sequence that satisfy some predicate by some value. </td></tr>
<tr>
<td align="center"><code>fill(sequence, value)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="center">Replace all the elements of a sequence with some value. </td></tr>
<tr>
<td align="center"><code>foldl(sequence, state, f)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Accumulates the elements of a sequence from the left. Equivalent to <code>f(...f(f(state, x1), x2), ..., xN)</code>. </td></tr>
<tr>
<td align="center"><code>foldr(sequence, state, f)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Accumulates the elements of a sequence from the right. Equivalent to <code>f(x1, f(x2, ..., f(xN, state))...)</code>. </td></tr>
<tr>
<td align="center"><code>for_each(sequence, f)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Call a function on each element of a sequence. Returns <code>void</code>. </td></tr>
<tr>
<td align="center"><code>length(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Returns the length of a sequence as an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>{minimum, maximum}_by(predicate, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Returns the smallest/greatest element of a sequence w.r.t. a predicate. </td></tr>
<tr>
<td align="center"><code>{minimum, maximum}_by(predicate, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Returns the smallest/greatest element of a sequence. The elements must be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>. </td></tr>
<tr>
<td align="center"><code>count(sequence, predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Returns the number of elements that satisfy the predicate. </td></tr>
<tr>
<td align="center"><code>unpack(sequence, f)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> </td><td align="center">Calls a function with the contents of a sequence. Equivalent to <code>f(x1, ..., xN)</code>. </td></tr>
<tr>
<td align="center"><code>head(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="center">Returns the first element of a sequence. </td></tr>
<tr>
<td align="center"><code>tail(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="center">Returns all the elements except the first one. Analogous to <code>pop_front</code>. </td></tr>
<tr>
<td align="center"><code>is_empty(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="center">Returns whether a sequence is empty as an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>at(index, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="center">Returns the n-th element of a sequence. The index must be an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>last(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="center">Returns the last element of a sequence. </td></tr>
<tr>
<td align="center"><code>drop(number, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="center">Drops the n first elements from a sequence and returns the rest. <code>n</code> must be an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>drop_{while,until}(sequence, predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="center">Drops elements from a sequence while/until a predicate is satisfied. The predicate must return an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>flatten(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> </td><td align="center">Flatten a sequence of sequences, a bit like <code>std::tuple_cat</code>. </td></tr>
<tr>
<td align="center"><code>prepend(value, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="center">Prepend an element to a sequence. </td></tr>
<tr>
<td align="center"><code>append(sequence, value)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="center">Append an element to a sequence. </td></tr>
<tr>
<td align="center"><code>concat(sequence1, sequence2)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="center">Concatenate two sequences. </td></tr>
<tr>
<td align="center"><code>filter(sequence, predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="center">Remove all the elements that do not satisfy a predicate. The predicate must return an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>{any,none,all}(sequence, predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="center">Returns whether any/none/all of the elements of the sequence satisfy some predicate. </td></tr>
<tr>
<td align="center"><code>{any,none,all}_of(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="center">Returns whether any/non/all of the elements of a sequence are true-valued. </td></tr>
<tr>
<td align="center"><code>elem(sequence, value)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="center">Returns whether an object is in a sequence. </td></tr>
<tr>
<td align="center"><code>find(sequence, predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="center">Find the first element of a sequence satisfying the predicate and return <code>just</code> it, or return <code>nothing</code>. See <a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a>. </td></tr>
<tr>
<td align="center"><code>lookup(sequence, value)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="center">Find the first element of a sequence which is equal to some value and return <code>just</code> it, or return nothing. See <a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a>. </td></tr>
<tr>
<td align="center"><code>group_by(predicate, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Group the adjacent elements of a sequence which all satisfy (or all do not satisfy) some predicate. </td></tr>
<tr>
<td align="center"><code>group(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Group adjacent elements of a sequence that compare equal. The elements must be <a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a>. </td></tr>
<tr>
<td align="center"><code>init(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Returns all the elements of a sequence, except the last one. Analogous to <code>pop_back</code>. </td></tr>
<tr>
<td align="center"><code>partition(sequence, predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Partition a sequence into a pair of elements that satisfy some predicate, and elements that do not satisfy it. </td></tr>
<tr>
<td align="center"><code>remove_at(index, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Remove the element at the given index. The index must be an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>reverse(sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Reverse the order of the elements in a sequence. </td></tr>
<tr>
<td align="center"><code>slice(sequence, from, to)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Returns the elements of a sequence at indices contained in <code>[from, to)</code>. </td></tr>
<tr>
<td align="center"><code>sort_by(predicate, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Sort the elements of a sequence according to some predicate. The sort is stable. </td></tr>
<tr>
<td align="center"><code>sort(predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Sort the elements of a sequence, which must be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>. The sort is stable. </td></tr>
<tr>
<td align="center"><code>take(number, sequence)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Take the first n elements of a sequence. n must be an <code>integral_constant</code>. </td></tr>
<tr>
<td align="center"><code>take_{while,until}(sequence, predicate)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Take elements of a sequence while/until some predicate is satisfied, and return that. </td></tr>
<tr>
<td align="center"><code>zip(sequence1, ..., sequenceN)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Zip <code>N</code> sequences into a sequence of tuples. </td></tr>
<tr>
<td align="center"><code>zip.with(f, sequence1, ..., sequenceN)</code> </td><td align="center"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="center">Zip <code>N</code> sequences with a <code>N</code>-ary function. </td></tr>
</table>
<h1><a class="anchor" id="tutorial-heterogeneity"></a>
Heterogeneity and generalized types</h1>
<hr/>
<p> The purpose of Hana is to manipulate heterogeneous objects. Before we dive any deeper into the library, let's ask a fundamental question: does it even make sense to manipulate heterogeneous objects?</p>
<p>For the sake of the explanation, let me make the following claim: a function template that compiles with an argument of every possible type must have a trivial implementation, in the sense that it must do nothing with its argument except perhaps return it. Hence, for a function template to do something interesting, it must fail to compile for some set of arguments. While I won't try to prove that claim formally &ndash; it might be false in some corner cases &ndash;, think about it for a moment. Let's say I want to apply a function to each element of an heterogeneous sequence:</p>
<div class="fragment"><div class="line">for_each([x, y, z], f)</div>
</div><!-- fragment --><p>The first observation is that <code>f</code> must have a templated call operator because <code>x</code>, <code>y</code> and <code>z</code> have different types. The second observation is that without knowing anything specific about the types of <code>x</code>, <code>y</code> and <code>z</code>, it is impossible for <code>f</code> to do anything meaningful. For example, could it print its argument? Of course not, since it does not know whether <code>std::cout &lt;&lt; x</code> is well-formed! In order to do something meaningful, the function has to put constraints on its arguments; it has to define a domain which is more specific that the set of all types, and hence it can't be <em>fully</em> polymorphic, even if we do not have a way to express this in C++ (right now). So while we're manipulating types that are technically heterogeneous, they still conceptually need something in common, or it wouldn't be possible to do anything meaningful with them. We'll still say that we're manipulating heterogeneous objects, but always keep in mind that the objects we manipulate share something, and are hence homogeneous in <em>some way</em>.</p>
<blockquote class="doxtable">
<p>Another way to see this is that we programmers <b>need</b> concepts to do useful things, whether or not there is language support for expressing them. </p>
</blockquote>
<p>Pushing this to the extreme, some type families represent exactly the same entity, except they must have a different C++ type because the language requires them to. For example, this is the case of <code>_tuple&lt;...&gt;</code>. In our context, we would like to see <code>_tuple&lt;int, int&gt;</code> and <code>_tuple&lt;int, long, float&gt;</code> as different representations for the same data structure (a "tuple"), but the C++ language requires us to give them different types. In Hana, we associate what we call a <em>generalized type</em> (we also say <em>data type</em> and sometimes <em>gtype</em>) to each type family. A generalized type is simply a tag (like in MPL or Fusion) which is associated to all the types in a family through the <code>datatype</code> metafunction. For <code>_tuple&lt;...&gt;</code>, this generalized type is <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code>; other constructs in Hana also follow this convention of naming their generalized type with a capital letter.</p>
<p>Just like C++ templates are families of types that are parameterized by some other type, it makes sense to speak of parameterized generalized types. A parameterized <em>gtype</em> is simply a <em>gtype</em> which depends on other generalized types. You might have seen it coming, but this is actually the case for <code>_tuple</code>, whose <em>gtype</em> can be seen as depending on the <em>gtype</em> of the objects it contains. However, take good note that <b>parameterized generalized types in Hana only live at the documentation level</b>. While enforcing proper parametricity would make the library more mathematically correct, I fear it would also make it less usable given the lack of language support. Given a parametric <em>gtype</em> <code>F</code>, we use <code>F(T)</code> to denote the "application" of <code>F</code> to another <em>gtype</em> <code>T</code>. While this is analogous to "applying" a C++ template to a type, we purposefully do not use the <code>F&lt;T&gt;</code> notation because parametric gtypes are not necessarily templates in Hana and that would be more confusing than helpful.</p>
<p>As an example, <code>_tuple&lt;int, int&gt;</code> conceptually has a gtype of <code>Tuple(int)</code>, but its actual gtype (outside of the documentation) is just <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code>. What about <code>_tuple&lt;int, long&gt;</code>? Well, <code>int</code> and <code>long</code> are embedded in the same mathematical universe, so we could say that it's a <code>Tuple(Number)</code>, where <code>Number</code> is some generalized type containing all the numeric types. What about <code>_tuple&lt;int, void&gt;</code>? First, that won't compile. But why would you create a sequence of objects that have nothing in common? What can you do with that?</p>
<p>These generalized types are useful for several purposes, for example creating a tuple with <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> and documenting pseudo-signatures for the functions provided in this library. Another important role is to customize algorithms; see the section on <a class="el" href="index.html#tutorial-extending-tag_dispatching">tag-dispatching</a> for more information. Finally, you can also consult the reference of the <a class="el" href="structboost_1_1hana_1_1datatype.html">datatype</a> metafunction for details on how to specify the generalized type of a family of types.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000059">Todo:</a></b></dt><dd>There is obviously a connection between generalized types and concepts. I think that generalized types are concepts whose models are unique up to a unique isomorphism. Still, it is necessary to distinguish between isomorphic models when we want to provide an implementation or create an object. If you see how it all fits together better than I do right now, let me know.</dd></dl>
<h1><a class="anchor" id="tutorial-type_computations"></a>
Type computations</h1>
<hr/>
<p> At this point, if you are interested in doing Boost.MPL-like computations on types, you might be wondering how is Hana going to help you. Do not despair. Hana provides a way to perform type-level computations with a great deal of expressiveness by representing types as values. This is a completely new way of metaprogramming, and you should try to set your MPL habits aside for a bit if you want to become proficient with Hana. Basically, Hana provides a way of representing a type <code>T</code> as an object, and it also provides a way of applying type transformations to those objects as-if they were functions, by wrapping them properly. Concretely;</p>
<div class="fragment"><div class="line"><span class="comment">// We &quot;lift&quot; the `int` type to a value, and the `std::add_pointer` metafunction</span></div>
<div class="line"><span class="comment">// to a regular function. Then, we can call that metafunction with a regular</span></div>
<div class="line"><span class="comment">// function call syntax.</span></div>
<div class="line"><span class="keyword">auto</span> t = type&lt;int&gt;;</div>
<div class="line"><span class="keyword">auto</span> add_pointer = metafunction&lt;std::add_pointer&gt;;</div>
<div class="line">static_assert(add_pointer(t) == type&lt;int*&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The <code>type&lt;int&gt;</code> expression is <em>not</em> a type! It is an object, more precisely a <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Variable_templates">variable template</a> defined roughly as <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">constexpr the-type-of-the-<span class="keywordtype">object</span> type{};</div>
</div><!-- fragment --></dd></dl>
<p>Now, since <code>type&lt;...&gt;</code> is just an object, we can store it in a heterogeneous sequence like a tuple. This also means that all the algorithms that apply to usual heterogeneous sequences are available to us, which is nice:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> types = make&lt;Tuple&gt;(type&lt;int&gt;, type&lt;char const&gt;, type&lt;void&gt;);</div>
<div class="line">static_assert(</div>
<div class="line">    transform(types, metafunction&lt;std::add_pointer&gt;) ==</div>
<div class="line">    make&lt;Tuple&gt;(type&lt;int*&gt;, type&lt;char const*&gt;, type&lt;void*&gt;)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Also, since typing <code>type&lt;...&gt;</code> can be annoying at the end of the day, Hana provides a variable template called <code>tuple_t</code>, which creates a tuple of <code>type&lt;...&gt;</code>s:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> types = tuple_t&lt;int, char const, void&gt;;</div>
<div class="line">static_assert(types == make&lt;Tuple&gt;(type&lt;int&gt;, type&lt;char const&gt;, type&lt;void&gt;), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    transform(types, metafunction&lt;std::add_pointer&gt;) ==</div>
<div class="line">    tuple_t&lt;int*, char const*, void*&gt;</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> I won't say much more about <code>type</code> and <code>metafunction</code> (see the <a class="el" href="structboost_1_1hana_1_1_type.html">reference</a>), but the last essential thing to know is that <code>decltype(type&lt;T&gt;)</code> is a MPL nullary metafunction. In other words, <code>decltype(type&lt;T&gt;)::type</code> is an alias to <code>T</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> T = decltype(t)::type;</div>
<div class="line">static_assert(std::is_same&lt;T, int&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> This way, you can recover the result of a type computation by unwrapping it with <code>decltype(...)::type</code>. Hence, doing type-level metaprogramming with Hana is usually a three step process:</p><ol type="1">
<li>Wrap the types with <code>type&lt;...&gt;</code> so they become values</li>
<li>Apply whatever type transformation <code>F</code> by using <code>metafunction&lt;F&gt;</code></li>
<li>Unwrap the result with <code>decltype(...)::type</code></li>
</ol>
<p>At this point, you must be thinking this is incredibly cumbersome. Why on earth would you want to write</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    decltype(metafunction&lt;std::add_pointer&gt;(type&lt;int&gt;))::type,</div>
<div class="line">    <span class="keywordtype">int</span>*</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> instead of simply writing</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    std::add_pointer&lt;int&gt;::type,</div>
<div class="line">    <span class="keywordtype">int</span>*</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> The answer is that of course you don't! For simple type computations such as this one, where you know the type transformation and the type itself, just use the most straightforward way of doing it. However, for more complex type computations, the syntactic noise of this three step process becomes negligible in light of the expressiveness gain of working with values instead of types inside that computation. Indeed, since we're working inside real functions instead of clunky structs, we can use variables, lambdas and a reasonable syntax. It also means that we don't need <code>typename</code> all around the place, which is nice (but can be avoided in MPL world with aliases). But this syntactic unification is not only some sugar for our eyes; it also means that some of our "metafunctions" will actually also work on normal values. Hence, any piece of generic enough code will work with both types and values out-of-the-box, without any extra work on our side. With previous approaches to type-level static metaprogramming, we had to reimplement type sequences and basically everything else from the ground up. For example, consider the simple problem of applying a transformation to each element in a sequence of sequences. For some metafunction <code>f</code> and sequence</p>
<div class="fragment"><div class="line">[</div>
<div class="line">    [x1, x2, ..., xN],</div>
<div class="line">    [y1, y2, ..., yM],</div>
<div class="line">    ...</div>
<div class="line">    [z1, z2, ..., zK]</div>
<div class="line">]</div>
</div><!-- fragment --><p>we want to produce a sequence</p>
<div class="fragment"><div class="line">[</div>
<div class="line">    [f&lt;x1&gt;::type, f&lt;x2&gt;::type, ..., f&lt;xN&gt;::type],</div>
<div class="line">    [f&lt;y1&gt;::type, f&lt;y2&gt;::type, ..., f&lt;yM&gt;::type],</div>
<div class="line">    ...</div>
<div class="line">    [f&lt;z1&gt;::type, f&lt;z2&gt;::type, ..., f&lt;zK&gt;::type]</div>
<div class="line">]</div>
</div><!-- fragment --><p>With Hana, this is very straightforward, and in fact the resulting algorithm will even work when given a regular function and values instead of a metafunction and types:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> apply_to_all = [](<span class="keyword">auto</span> sequences, <span class="keyword">auto</span> f) {</div>
<div class="line">    <span class="keywordflow">return</span> transform(sequences, [=](<span class="keyword">auto</span> sequence) {</div>
<div class="line">        <span class="keywordflow">return</span> transform(sequence, f);</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> types = make&lt;Tuple&gt;(</div>
<div class="line">    tuple_t&lt;int, char&gt;,</div>
<div class="line">    tuple_t&lt;void, std::string, double&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    apply_to_all(types, metafunction&lt;std::add_pointer&gt;) ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        tuple_t&lt;int*, char*&gt;,</div>
<div class="line">        tuple_t&lt;void*, std::string*, double*&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p><code>BOOST_HANA_CONSTANT_CHECK</code> is essentially equivalent to <code>static_assert</code>; see the <a class="el" href="group__group-assertions.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">reference</a> for more information. </p>
</blockquote>
<p>However, expressing the same algorithm using Boost.MPL requires using lambda expressions, which are much more limited than plain lambdas. It also requires being at class or global scope, which means that you can't create this algorithm on the fly (e.g. inside a function), and it will only work on types!</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Sequences, <span class="keyword">typename</span> F&gt;</div>
<div class="line"><span class="keyword">struct </span>apply_to_all</div>
<div class="line">    : mpl::transform&lt;</div>
<div class="line">        Sequences,</div>
<div class="line">        mpl::transform&lt;mpl::_1, F&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> types = mpl::vector&lt;</div>
<div class="line">    mpl::vector&lt;int, char&gt;,</div>
<div class="line">    mpl::vector&lt;void, std::string, double&gt;</div>
<div class="line">&gt;;</div>
<div class="line"></div>
<div class="line">static_assert(mpl::equal&lt;</div>
<div class="line">    apply_to_all&lt;types, mpl::quote1&lt;std::add_pointer&gt;&gt;::type,</div>
<div class="line">    mpl::vector&lt;</div>
<div class="line">        mpl::vector&lt;int*, char*&gt;,</div>
<div class="line">        mpl::vector&lt;void*, std::string*, double*&gt;</div>
<div class="line">    &gt;,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// mpl::equal was seemingly not designed for deep comparisons, so we</span></div>
<div class="line">    <span class="comment">// need this tricky line for it to do what we want.</span></div>
<div class="line">    mpl::equal&lt;mpl::_1, mpl::_2, mpl::quote2&lt;std::is_same&gt;&gt;</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>That's it for the introduction to type computations with Hana, but there are a couple of interesting examples scattered in the documentation if you want more. There's also a minimal reimplementation of the MPL using Hana under the hood in <code>example/mini_mpl.cpp</code>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000060">Todo:</a></b></dt><dd><ul>
<li>Provide links to the scattered examples, and also to example/mini_mpl. For some reason, I can't get Doxygen to generate a link.</li>
<li>Expand this section to explain the philosophy behind Hana's metaprogramming paradigm, i.e. that you only retrieve the types at the end and that you do not try to represent everything as a type.</li>
<li>Write a cheatsheet mapping common MPL/Fusion idioms to idiomatic Hana code. Maybe this should go in some Appendix?</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="tutorial-constant"></a>
Constants, or setting constexpr straight</h1>
<hr/>
<p> In C++, the border between compile-time and runtime is hazy, a fact that is even more true with the introduction of <a href="http://en.wikipedia.org/wiki/C%2B%2B11#constexpr_.E2.80.93_Generalized_constant_expressions">generalized constant expressions</a> in C++11. However, being able to manipulate heterogeneous objects is all about understanding that border and then crossing it at one's will. The goal of this section is to set things straight with <code>constexpr</code>; to understand which problems it can solve and which ones it can't. Let's start off with a <a href="http://www.gotw.ca/gotw/index.htm">GOTW</a> style question: do you think the following code should compile, and why?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">constexpr T assert_positive(T i) {</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keywordtype">int</span> i = 2;</div>
<div class="line">    assert_positive(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The right answer is "no". The error given by Clang goes like</p>
<div class="fragment"><div class="line">error: static_assert expression is not an integral constant expression</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">                  ^~~~~</div>
</div><!-- fragment --><p>The problem is that when you are in a function (<code>constexpr</code> or otherwise), you can't use an argument as a constant expression, even if the argument turns out to be a constant expression when you call the function. If you are surprised, consider the following code; the function is not a template anymore, which doesn't change anything with respect to the <code>constexpr</code>-ness of the argument if you think about it. Yet, the answer is now obvious:</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> assert_positive(<span class="keywordtype">int</span> i) {</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keywordtype">int</span> i = 2;</div>
<div class="line">    assert_positive(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Actually, since the body of <code>assert_positive</code> is not dependent anymore, Clang does not even reach <code>main</code> before giving the same error as before. Now, this is not a big problem for static assertions because we have <a href="http://stackoverflow.com/a/8626450/627587">another way</a> of reporting errors inside <code>constexpr</code> functions. However, it also means that we can't use an argument as a non-type template parameter, since that requires a constant expression. In other words, we can't create types that are dependent on the <em>value</em> of an argument in C++, which is nothing new if you think about it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> i&gt;</div>
<div class="line"><span class="keyword">struct </span>foo { };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i) {</div>
<div class="line">    foo&lt;i&gt; x; <span class="comment">// obviously won&#39;t work</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In particular, this means that the return type of a function can't depend on the value of its arguments; it may only depend on their type, and <code>constexpr</code> can't change this fact. This is of utmost importance to us, because we're interested in manipulating heterogeneous objects and eventually returning them from functions. Some of these functions might want to return an object of type <code>T</code> in one case and an object of type <code>U</code> in the other; from our little analysis, we now know that these "cases" will have to depend on information encoded in the <em>types</em> of the arguments, not in their <em>values</em>.</p>
<p>To represent this fact, Hana defines the concept of a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>, which is an object from which a constant expression may always be obtained, regardless of the <code>constexpr</code>-ness of the object. <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s provide a way to obtain that constant expression through the use of the <code>value</code> function. Specifically, for any <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> <code>c</code>, the following program must be valid:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keywordtype">void</span> f(X x) {</div>
<div class="line">    constexpr <span class="keyword">auto</span> y = value(x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    f(c);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This law that must be respected by <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s expresses the minimal requirement that we're able to retrieve a constant expression from an object, even if that object isn't a constant expression. There is no restriction on what the type of the constant expression might be, but it should be documented. Hana provides a model of this concept called an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a></code>; it encodes a compile-time value of an integral type, and you can think of it as a <code>std::integral_constant</code>. Before going on to the next section, you probably want to take a look at the <a class="el" href="structboost_1_1hana_1_1_integral_constant.html">reference documentation</a> for <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a></code>, which explains how to create these objects and what you can expect from them.</p>
<h2><a class="anchor" id="tutorial-constant-side_effects"></a>
Side effects</h2>
<dl class="section note"><dt>Note</dt><dd>Before reading this section, you should be familiar with the <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> concept. Also note that this section contains somewhat advanced material, and it can safely be skipped during a first read.</dd></dl>
<p>Let me ask a tricky question. Is the following code valid?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) { <span class="keywordflow">return</span> x; }</div>
<div class="line"></div>
<div class="line">static_assert(value(identity(bool_&lt;true&gt;)), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>The answer is "no", but the reason might not be obvious at first. Even more puzzling is that the following code is perfectly valid:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) { <span class="keywordflow">return</span> x; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> x = identity(bool_&lt;true&gt;);</div>
<div class="line">static_assert(value(x), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To understand why the compiler can't possibly evaluate the first assertion at compile-time, notice that <code>identity</code> was not marked <code>constexpr</code> and consider the following alternative (but valid) definition for <code>identity</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Good luck in evaluating this at compile-time!&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The signature of the function did not change; the function could even have been defined in a separate source file. However, it is now obvious that the compiler can't evaluate that expression at compile-time. On the other hand, when we write</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Good luck in evaluating this at compile-time!&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> x = identity(bool_&lt;true&gt;);</div>
<div class="line">static_assert(value(x), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> we're telling the compiler to perform those potential side effects during the dynamic initialization phase! Then, we use <code>value</code> to return the compile-time value associated to its argument. Also note that <code>value</code> takes a <code>const&amp;</code> to its argument; if it tried taking it by value, we would be reading from a non-<code>constexpr</code> variable to do the copying, and that could hide side-effects.</p>
<h1><a class="anchor" id="tutorial-external_libraries"></a>
Integration with external libraries</h1>
<hr/>
<h2><a class="anchor" id="tutorial-external_libraries-stl"></a>
The standard library</h2>
<h2><a class="anchor" id="tutorial-external_libraries-fusion"></a>
Boost.Fusion</h2>
<h2><a class="anchor" id="tutorial-external_libraries-mpl"></a>
Boost.MPL</h2>
<h1><a class="anchor" id="tutorial-performance_considerations"></a>
Performance considerations</h1>
<hr/>
<h2><a class="anchor" id="tutorial-performance_considerations-compile_time"></a>
Compile-time performance</h2>
<h2><a class="anchor" id="tutorial-performance_considerations-run_time"></a>
Runtime performance</h2>
<h1><a class="anchor" id="tutorial-extending"></a>
Extending the library</h1>
<hr/>
<p> Because of its modular design, Hana can be extended in a ad-hoc manner very easily. Actually, all the functionality of the library is provided through this ad-hoc customization mechanism.</p>
<h2><a class="anchor" id="tutorial-extending-tag_dispatching"></a>
Tag dispatching</h2>
<p>Tag dispatching is a generic programming technique for picking the right implementation of a function depending on the type of the arguments passed to the function. The usual mechanism for overriding a function's behavior is overloading. Unfortunately, this mechanism is not always convenient when dealing with families of related types having different C++ types, or with objects of unspecified types as is often the case in Hana. For example, consider trying to overload a function for all Boost.Fusion vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <span class="keyword">function</span>(boost::fusion::vector&lt;T...&gt; v) {</div>
<div class="line">    <span class="comment">// whatever</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>If you know Boost.Fusion, then you probably know that it won't work. This is because Boost.Fusion vectors are not necessarily specializations of the <code>boost::fusion::vector</code> template. Fusion vectors also exist in numbered forms, which are all of different types:</p>
<div class="fragment"><div class="line">boost::fusion::vector1&lt;T&gt;</div>
<div class="line">boost::fusion::vector2&lt;T, U&gt;</div>
<div class="line">boost::fusion::vector3&lt;T, U, V&gt;</div>
<div class="line">...</div>
</div><!-- fragment --><p>This is an implementation detail required by the lack of variadic templates in C++03 that leaks into the interface. This is unfortunate, but we need a way to work around it. To do so, we use an infrastructure with three distinct components:</p>
<ol type="1">
<li>A metafunction associating a single tag to every type in a family of related types. In Hana, we use the generalized type of an object, which is accessible through the <code>datatype</code> metafunction.</li>
<li>A function belonging to the public interface of the library, for which we'd like to be able to provide a customized implementation.</li>
<li>An implementation for the function, parameterized with the data type(s) of the argument(s) passed to the function.</li>
</ol>
<p>When the public interface function is called, it will use the metafunction on its argument(s) (or a subset thereof) to obtain their data type(s) and redirect to the implementation associated to those data type(s). For example, a basic setup for tag dispatching of a function that prints its argument to a stream would look like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Datatype&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::ostream&amp; os, X x) {</div>
<div class="line">        <span class="comment">/* possibly some default implementation */</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(std::ostream&amp; os, X x) {</div>
<div class="line">    <span class="keyword">using</span> Datatype = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt;X&gt;::type</a>;</div>
<div class="line">    <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">print_impl&lt;Datatype&gt;::apply</a>(os, x);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Then, if you want to customize the behavior of the <code>print</code> function for some user defined family of types, you only need to specialize the <code>print_impl</code> template for the tag representing the whole family of types:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl&lt;UserDefinedDatatype&gt; {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::ostream&amp; os, X x) {</div>
<div class="line">        <span class="comment">/* a custom implementation for some data type */</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="tutorial-extending-creating_concepts"></a>
Creating new concepts</h2>
<h1><a class="anchor" id="tutorial-header_organization"></a>
Header organization</h1>
<hr/>
<p> The library is designed to be modular while keeping the number of headers that must be included to get basic functionality reasonably low. The structure of the library was also intentionally kept simple, because we all love simplicity.</p>
<ul>
<li><code><a class="el" href="hana_8hpp.html" title="Includes all the library components except the adapters for external libraries. ">boost/hana.hpp</a></code><br />
 This is the master header of the library. It includes the whole public interface of the library except adapters for external libraries, which must be included separately.</li>
<li><code>boost/hana/</code><br />
 This is the main directory of the library containing the definitions of concepts and data types. A file of the form <code>boost/hana/[XXX].hpp</code> contains the definition for the concept or data type named <code>XXX</code>.<ul>
<li><code>boost/hana/core/</code><br />
 This subdirectory contains the machinery for tag-dispatching and other related utilities like <code>make</code> and <code>to</code>.</li>
<li><code>boost/hana/fwd/</code><br />
 This subdirectory contains the forward declaration of every concept and data type in the library. Basically, <code>boost/hana/fwd/[XXX].hpp</code> is the forward declaration for the concept or data type named <code>XXX</code>.</li>
<li><code>boost/hana/functional/</code><br />
 This subdirectory contains various function objects that are often useful, but that do not necessarily belong to a concept.</li>
<li><p class="startli"><code>boost/hana/ext/</code><br />
 This directory contains adapters for external libraries. This is the only part of the public interface which is not included by the master header, because that would make the master header dependent on those external libraries. Note that only the strict minimum required to adapt the external components is included in these headers (e.g. a forward declaration). This means that the definition of the external component should still be included when one wants to use it. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2tuple_8hpp.html">boost/hana/ext/std/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span> <span class="comment">// still required to create a tuple</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr std::tuple&lt;int, char, float&gt; xs{1, <span class="charliteral">&#39;2&#39;</span>, 3.0f};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(head(xs) == 1);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>boost/hana/sandbox/</code><br />
 This directory contains experimental code on which no guarantee whatsoever is made. It might not even compile and it will definitely not be stable.</li>
<li><code>boost/hana/detail/</code><br />
 This directory contains utilities required internally. Nothing in <code>detail/</code> is guaranteed to be stable, so you should not use it.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="tutorial-using_the_reference"></a>
Using the reference</h1>
<hr/>
<p> You now have everything you need to start using the library. From here on, mastering the library is only a matter of understanding and knowing how to use the general purpose concepts and data types provided with it, which is best done by looking at the reference documentation. At some point, you will probably also want to create your own concepts and data types that fit your needs better; go ahead, the library was intended to be used that way.</p>
<p>The structure of the reference (available in the menu to the left) goes as follow:</p><ul>
<li><a class="el" href="group__group-core.html">Core</a><br />
 Documentation for the core module, which contains everything needed to create concepts, data types and related utilities. This is relevant if you need to extend the library, but otherwise you can probably ignore this.</li>
<li><a class="el" href="group__group-functional.html">Functional</a><br />
 General purpose function objects that are generally useful in a purely functional setting. These are currently not tied to any concept or data type.</li>
<li><a class="el" href="group__group-concepts.html">Concepts</a><br />
 Documentation for all the concepts provided with the library. Each concept:<ul>
<li>Documents laws that are internal to this concept</li>
<li>Documents the concept(s) it is derived from, if any. In the documentation, we usually call those base concepts <em>superclasses</em>. Sometimes, a concept is powerful enough to provide a model of its superclass, or at least the implementation for some of its methods. When this is the case, the concept will document which superclass methods it provides, and how it does so. Also, it is sometimes possible that the model for a superclass is unique, in which case it can be provided automatically. When this happens, it will be documented but you don't have to do anything special to get that model.</li>
<li>Documents which methods must be implemented absolutely in order to model that concept.</li>
</ul>
</li>
<li><a class="el" href="group__group-datatypes.html">Data types</a><br />
 Documentation for all the data types provided with the library. Each data type documents the concept(s) it models, and how it does so. It also documents the methods tied to that data type but not to any concept, for example <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code>.</li>
<li><a class="el" href="group__group-config.html">Configuration options</a><br />
 Macros that can be used to tweak the global behavior of the library.</li>
<li><a class="el" href="group__group-assertions.html">Assertions</a><br />
 Macros to perform various types of assertions.</li>
<li><a class="el" href="group__group-details.html">Details</a><br />
 Implementation details. Don't go there.</li>
</ul>
<p>I hope you enjoy using the library, and please consider contributing since there is still a lot of work to do!</p>
<p>&ndash; Louis </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
