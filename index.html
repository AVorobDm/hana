<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Boost.Hana: Boost.Hana Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Boost.Hana Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a></li>
<li class="level1"><a href="#tutorial-introduction">Introduction</a></li>
<li class="level1"><a href="#tutorial-quick_start">Quick start</a></li>
<li class="level1"><a href="#tutorial-typeclasses">Type classes</a><ul><li class="level2"><a href="#tutorial-typeclasses-getting_concrete">Getting concrete</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-datatypes">Data types</a></li>
<li class="level1"><a href="#tutorial-header_organization">Header organization</a></li>
<li class="level1"><a href="#tutorial-mastering">Mastering the library</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> The seed that became this library was planted in late 2012, when I first started to reimplement the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> using C++11 in a project named <a href="http://github.com/ldionne/mpl11">MPL11</a>. In spring 2014, I applied to <a href="http://www.google-melange.com/gsoc/homepage/google/gsoc2014">Google Summer of Code</a> with that project for the Boost organization and got in. The goal was to polish the MPL11 and get it in Boost by the end of the summer. In May, before GSoC was started full steam, I presented the project at <a href="http://cppnow.org">C++Now</a> and had insightful conversations with several attendees. The idea that it was possible to unify the <a href="http://www.boost.org/doc/libs/release/libs/fusion/doc/html/index.html">Boost.Fusion</a> and the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> libraries made its way and I became convinced of it after writing the first prototype for what is now Boost.Hana. We are now in late July and the plan is to request an official review to get the library in Boost by the end of GSoC; we'll see how that works out.</p>
<p>Let the fun begin.</p>
<h1><a class="anchor" id="tutorial-introduction"></a>
Introduction</h1>
<hr/>
<p> Boost.Hana is a library of combinators tailored towards the manipulation of heterogeneous collections. However, the core of Hana is a powerful system for ad-hoc polymorphism inspired by Haskell type classes; this extension system is then used to provide all the functionality of the library in a modular way. Specifically, the library is built around two core concepts; <a class="el" href="index.html#tutorial-typeclasses">type classes</a> and <a class="el" href="index.html#tutorial-datatypes">data types</a>. Type classes are essentially abstract interfaces specifying functionality and data types are concrete implementations of those interfaces.</p>
<p>The library uses a purely functional style of programming, which is required to manipulate objects of heterogeneous types &ndash; it is impossible to modify the type of an object, so a new object must be introduced.</p>
<p>Contrary to previous metaprogramming libraries like Boost.MPL and Boost.Fusion, the design of the library is not based on that of the STL. Rather, it is strongly inspired by several (standard and non standard) modules written for the Haskell programming language. Through experience, I have found this to be much more expressive, flexible and easy to use while not sacrificing any performance given the purely functional setting.</p>
<h1><a class="anchor" id="tutorial-quick_start"></a>
Quick start</h1>
<hr/>
<p> This section assumes the reader is already familiar with basic metaprogramming and the C++14 standard. First, let's include the library:</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/hana.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>boost::hana;</div>
</div><!-- fragment --></p>
<blockquote class="doxtable">
<h4>Note</h4>
<p>Unless specified otherwise, the documentation assumes that the above lines are present before examples and code snippets. Use your judgment! </p>
</blockquote>
<p>Finer grained headers are provided and will be explained in the <a class="el" href="index.html#tutorial-header_organization">Header organization</a> section, but for now that'll do. Let's create an heterogeneous list, which is conceptually the same as a <code>std::tuple</code>:</p>
<p><div class="fragment"><div class="line">    <span class="keyword">auto</span> xs = <a class="code" href="structboost_1_1hana_1_1_list.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>});</div>
</div><!-- fragment --></p>
<p>Here, <code>list</code> is a generic lambda taking a variable number of arguments and returning an object which is a valid sequence for Boost.Hana. The actual type of the object returned by <code>list</code> is left unspecified, as will always be the case in this library. However, something called its "data type" is specified; <code>list</code> returns an object of data type <code>List</code>. Data types will be explained in detail in <a class="el" href="index.html#tutorial-datatypes">their own section</a>. There are several operations that can be performed on lists; here are a couple so you get the feeling:</p>
<p><div class="fragment"><div class="line">    assert(<a class="code" href="structboost_1_1hana_1_1_iterable.html#a5379264e83af65af8802eeec0d49e5f0">last</a>(xs) == <span class="stringliteral">&quot;345&quot;</span>);</div>
<div class="line">    assert(<a class="code" href="structboost_1_1hana_1_1_iterable.html#ab15783aae10d4373e2399abe728f3f96">tail</a>(xs) == <a class="code" href="structboost_1_1hana_1_1_list.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>}));</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_iterable.html#a4193ecf811f29479c60022564afa512a">is_empty</a>(xs));</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_iterable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(xs, [](<span class="keyword">auto</span> x) { std::cout &lt;&lt; x; });</div>
</div><!-- fragment --></p>
<p>An interesting observation is that <code>is_empty</code> returns a value that can be constexpr-converted to <code>bool</code> even though the list contains non-constexpr objects (a <code>std::string</code>). Indeed, the size of the sequence is known at compile-time regardless of its content, so it only makes sense that the library does not throw away this information. Let's take that <code>for_each</code> for a tour and write a function that prints a list as XML:</p>
<p><div class="fragment"><div class="line">    <span class="keyword">auto</span> to_xml = [](<span class="keyword">auto</span>&amp; ostream, <span class="keyword">auto</span> xs) {</div>
<div class="line">        <a class="code" href="structboost_1_1hana_1_1_iterable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(xs, [&amp;](<span class="keyword">auto</span> x) {</div>
<div class="line">            ostream &lt;&lt; <span class="charliteral">&#39;&lt;&#39;</span>  &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; <span class="charliteral">&#39;&gt;&#39;</span></div>
<div class="line">                    &lt;&lt;                x</div>
<div class="line">                    &lt;&lt; <span class="stringliteral">&quot;&lt;/&quot;</span> &lt;&lt; <span class="keyword">typeid</span>(x).name() &lt;&lt; <span class="charliteral">&#39;&gt;&#39;</span>;</div>
<div class="line">        });</div>
<div class="line">    };</div>
<div class="line">    to_xml(std::cout, xs);</div>
</div><!-- fragment --></p>
<p>One of the initial goals of the library was to unify type level programming with value level programming. So in principle, it should be possible to manipulate types and sequences of types just as one would do with the Boost.MPL. Here is how Hana does it:</p>
<p><div class="fragment"><div class="line">    <span class="keyword">auto</span> ts = <a class="code" href="structboost_1_1hana_1_1_list.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(type&lt;int*&gt;, type&lt;void&gt;, type&lt;char const&gt;);</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_iterable.html#a5379264e83af65af8802eeec0d49e5f0">last</a>(ts) == type&lt;char const&gt;);</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_functor.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a>(metafunction&lt;std::add_pointer&gt;, ts) == <a class="code" href="structboost_1_1hana_1_1_list.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(type&lt;int**&gt;, type&lt;void*&gt;, type&lt;char const*&gt;));</div>
</div><!-- fragment --></p>
<p>There is a lot going on here. First, <code>type</code> is a variable template, and <code>type&lt;T&gt;</code> is an object representing the C++ type <code>T</code>. Since it's an object, it makes perfect sense to create a list out of these guys. Second, <code>fmap</code> is a function similar to <code>std::transform</code>: it takes a function object and a list (actually any <code>Functor</code> &ndash; more on this later), applies the function to every element in the list and returns the resulting list. Now, this means that somehow <code>metafunction&lt;std::add_pointer&gt;</code> is in fact a function object. Specifically, <code>metafunction</code> is a variable template taking a template template parameter, and <code>metafunction&lt;std::add_pointer&gt;</code> is a function object which accepts a <code>type&lt;T&gt;</code> and returns <code>type&lt;std::add_pointer&lt;T&gt;::type&gt;</code>. Still with me?</p>
<p>So far, we can perform computations on C++ types but we can't really do anything useful with the result if we can't get the type out, i.e. get the <code>T</code> out of <code>type&lt;T&gt;</code>. This is easily done:</p>
<p><div class="fragment"><div class="line">    static_assert(std::is_same&lt;</div>
<div class="line">        decltype(<a class="code" href="structboost_1_1hana_1_1_iterable.html#a5379264e83af65af8802eeec0d49e5f0">last</a>(ts))::<a class="code" href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">type</a>,</div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span></div>
<div class="line">    &gt;::<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --></p>
<p>It turns out that while <code>type&lt;T&gt;</code> has an unspecified C++ type, that C++ type is still guaranteed to have a nested type named <code>type</code> which is an alias to <code>T</code>. In Boost.MPL parlance, <code>decltype(type&lt;T&gt;)</code> is a nullary metafunction returning <code>T</code>.</p>
<p>This is it for the quick start. Of course, there is much more available like associative sequences, sets, ranges and even an heterogeneous <code>std::optional</code> called <code>Maybe</code>, but you can read on if you want to know more.</p>
<h1><a class="anchor" id="tutorial-typeclasses"></a>
Type classes</h1>
<hr/>
<p> Conceptually, type classes are an artifice allowing humans to manipulate objects of heterogeneous types with well-defined semantics. They serve a purpose very similar to C++ concepts (which are not in yet) and to Haskell type classes, except they do not have language support.</p>
<p>For the sake of the explanation, let me make the following claim: a function template that compiles with an argument of every possible type must have a trivial implementation, in the sense that it must do nothing with its argument except perhaps return it. Hence, for a function template to do something interesting, it must fail to compile for some set of arguments. While I won't try to prove that claim formally &ndash; it might be false in some corner cases &ndash;, think about it for a moment. Let's say I want to apply a function to each element of an heterogeneous sequence:</p>
<div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_iterable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(<a class="code" href="structboost_1_1hana_1_1_list.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(x, y, z), f)</div>
</div><!-- fragment --><p>The first observation is that <code>f</code> must have a templated call operator because <code>x</code>, <code>y</code> and <code>z</code> have different types. The second observation is that without knowing anything specific about the types of <code>x</code>, <code>y</code> and <code>z</code>, it is impossible for <code>f</code> to do anything meaningful. For example, could it print its argument? Of course not, since it does not know whether <code>std::cout &lt;&lt; x</code> is well-formed! In order to do something meaningful, the function has to put constraints on its arguments, it has to define a domain. In other words, it can't be <em>fully</em> polymorphic, at least not conceptually. The current language does not provide a way to express this (concepts are not there yet), so we would write something like this instead:</p>
<div class="fragment"><div class="line"><span class="comment">// compile-time precondition for `f(x)` to be well-formed:</span></div>
<div class="line"><span class="comment">// `std::cout &lt;&lt; x` must be a valid expression, i.e. `x` must be `Printable`</span></div>
<div class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">  std::cout &lt;&lt; x;</div>
<div class="line">};</div>
</div><!-- fragment --><p>While the compile-time precondition is only a comment which the compiler is not aware of, there is nonetheless a conceptual constraint on the argument of <code>f</code>. This allows us to define the domain of <code>f</code>, which is any <code>Printable</code> object. In straight C++, the domain of a function is a C++ type. However, it should now be clear from the example that more flexibility could be achieved by allowing domains to be arbitrary sets (e.g. the set of all types that can be <code>std::cout</code>ed), which is roughly what C++ concepts will bring to the table.</p>
<blockquote class="doxtable">
<p>Some libraries like <a href="http://www.boost.org/doc/libs/release/libs/concept_check/index.html">Boost.ConceptCheck</a> aim to make these type constraints more explicit and checkable until there is language support. </p>
</blockquote>
<p>Type classes in Boost.Hana are a library-level implementation of such type constraints allowing us to organize our generic programming. They allow us to bundle together related operations (called methods), to explicitly state that a type satisfies some constraints and how, and to do all sorts of tricks to reduce the amount of code we have to write. However, they are in no way a replacement for concepts; because they do not have language-level support, the type constraints are not checked explicitly by the compiler and failure to satisfy constraints will result in the usual compiler errors we all know and love.</p>
<h2><a class="anchor" id="tutorial-typeclasses-getting_concrete"></a>
Getting concrete</h2>
<p>We're now ready to take a look at these little beasts. Concretely, a type class is just a C++ structure or class calling the <code>BOOST_HANA_TYPECLASS</code> macro in its definition at public scope:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">  <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>BOOST_HANA_TYPECLASS</code> macro creates a nested template named <code>instance</code> &ndash; which will be explained later &ndash;, so that name is reserved inside a type class to avoid clashes. Other arbitrary members can be put in the type class, but it is probably a good idea to keep anything unrelated out for the sake of separating concerns:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">  <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// This is valid, but it&#39;s probably not a good idea unless those are</span></div>
<div class="line">  <span class="comment">// strongly related to the type class.</span></div>
<div class="line">  <span class="keywordtype">int</span> foo;</div>
<div class="line">  <span class="keywordtype">void</span> bar()<span class="keyword"> const </span>{ };</div>
<div class="line">  <span class="keyword">struct </span>baz { };</div>
<div class="line">};</div>
</div><!-- fragment --><p>As you will see later with minimal complete definitions, it is often useful to put other <em>related</em> members in a type class; don't hesitate to do it when it makes sense.</p>
<p>When I introduced type classes, I said they allowed us to bundle together related operations called methods. This is because type classes can be seen as defining some kind of public interface consisting of the operations that are valid with any object satisfying some constraints. I also said that they made it possible to explicitly state that a type satisfies those constraints, and how it does so. From now on, I will refer to the set of all types satisfying the constraints of a type class <code>T</code> as the <em>instances</em> of <code>T</code>, and I will refer to the act of specifying how a type <code>t</code> is an <em>instance</em> of <code>T</code> as the act of <em>instantiating</em> <code>T</code> with <code>t</code>. Note that this has nothing to do with C++ template instantiation; it is just the standard Haskell terminology.</p>
<p>To associate methods to a type class, we create a layer of indirection through the <code>instance</code> member of the type class. For example, let's say we want to have a method named <code>print</code> in the <code>Printable</code> type class:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> print = [](std::ostream&amp; os, <span class="keyword">auto</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> Printable::instance&lt;decltype(x)&gt;::print_impl(os, x);</div>
<div class="line">};</div>
</div><!-- fragment --><blockquote class="doxtable">
<h4>Note</h4>
<p>This is actually <em>slightly</em> different from what is really done in the library; this will be clarified in the section on data types. </p>
</blockquote>
<p>To make a type an instance of <code>Printable</code>, we must implement the <code>print</code> method, which is done by specializing the <code>Printable::instance</code> template as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;int&gt; {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, <span class="keywordtype">int</span> i) {</div>
<div class="line">    os &lt;&lt; i;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that we could have chosen a name different from <code>print_impl</code>, but this naming convention has the advantage of being clear and avoiding name clashes inside the instance. In particular, we would not want to use <code>Printable::instance&lt;int&gt;::print</code>, because using <code>print</code> inside the instance would then refer to the implementation instead of <code>::print</code>, which is unexpected. This naming convention is used for all the type classes in Boost.Hana. Now that we have made <code>int</code> an instance of <code>Printable</code>, we can write:</p>
<div class="fragment"><div class="line">print(std::cout, 2);</div>
</div><!-- fragment --><p>So far so good, but you probably don't want to write an instance for each arithmetic type, right?. Fortunately, I didn't want to either so it is possible to instantiate a type class for all types satisfying a predicate:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, when&lt;std::is_arithmetic&lt;T&gt;<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">::value</a>&gt;&gt; {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T x) {</div>
<div class="line">    os &lt;&lt; x;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>when</code> accepts a single compile-time boolean and enables the instance if and only if that boolean is <code>true</code>. This is similar to the well known C++ idiom of using a dummy template parameter with <code>std::enable_if</code> and relying on SFINAE. As expected, we can now write</p>
<div class="fragment"><div class="line">print(std::cout, 2.2);</div>
</div><!-- fragment --><p>Ok, we managed to cut down the number of instances quite a bit, but we still can't write</p>
<div class="fragment"><div class="line">print(std::cout, std::string{<span class="stringliteral">&quot;foo&quot;</span>});</div>
</div><!-- fragment --><p>without writing an explicit instance for <code>std::string</code>. Again, laziness won me over and so it is possible to instantiate a type class for all types making some expression well-formed (think SFINAE):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, <a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;</div>
<div class="line">  decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt; {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T x) {</div>
<div class="line">    os &lt;&lt; x;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>when_valid</code> is actually an alias to <code>when&lt;true&gt;</code>, but it takes an arbitrary number of types and relies on the fact that SFINAE will kick in and remove the specialization if any of the types is not well-formed. As expected, we can now write</p>
<div class="fragment"><div class="line">print(std::cout, std::string{<span class="stringliteral">&quot;foo&quot;</span>});</div>
</div><!-- fragment --><p>Note that instances provided without <code>when</code>/<code>when_valid</code> (i.e. an explicit or partial specialization in the case of a parametric type) have the priority over instances provided with it. This is to allow types to instantiate a type class even if an instance for the same type class is provided through a predicate. This design choice was made assuming that a specialization (even partial) is usually meant to be more specific than a catch-all instance enabled by a predicate.</p>
<p>All is good so far, but what if we just wanted a string representation of our object instead of printing it to a stream? Sure, we could write</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">  std::ostringstream os;</div>
<div class="line">  print(os, x);</div>
<div class="line">  <span class="keywordflow">return</span> os.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">to_string(1);</div>
</div><!-- fragment --><p>but then <code>to_string(std::string{"foobar"})</code> would be far from optimal. The solution is to make <code>to_string</code> a method too, and then specialize the instance for <code>std::string</code> to make it more efficient:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> Printable::instance&lt;decltype(x)&gt;::to_string_impl(x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, <a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;</div>
<div class="line">  decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt; {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T x) {</div>
<div class="line">    os &lt;&lt; x;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> std::string to_string_impl(T x) {</div>
<div class="line">    std::ostringstream os;</div>
<div class="line">    print(os, x);</div>
<div class="line">    <span class="keywordflow">return</span> os.str();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;std::string&gt; {</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, std::string x) {</div>
<div class="line">    os &lt;&lt; x;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> std::string to_string_impl(std::string x)</div>
<div class="line">  { <span class="keywordflow">return</span> x; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>While this is pretty satisfying, notice how the general definition of <code>to_string_impl</code> is tied to the instance it is defined in, even though it would work for any <code>Printable</code> implementing <code>print</code>. For example, let's say we want to instantiate <code>Printable</code> for <code>std::vector&lt;T&gt;</code> for any <code>T</code> which can be put to a stream:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;std::vector&lt;T&gt;, <a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;</div>
<div class="line">  decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt; {</div>
<div class="line">  static void print_impl(std::ostream&amp; os, std::vector&lt;T&gt; v) {</div>
<div class="line">    os &lt;&lt; &#39;[&#39;;</div>
<div class="line">    for (auto it = begin(v); it != end(v); ) {</div>
<div class="line">      os &lt;&lt; *it;</div>
<div class="line">      if (++it != end(v))</div>
<div class="line">        os &lt;&lt; &quot;, &quot;;</div>
<div class="line">    }</div>
<div class="line">    os &lt;&lt; &#39;]&#39;;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  static std::string to_string_impl(std::vector&lt;T&gt; v) {</div>
<div class="line">    std::ostringstream os;</div>
<div class="line">    print(os, v);</div>
<div class="line">    return os.str();</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>It is annoying to have to redefine <code>to_string_impl</code> even if <code>print_impl</code> alone would be enough because <code>to_string_impl</code> is completely determined by it. From now on, I will refer to the minimal set of methods that are required to instantiate a type class as the minimal complete definition, abbreviated <code>mcd</code>. In the present case, the minimal complete definition for the <code>Printable</code> type class is <code>print</code>. To avoid code duplication, a default implementation for methods that are not part of the mcd should be provided by the type class. By convention, we provide these in a nested type of the type class:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">  <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">struct </span>mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(X x) {</div>
<div class="line">      std::ostringstream os;</div>
<div class="line">      print(os, x);</div>
<div class="line">      <span class="keywordflow">return</span> os.str();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p>It then suffices to inherit from that structure when instantiating <code>Printable</code> to get the default implementation for <code>to_string_impl</code>, which can now be shared by several instances:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, <a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;</div>
<div class="line">  decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt; : Printable::mcd {</div>
<div class="line">  <span class="comment">// print_impl omitted</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;std::vector&lt;T&gt;, <a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;</div>
<div class="line">  decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt; : Printable::mcd {</div>
<div class="line">  <span class="comment">// print_impl omitted</span></div>
<div class="line">};</div>
</div><!-- fragment --><blockquote class="doxtable">
<h4>Note</h4>
<p>For simplicity, the term minimal complete definition can refer either to a minimal set of required methods or to the member of the type class providing the corresponding default implementations. </p>
</blockquote>
<p>It is possible for a type class to have several minimal complete definitions. For example, one could observe that <code>print</code> can also be implemented in terms of <code>to_string</code>. If we wanted to do so, we could provide both minimal complete definitions by putting them into suitably named members of the <code>Printable</code> type class:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">  <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// requires to_string only</span></div>
<div class="line">  <span class="keyword">struct </span>to_string_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, X x) {</div>
<div class="line">      os &lt;&lt; to_string(x);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  <span class="comment">// requires print only</span></div>
<div class="line">  <span class="keyword">struct </span>print_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(X x) {</div>
<div class="line">      std::ostringstream os;</div>
<div class="line">      print(os, x);</div>
<div class="line">      <span class="keywordflow">return</span> os.str();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p>Either minimal complete definitions could now be used to instantiate <code>Printable</code>. By convention, in Boost.Hana, the minimal complete definition is always named <code>mcd</code> when there is a single one. A nested type named <code>mcd</code> is also provided when there are no default implementations to provide for consistency and for extensibility, as will be explained next. If there is more than one possible mcd, each mcd is in a different nested type with a descriptive name. In all cases, the minimal complete definition(s) are documented.</p>
<p>It is recommended to always inherit from a minimal complete definition, even when the default implementations are not actually used:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;std::string&gt;</div>
<div class="line">  : Printable::print_mcd <span class="comment">// could also be to_string_mcd, it doesn&#39;t matter</span></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, std::string x)</div>
<div class="line">  { os &lt;&lt; x; }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> std::string to_string_impl(std::string x)</div>
<div class="line">  { <span class="keywordflow">return</span> x; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This allows methods to be added to the type class without breaking the instance, provided the type class does not change its minimal complete definition(s). This is the reason why a minimal complete definition is always provided, even when it is empty.</p>
<p>To show the full power of type classes and introduce the <code>instantiates</code> utility, let's define a <code>Printable</code> instance for <code>std::vector</code>s containing any <code>Printable</code> type. This is a generalization of our previous <code>Printable</code> instance for <code>std::vector</code>s, which supported only streamable types.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;std::vector&lt;T&gt;, when&lt;instantiates&lt;Printable, T&gt;()&gt;&gt;</div>
<div class="line">  : Printable::print_mcd</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, std::vector&lt;T&gt; v) {</div>
<div class="line">    os &lt;&lt; <span class="charliteral">&#39;[&#39;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = begin(v); it != end(v); ) {</div>
<div class="line">      print(os, *it); <span class="comment">// recursively print the contents</span></div>
<div class="line">      <span class="keywordflow">if</span> (++it != end(v))</div>
<div class="line">        os &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    os &lt;&lt; <span class="charliteral">&#39;]&#39;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>instantiates</code> is a variable template taking a type class and a type and returning whether the type is an instance of the given type class. The result is returned as a boolean <code>Integral</code>, which is basically equivalent to a boolean <code>std::integral_constant</code>, hence the trailing <code>()</code> to convert the result to a <code>bool</code> at compile-time. We can now print nested containers:</p>
<div class="fragment"><div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; v{{1, 2, 3}, {3, 4, 5}};</div>
<div class="line">print(std::cout, v); <span class="comment">// prints &quot;[[1, 2, 3], [3, 4, 5]]&quot;</span></div>
</div><!-- fragment --><p>One last thing which can be done with type classes is to provide a default instance for all data types. To do so, a nested <code>default_instance</code> template must be defined in the type class:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">  <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// definitions omitted</span></div>
<div class="line">  <span class="keyword">struct </span>to_string_mcd { };</div>
<div class="line">  <span class="keyword">struct </span>print_mcd { };</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">struct </span>default_instance : to_string_mcd {</div>
<div class="line">    <span class="keyword">static</span> std::string to_string_impl(T) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;not-printable&gt;&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>default_instance</code> should be just like a normal instance. Note that this feature should seldom be used because methods with a meaningful behavior for all data types are rare. This feature is provided for flexibility, but it should be a hint to reconsider your type class design if you are about to use it.</p>
<h3>Example of a type class definition</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/core/typeclass.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/detail/constexpr.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/detail/static_assert.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Incrementable);</div>
<div class="line">    <span class="keyword">struct </span>next_mcd;</div>
<div class="line">    <span class="keyword">struct </span>next_n_mcd;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::next_impl(x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next_n = [](<span class="keyword">auto</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::next_n_impl(x, n);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(X x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">        <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> x;</div>
<div class="line">        <span class="keywordflow">else</span>        <span class="keywordflow">return</span> next_n_impl(next(x), n - 1);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> next_n(x, 1); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;int&gt; : Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(<span class="keywordtype">int</span> x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;long&gt; : Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(<span class="keywordtype">long</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)</div>
<div class="line">    { <span class="keywordflow">return</span> x + n; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;T, hana::when&lt;std::is_floating_point&lt;T&gt;{}&gt;&gt;</div>
<div class="line">    : Incrementable::next_mcd</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1) == 2);</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1, 3) == 4);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1l) == 2l);</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1l, 3) == 4l);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1.0) == 2.0);</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1.0, 3) == 4.0);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Example of a type class with a default instance</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/core/typeclass.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/detail/constexpr.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Showable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Showable);</div>
<div class="line">    <span class="keyword">struct </span>mcd { };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>default_instance : mcd {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">        <span class="keyword">static</span> std::string show_impl(X)</div>
<div class="line">        { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>; }</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> show = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> Showable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::show_impl(x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Showable::instance&lt;int&gt; : Showable::mcd {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> show_impl(<span class="keywordtype">int</span> i)</div>
<div class="line">    { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; i).str(); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>unshowable { };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    assert(show(1) == <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line">    assert(show(unshowable{}) == <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>Document type classes with operators. Document <code>disable</code>.</dd></dl>
<h1><a class="anchor" id="tutorial-datatypes"></a>
Data types</h1>
<hr/>
<p> Data types are a generalization of usual C++ types making it easier to instantiate type classes for heterogeneous containers. They are very similar to Boost.Fusion and Boost.MPL tags. So far, we have only instantiated type classes with types that "contained" homogeneous objects (<code>std::vector&lt;T&gt;</code>, <code>int</code>, etc..). What if we wanted to make <code>boost::fusion::vector</code> an instance of <code>Printable</code>?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;boost::fusion::vector&lt;T...&gt;&gt;</div>
<div class="line">  : Printable::print_mcd</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// print_impl omitted</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>If you know Boost.Fusion, then you probably know that it won't work. When we instantiate <code>Printable</code> for <code>boost::fusion::vector&lt;T...&gt;</code>, we're only instantiating it for that particular representation of a Boost.Fusion vector. This is because Boost.Fusion vectors exist in numbered forms, which are of different types:</p>
<div class="fragment"><div class="line">boost::fusion::vector1&lt;T&gt;</div>
<div class="line">boost::fusion::vector2&lt;T, U&gt;</div>
<div class="line">boost::fusion::vector3&lt;T, U, V&gt;</div>
<div class="line">...</div>
</div><!-- fragment --><p>This is an implementation detail required by the lack of variadic templates in C++03 that leaks into the interface. This is unfortunate, but we need a way to work around it. And it gets worse; I said earlier that <code>list</code>, <code>type</code> and other Boost.Hana components did not specify their type at all &ndash; specifying those types would be too restrictive for the implementation &ndash;, so it would be straight impossible to instantiate type classes with those. The solution is to bundle all the types representing the "same thing" under a single tag, and then to use that tag to perform the method dispatching. For this, we introduce the <code>datatype</code> metafunction, which associates a "tag" to a group of types. The <code>Printable</code> methods now become:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> print = [](std::ostream&amp; os, <span class="keyword">auto</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> Printable::instance&lt;</div>
<div class="line">    <span class="keyword">typename</span> datatype&lt;decltype(x)&gt;::type</div>
<div class="line">  &gt;::print_impl(os, x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> Printable::instance&lt;</div>
<div class="line">    <span class="keyword">typename</span> datatype&lt;decltype(x)&gt;::type</div>
<div class="line">  &gt;::to_string_impl(x);</div>
<div class="line">};</div>
</div><!-- fragment --><blockquote class="doxtable">
<h4>Note</h4>
<p>Actually, it would be possible to work around the issue regarding Fusion vectors by using <code>boost::fusion::sequence_tag</code> with <code>when</code> to instantiate <code>Printable</code> only when it is a Fusion vector, but it still does not resolve the issue for Hana components that do not specify anything about their type. </p>
</blockquote>
<p>By default, <code>datatype&lt;T&gt;::type</code> is <code>T::hana_datatype</code> if that expression is well-formed, and <code>T</code> otherwise. It can also be specialized to allow customizing the data type of <code>T</code> in a ad-hoc manner. Finally, like for type class instances, it can be specialized for all types satisfying some boolean condition using <code>when</code>, or for all types making some expression well-formed with <code>when_valid</code>. For <code>boost::fusion::vector</code>, we would then do:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>BoostFusionVector;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>datatype&lt;T, when&lt;is_a_boost_fusion_vector&lt;T&gt;::<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>&gt;&gt; {</div>
<div class="line">  <span class="keyword">using</span> type = BoostFusionVector;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Where <code>is_a_boost_fusion_vector</code> is some metafunction returning whether a type is a Fusion vector. Hana components either provide a similar specialization or use the nested <code>hana_datatype</code> alias to provide a data type, which is specified. To make <code>boost::fusion::vector</code> <code>Printable</code>, we would now write:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;BoostFusionVector&gt; : Printable::print_mcd {</div>
<div class="line">  <span class="comment">// print_impl omitted</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The fact that <code>datatype&lt;T&gt;::type</code> defaults to <code>T</code> is <em>very</em> useful, because it means that you can ignore it completely if the component you're building has a well-defined type, and everything will "just work".</p>
<h1><a class="anchor" id="tutorial-header_organization"></a>
Header organization</h1>
<hr/>
<p> The library is designed to be very modular while keeping the number of headers that must be included to get basic functionality reasonably low. The structure of the library is influenced by the structure of type classes and data types. Once you are familiar with the type classes and data types provided with the library, the header structure should feel intuitive.</p>
<ul>
<li><code>boost/hana.hpp</code><br />
 This is the master header of the library. It includes the whole public interface of the library except adapters for external libraries, which must be included separately.</li>
<li><code>boost/hana/</code><ul>
<li><code>boost/hana/core/</code><ul>
<li><code>boost/hana/core/datatype.hpp</code><br />
 This file defines everything required to define a new data type. This includes the <code>datatype</code> metafunction, <code>when</code>, <code>when_valid</code> and <code>operators::enable</code>. By contract, all the other files in <code>boost/hana/core/</code> include this one, so there is no need to include it when something else in <code>boost/hana/core/</code> is already included.</li>
<li><code>boost/hana/core/typeclass.hpp</code><br />
 This file defines everything required to define a new type class. This includes the <code>BOOST_HANA_{UNARY,BINARY}_TYPECLASS</code> macros and <code>disable</code>.</li>
<li><code>boost/hana/core/instantiates.hpp</code><br />
 This file defines the <code>instantiates</code> utility and related goodies like <code>is_a</code> and <code>is_an</code>.</li>
<li><code>boost/hana/core/convert.hpp</code><br />
 This file defines the conversion utilities <code>to</code> and <code>convert</code>.</li>
</ul>
</li>
<li><code>boost/hana/core.hpp</code> This file includes everything in <code>boost/hana/core/</code>.</li>
<li><code>boost/hana/[typeclass].hpp</code><br />
 A file of this type includes the whole definition of a type class <code>[typeclass]</code>. This includes all the type class methods, minimal complete definitions and laws related to the type class.</li>
<li><code>boost/hana/[typeclass]/[typeclass].hpp</code><br />
 A file of this type includes the definition of the type class structure (but not its members like <code>mcd</code>, <code>laws</code>, etc..) and the associated type class methods. It also defines the operators associated to its methods and the default-provided instances for builtin types, if there are any. Note that default-provided instances for non-builtin types are not defined in this header. This header is included by all other headers inside its directory.</li>
<li><code>boost/hana/[typeclass]/[mcd].hpp</code><br />
 A file of this type defines a minimal complete definition named <code>[mcd]</code> along with default-provided instances for non-builtin types, if any. It is possible for a type class to have several minimal complete definitions, in which case there are several such headers with a proper name.</li>
<li><code>boost/hana/[typeclass]/laws.hpp</code><br />
 This file defines the laws associated to a type class. Not all type classes have laws associated to them and some type classes have laws which are too hard to check automatically, in which case this header is not provided.</li>
<li><code>boost/hana/[typeclass]/instance.hpp</code><br />
 Some type classes are such that all instances are forced to be isomorphic. In that case, it sometimes makes sense to provide an implementation of the unique instance. When such an instance is provided, it is defined in this header.</li>
<li><code>boost/hana/[datatype].hpp</code><br />
 A file of this type defines a data type named <code>[datatype]</code>. It defines all the type class instances associated to that data type, so that one only has to include the data type's header to get the full functionality it supports.</li>
<li><p class="startli"><code>boost/hana/ext/</code><br />
 This directory contains adapters for external libraries. This is the only part of the public interface which is not included by the master header, because that would make the master header dependent on those external libraries. Note that only the strict minimum required to adapt the external component is included in these headers (e.g. a forward declaration). This means that the definition of the external component should still be included when one wants to use it. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/hana/ext/std/tuple.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span> <span class="comment">// still required to create a tuple</span></div>
<div class="line"><span class="keyword">using namespace </span>boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr std::tuple&lt;int, char, float&gt; xs{1, <span class="charliteral">&#39;2&#39;</span>, 3.0f};</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(head(xs) == 1);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>boost/hana/sandbox/</code><br />
 This directory contains experimental code on which no guarantee whatsoever is made. It might not even compile and it will definitely not be stable.</li>
<li><code>boost/hana/detail/</code><br />
 This directory contains utilities required internally. Nothing in <code>detail/</code> is guaranteed to be stable, so you should not use it.</li>
</ul>
</li>
</ul>
<h3>Example</h3>
<p>Let's say I want to include <code>set</code>. I only have to include its header and I can use all the methods it supports right away:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/hana/set.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> xs = set(1, 2.2, <span class="charliteral">&#39;x&#39;</span>);</div>
<div class="line">    <a class="code" href="group__group-details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(elem(<span class="charliteral">&#39;x&#39;</span>, xs));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="tutorial-mastering"></a>
Mastering the library</h1>
<hr/>
<p> You now have everything you need to start using the library. From here on, mastering the library is only a matter of understanding and knowing how to use the general purpose type classes and data types provided with it, which is best done by looking at the reference documentation. At some point, you will probably also want to create your own type classes and data types that fit your needs better; go ahead, the library was intended to be used that way.</p>
<p>The structure of the reference (available in the menu to the left) goes as follow:</p><ul>
<li><a class="el" href="group__group-core.html">Core</a><br />
 Documentation for the core module, which contains everything needed to implement type classes, data types and related utilities. This is relevant if you need to extend the library, but otherwise the tutorial pretty much covered it all.</li>
<li><a class="el" href="group__group-functional.html">Functional</a><br />
 General purpose function objects that are generally useful in a purely functional setting. These are not tied to any type class or data type (currently).</li>
<li><a class="el" href="group__group-typeclasses.html">Type classes</a><br />
 Documentation for all the type classes provided with the library. Each type class is documented as follows:<ul>
<li>The methods it provides</li>
<li>The minimal complete definition(s) required to instantiate it</li>
<li>The laws that must be respected by its instances</li>
<li>Any additional type class specific information</li>
</ul>
</li>
<li><a class="el" href="group__group-datatypes.html">Data types</a><br />
 Documentation for all the data types provided with the library. Each data type is documented as follows:<ul>
<li>The type classes it instantiates, and how it does so</li>
<li>Methods tied to the data type but not to any type class</li>
<li>Any data type specific information</li>
</ul>
</li>
</ul>
<p>If you are not too familiar with Haskell, I suggest you start with a fairly concrete type class and then work your way down to more abstract and powerful type classes. A good place to start would be the <code>List</code> type class, which is useful and very concrete.</p>
<p>I hope you enjoy using the library as much as I enjoyed writing it!</p>
<p>&ndash; Louis </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
