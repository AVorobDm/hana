<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Boost.Hana: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous core utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1convert.html">boost::hana::convert&lt; To, From, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements conversions between data types.  <a href="structboost_1_1hana_1_1convert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1when.html">boost::hana::when&lt; condition &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to instantiate a type class based on the value of a predicate.  <a href="structboost_1_1hana_1_1when.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1disable.html">boost::hana::disable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly disable a type class instance.  <a href="structboost_1_1hana_1_1disable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning the data type associated to <code>T</code>.  <a href="structboost_1_1hana_1_1datatype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1operators_1_1enable.html">boost::hana::operators::enable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows operators in the <code>boost::hana::operators</code> namespace to be found by ADL.  <a href="structboost_1_1hana_1_1operators_1_1enable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac072d4434777cd5ee841a7766d41f1d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(NAME)</td></tr>
<tr class="memdesc:gac072d4434777cd5ee841a7766d41f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machinery for creating a unary type class.  <a href="#gac072d4434777cd5ee841a7766d41f1d8">More...</a><br /></td></tr>
<tr class="separator:gac072d4434777cd5ee841a7766d41f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gabc68f88756ee6bb3b727d8f0abea8ee5">BOOST_HANA_BINARY_TYPECLASS</a>(NAME)</td></tr>
<tr class="memdesc:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machinery for creating a binary type class.  <a href="#gabc68f88756ee6bb3b727d8f0abea8ee5">More...</a><br /></td></tr>
<tr class="separator:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = when&lt; true &gt;</td></tr>
<tr class="memdesc:ga0f5d717bbf6646619bb6219b104384dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to instantiate a type class based on the validity of an expression.  <a href="#ga0f5d717bbf6646619bb6219b104384dc">More...</a><br /></td></tr>
<tr class="separator:ga0f5d717bbf6646619bb6219b104384dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typename datatype&lt; T &gt;::<a class="el" href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">type</a></td></tr>
<tr class="memdesc:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>datatype&lt;T&gt;::type</code>.  <a href="#gae3cedd3772d00ac7c4de9dc3d719f321">More...</a><br /></td></tr>
<tr class="separator:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1505b4c072265b1461478be8e424e356"><td class="memTemplParams" colspan="2">template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga1505b4c072265b1461478be8e424e356"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga1505b4c072265b1461478be8e424e356">boost::hana::instantiates</a></td></tr>
<tr class="memdesc:ga1505b4c072265b1461478be8e424e356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the type class is instantiated with the given arguments.  <a href="#ga1505b4c072265b1461478be8e424e356">More...</a><br /></td></tr>
<tr class="separator:ga1505b4c072265b1461478be8e424e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f50738684d619fea95be73a38fd7f47"><td class="memTemplParams" colspan="2">template&lt;typename Typeclass &gt; </td></tr>
<tr class="memitem:ga4f50738684d619fea95be73a38fd7f47"><td class="memTemplItemLeft" align="right" valign="top">constexpr core_detail::is_a<br class="typebreak" />
&lt; Typeclass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga4f50738684d619fea95be73a38fd7f47">boost::hana::is_a</a> {}</td></tr>
<tr class="memdesc:ga4f50738684d619fea95be73a38fd7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether an object is an instance of the given type class.  <a href="#ga4f50738684d619fea95be73a38fd7f47">More...</a><br /></td></tr>
<tr class="separator:ga4f50738684d619fea95be73a38fd7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffd5adfee9463f878117bdb8a37955a"><td class="memTemplParams" colspan="2">template&lt;typename Typeclass &gt; </td></tr>
<tr class="memitem:ga4ffd5adfee9463f878117bdb8a37955a"><td class="memTemplItemLeft" align="right" valign="top">constexpr core_detail::is_a<br class="typebreak" />
&lt; Typeclass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga4ffd5adfee9463f878117bdb8a37955a">boost::hana::is_an</a> {}</td></tr>
<tr class="memdesc:ga4ffd5adfee9463f878117bdb8a37955a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language.  <a href="#ga4ffd5adfee9463f878117bdb8a37955a">More...</a><br /></td></tr>
<tr class="separator:ga4ffd5adfee9463f878117bdb8a37955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7d85fcbf846d9b63a8270f547309be"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:ga2a7d85fcbf846d9b63a8270f547309be"><td class="memTemplItemLeft" align="right" valign="top">constexpr core_detail::to&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga2a7d85fcbf846d9b63a8270f547309be">boost::hana::to</a> {}</td></tr>
<tr class="memdesc:ga2a7d85fcbf846d9b63a8270f547309be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of a data type from an object of another data type.  <a href="#ga2a7d85fcbf846d9b63a8270f547309be">More...</a><br /></td></tr>
<tr class="separator:ga2a7d85fcbf846d9b63a8270f547309be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Miscellaneous core utilities. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gabc68f88756ee6bb3b727d8f0abea8ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_BINARY_TYPECLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                        \</div>
<div class="line">        template &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> ...&gt;                     \</div>
<div class="line">        struct instance                                                     \</div>
<div class="line">            : instance&lt;T, U, ::boost::hana::when&lt;true&gt;&gt;                     \</div>
<div class="line">        { };                                                                \</div>
<div class="line">                                                                            \</div>
<div class="line">        template &lt;typename T, typename U, bool condition&gt;                   \</div>
<div class="line">        struct instance&lt;T, U, ::boost::hana::when&lt;condition&gt;&gt;               \</div>
<div class="line">            : ::boost::hana::core_detail::default_instance&lt;                 \</div>
<div class="line">                void, NAME, T, U                                            \</div>
<div class="line">            &gt;<a class="code" href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">::type</a>                                                         \</div>
<div class="line">        { }                                                                 \                                                     \</div>
<div class="ttc" id="structboost_1_1hana_1_1_type_html_ab66de88586706cb474453dd937d13f8c"><div class="ttname"><a href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">boost::hana::Type::type</a></div><div class="ttdeci">constexpr type_detail::make_type&lt; T &gt;::type type</div><div class="ttdoc">Creates an object representing the C++ type T. </div><div class="ttdef"><b>Definition:</b> type.hpp:82</div></div>
</div><!-- fragment -->
<p>Machinery for creating a binary type class. </p>
<p>This is equivalent to <code>BOOST_HANA_TYPECLASS</code>, except it creates a type class with two arguments. </p>

</div>
</div>
<a class="anchor" id="gac072d4434777cd5ee841a7766d41f1d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_TYPECLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                                                        \</div>
<div class="line">        template &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...&gt;                                 \</div>
<div class="line">        struct instance                                                     \</div>
<div class="line">            : instance&lt;T, ::boost::hana::when&lt;true&gt;&gt;                        \</div>
<div class="line">        { };                                                                \</div>
<div class="line">                                                                            \</div>
<div class="line">        template &lt;typename T, bool condition&gt;                               \</div>
<div class="line">        struct instance&lt;T, ::boost::hana::when&lt;condition&gt;&gt;                  \</div>
<div class="line">            : ::boost::hana::core_detail::default_instance&lt;                 \</div>
<div class="line">                void, NAME, T                                               \</div>
<div class="line">            &gt;<a class="code" href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">::type</a>                                                         \</div>
<div class="line">        { }                                                                 \                                                     \</div>
<div class="ttc" id="structboost_1_1hana_1_1_type_html_ab66de88586706cb474453dd937d13f8c"><div class="ttname"><a href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">boost::hana::Type::type</a></div><div class="ttdeci">constexpr type_detail::make_type&lt; T &gt;::type type</div><div class="ttdoc">Creates an object representing the C++ type T. </div><div class="ttdef"><b>Definition:</b> type.hpp:82</div></div>
</div><!-- fragment -->
<p>Machinery for creating a unary type class. </p>
<h3>Creating a type class</h3>
<p>Creating a new type class is done by using the <code>BOOST_HANA_TYPECLASS</code> macro inside a struct with the desired name: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Typeclass {</div>
<div class="line">    <a class="code" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Typeclass);</div>
<div class="line">};</div>
</div><!-- fragment --><p>If desired, methods can be provided by putting them inside a nested type of <code>Typeclass</code>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Typeclass {</div>
<div class="line">    <a class="code" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Typeclass);</div>
<div class="line">    <span class="keyword">struct </span>some_member {</div>
<div class="line">        <span class="comment">// methods</span></div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p>In this library, type classes with a single minimal complete definition provide the other methods, if any, in the nested type named <code>mcd</code>. In the case where multiple minimal complete definitions exist, each set of provided methods is in a different nested type with a descriptive name. In all cases, the minimal complete definition(s) and the location of their associated set of provided methods are documented.</p>
<p>It is also possible to define a default instance for all data types. To do so, provide a nested <code>default_instance</code> template inside the type class: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Typeclass {</div>
<div class="line">    <a class="code" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Typeclass);</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...TypeclassArguments&gt;</div>
<div class="line">    <span class="keyword">struct </span>default_instance {</div>
<div class="line">        <span class="comment">// default instance for all data types</span></div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p>The nested <code>default_instance</code> should be just like a normal instance; see below for how to instantiate a type class. This can be used to provide a default behavior for all data types while still allowing this behavior to be customized by instantiating the type class. However, this should seldom be used because methods with a meaningful behavior for all data types are rare. This feature is provided for flexibility, but it should be a hint to reconsider your type class design if you are about to use it.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_8hpp.html">boost/hana/core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="constexpr_8hpp.html">boost/hana/detail/constexpr.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Showable {</div>
<div class="line">    <a class="code" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Showable);</div>
<div class="line">    <span class="keyword">struct </span>mcd { };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>default_instance : mcd {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">        <span class="keyword">static</span> std::string show_impl(X)</div>
<div class="line">        { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>; }</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> show = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> Showable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::show_impl(x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Showable::instance&lt;int&gt; : Showable::mcd {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> show_impl(<span class="keywordtype">int</span> i)</div>
<div class="line">    { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; i).str(); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>unshowable { };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    assert(show(1) == <span class="stringliteral">&quot;1&quot;</span>);</div>
<div class="line">    assert(show(unshowable{}) == <span class="stringliteral">&quot;&lt;?&gt;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Instantiating a type class</h3>
<p>Instantiating a type class is done by specializing the associated <code>instance</code> nested type: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Typeclass::instance&lt;Datatype&gt; : Typeclass::mcd {</div>
<div class="line">    <span class="comment">// minimal complete definition at least</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Inheriting from <code>Typeclass::mcd</code> makes the default methods associated to that minimal complete definition available. If multiple minimal complete definitions are provided, one has to choose and inherit from the corresponding set of default methods.</p>
<p>It is possible to over-define a type class, i.e. provide more methods than strictly necessary to fulfill the minimal complete definition. Simply implement those methods as if they were part of the minimal complete definition: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Typeclass::instance&lt;Datatype&gt; : Typeclass::mcd {</div>
<div class="line">    <span class="comment">// minimal complete definition</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// more methods</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Inheriting from a set of default methods is recommended even if default methods are not actually required, i.e. all the methods of the type class are implemented in the instance. This allows methods to be added to the type class without breaking the instance, provided the type class does not change its minimal complete definition(s).</p>
<p>Type classes can also be instantiated for all specializations of a parametric data type in the most natural way: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Typeclass::instance&lt;SomeDatatype&lt;T&gt;&gt; : Typeclass::mcd {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Finally, type classes can be instantiated for all data types satisfying some predicate: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Typeclass::instance&lt;T, when&lt;Predicate(T)&gt;&gt;</div>
<div class="line">    : Typeclass::mcd</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that instances provided through partial specialization have the priority over instances provided through a predicate. This allows data types (parametric or not) to instantiate a type class even if an instance for the same type class is provided through a predicate.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_8hpp.html">boost/hana/core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="constexpr_8hpp.html">boost/hana/detail/constexpr.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="static__assert_8hpp.html">boost/hana/detail/static_assert.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable {</div>
<div class="line">    <a class="code" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Incrementable);</div>
<div class="line">    <span class="keyword">struct </span>next_mcd;</div>
<div class="line">    <span class="keyword">struct </span>next_n_mcd;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::next_impl(x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next_n = [](<span class="keyword">auto</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::next_n_impl(x, n);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(X x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">        <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> x;</div>
<div class="line">        <span class="keywordflow">else</span>        <span class="keywordflow">return</span> next_n_impl(next(x), n - 1);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> next_n(x, 1); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;int&gt; : Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(<span class="keywordtype">int</span> x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;long&gt; : Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(<span class="keywordtype">long</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)</div>
<div class="line">    { <span class="keywordflow">return</span> x + n; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;T, hana::when&lt;std::is_floating_point&lt;T&gt;{}&gt;&gt;</div>
<div class="line">    : Incrementable::next_mcd</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1) == 2);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1, 3) == 4);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1l) == 2l);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1l, 3) == 4l);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1.0) == 2.0);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1.0, 3) == 4.0);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gae3cedd3772d00ac7c4de9dc3d719f321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typedef typename datatype&lt;T&gt;::<a class="el" href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to <code>datatype&lt;T&gt;::type</code>. </p>

</div>
</div>
<a class="anchor" id="ga0f5d717bbf6646619bb6219b104384dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = typedef when&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to instantiate a type class based on the validity of an expression. </p>
<p>Specifically, this is equivalent to <code>when&lt;true&gt;</code>, but SFINAE will cause the partial specialization to fail when the expression is ill-formed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga1505b4c072265b1461478be8e424e356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Typeclass , typename... Datatypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::instantiates</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the type class is instantiated with the given arguments. </p>
<p>This is provided in addition to <code>is_a</code> for type classes taking more than one argument or when no object of the data type is available. </p>

</div>
</div>
<a class="anchor" id="ga4f50738684d619fea95be73a38fd7f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Typeclass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr core_detail::is_a&lt;Typeclass&gt; boost::hana::is_a {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether an object is an instance of the given type class. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> row = list;</div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> check_table = [](<span class="keyword">auto</span> ...headers) {</div>
<div class="line">        <span class="keywordflow">return</span> [=](<span class="keyword">auto</span> ...rows) {</div>
<div class="line">            <span class="keyword">auto</span> row_is_correct = [=](<span class="keyword">auto</span> row) {</div>
<div class="line">                <span class="keywordflow">return</span> list(headers(head(row))...) == tail(row);</div>
<div class="line">            };</div>
<div class="line">            <span class="keyword">auto</span> typeclasses_match = all(row_is_correct, list(rows...));</div>
<div class="line">            static_assert(typeclasses_match(),</div>
<div class="line">            <span class="stringliteral">&quot;type classes in the table below are wrong&quot;</span>);</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    check_table(                      is_a&lt;Logical&gt;, is_an&lt;Iterable&gt;, is_a&lt;Monad&gt;   )(</div>
<div class="line">    row(just(1),                         false_,         false_,         true_      ),</div>
<div class="line">    row(list(1, <span class="charliteral">&#39;2&#39;</span>, 3.3),               false_,         true_,          true_      ),</div>
<div class="line">    row(std::make_tuple(<span class="stringliteral">&quot;abc&quot;</span>, <span class="charliteral">&#39;d&#39;</span>),     false_,         true_,          true_      ),</div>
<div class="line">    row(long_&lt;12&gt;,                       true_,          false_,         false_     ),</div>
<div class="line">    row(range(int_&lt;-4&gt;, int_&lt;15&gt;),       false_,         true_,          false_     )</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga4ffd5adfee9463f878117bdb8a37955a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Typeclass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr core_detail::is_a&lt;Typeclass&gt; boost::hana::is_an {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language. </p>

</div>
</div>
<a class="anchor" id="ga2a7d85fcbf846d9b63a8270f547309be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr core_detail::to&lt;To&gt; boost::hana::to {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object of a data type from an object of another data type. </p>
<p>See <code>convert</code> for how to specify user-defined conversions.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        to&lt;List&gt;(std::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == list(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        to&lt;List&gt;(range(int_&lt;1&gt;, int_&lt;4&gt;)) == list(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        to&lt;List&gt;(std::array&lt;int, 3&gt;{{1, 2, 3}}) == list(1, 2, 3)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jul 23 2014 20:47:11 for Boost.Hana by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
