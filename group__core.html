<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Boost.Hana: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__core.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous core utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structboost_1_1hana_1_1convert"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#structboost_1_1hana_1_1convert">boost::hana::convert&lt; To, From, Enable &gt;</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1convert"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements conversions between data types.  <a href="group__core.html#structboost_1_1hana_1_1convert">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1convert"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1when"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#structboost_1_1hana_1_1when">boost::hana::when&lt; condition &gt;</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1when"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to instantiate a type class based on the value of a predicate.  <a href="group__core.html#structboost_1_1hana_1_1when">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1when"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1disable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#structboost_1_1hana_1_1disable">boost::hana::disable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1disable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly disable a type class instance.  <a href="group__core.html#structboost_1_1hana_1_1disable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1disable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1datatype"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#structboost_1_1hana_1_1datatype">boost::hana::datatype&lt; T, Enable &gt;</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1datatype"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning the data type associated to <code>T</code>.  <a href="group__core.html#structboost_1_1hana_1_1datatype">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1datatype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1operators_1_1enable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#structboost_1_1hana_1_1operators_1_1enable">boost::hana::operators::enable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1operators_1_1enable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows operators in the <code>boost::hana::operators</code> namespace to be found by ADL.  <a href="group__core.html#structboost_1_1hana_1_1operators_1_1enable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1operators_1_1enable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac072d4434777cd5ee841a7766d41f1d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(NAME)</td></tr>
<tr class="memdesc:gac072d4434777cd5ee841a7766d41f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a unary type class.  <a href="#gac072d4434777cd5ee841a7766d41f1d8">More...</a><br /></td></tr>
<tr class="separator:gac072d4434777cd5ee841a7766d41f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gabc68f88756ee6bb3b727d8f0abea8ee5">BOOST_HANA_BINARY_TYPECLASS</a>(NAME)</td></tr>
<tr class="memdesc:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a binary type class.  <a href="#gabc68f88756ee6bb3b727d8f0abea8ee5">More...</a><br /></td></tr>
<tr class="separator:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = when&lt; true &gt;</td></tr>
<tr class="memdesc:ga0f5d717bbf6646619bb6219b104384dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to instantiate a type class based on the validity of an expression.  <a href="#ga0f5d717bbf6646619bb6219b104384dc">More...</a><br /></td></tr>
<tr class="separator:ga0f5d717bbf6646619bb6219b104384dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae3cedd3772d00ac7c4de9dc3d719f321"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typename datatype&lt; T &gt;::<a class="el" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a></td></tr>
<tr class="memdesc:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>datatype&lt;T&gt;::type</code>. <br /></td></tr>
<tr class="separator:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1505b4c072265b1461478be8e424e356"><td class="memTemplParams" colspan="2">template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga1505b4c072265b1461478be8e424e356"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga1505b4c072265b1461478be8e424e356">boost::hana::instantiates</a></td></tr>
<tr class="memdesc:ga1505b4c072265b1461478be8e424e356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the type class is instantiated with the given arguments.  <a href="#ga1505b4c072265b1461478be8e424e356">More...</a><br /></td></tr>
<tr class="separator:ga1505b4c072265b1461478be8e424e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f50738684d619fea95be73a38fd7f47"><td class="memTemplParams" colspan="2">template&lt;typename Typeclass &gt; </td></tr>
<tr class="memitem:ga4f50738684d619fea95be73a38fd7f47"><td class="memTemplItemLeft" align="right" valign="top">constexpr core_detail::is_a<br class="typebreak" />
&lt; Typeclass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga4f50738684d619fea95be73a38fd7f47">boost::hana::is_a</a> {}</td></tr>
<tr class="memdesc:ga4f50738684d619fea95be73a38fd7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether an object is an instance of the given type class.  <a href="#ga4f50738684d619fea95be73a38fd7f47">More...</a><br /></td></tr>
<tr class="separator:ga4f50738684d619fea95be73a38fd7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffd5adfee9463f878117bdb8a37955a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4ffd5adfee9463f878117bdb8a37955a"></a>
template&lt;typename Typeclass &gt; </td></tr>
<tr class="memitem:ga4ffd5adfee9463f878117bdb8a37955a"><td class="memTemplItemLeft" align="right" valign="top">constexpr core_detail::is_a<br class="typebreak" />
&lt; Typeclass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga4ffd5adfee9463f878117bdb8a37955a">boost::hana::is_an</a> {}</td></tr>
<tr class="memdesc:ga4ffd5adfee9463f878117bdb8a37955a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language. <br /></td></tr>
<tr class="separator:ga4ffd5adfee9463f878117bdb8a37955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7d85fcbf846d9b63a8270f547309be"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:ga2a7d85fcbf846d9b63a8270f547309be"><td class="memTemplItemLeft" align="right" valign="top">constexpr core_detail::to&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga2a7d85fcbf846d9b63a8270f547309be">boost::hana::to</a> {}</td></tr>
<tr class="memdesc:ga2a7d85fcbf846d9b63a8270f547309be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of a data type from an object of another data type.  <a href="#ga2a7d85fcbf846d9b63a8270f547309be">More...</a><br /></td></tr>
<tr class="separator:ga2a7d85fcbf846d9b63a8270f547309be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Miscellaneous core utilities. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structboost_1_1hana_1_1convert" id="structboost_1_1hana_1_1convert"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::convert</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename To, typename From, typename Enable = void&gt;<br />
struct boost::hana::convert&lt; To, From, Enable &gt;</h3>

<p>Implements conversions between data types. </p>
<p>To specify a conversion between two data types, one must specialize <code>convert</code> for the corresponding data types. A dummy template parameter is also provided for SFINAE. This allows conversions to be specified for all data types satisfying a predicate.</p>
<p>By default, <code>convert</code> has the following behavior: If the <code>To</code> and <code>From</code> data types are the same, nothing is done. Otherwise, if the type of the converted-from object &ndash; its actual type, not its data type &ndash; is convertible to the <code>To</code> data type with <code>static_cast</code>, that conversion is used. Otherwise, a static assertion is triggered.</p>
<dl class="section note"><dt>Note</dt><dd><code>convert</code> is only used to provide the conversions; to actually perform conversions, use <code>to</code>.</dd></dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/comparable/equal_mcd.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/ext/std/list.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/list/instance.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>StdVector;</div>
<div class="line"><span class="keyword">struct </span>StdList;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__core.html#structboost_1_1hana_1_1datatype">datatype</a>&lt;std::vector&lt;T&gt;&gt; { <span class="keyword">using</span> type = StdVector; };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>Comparable::instance&lt;StdVector, StdVector&gt; : <a class="code" href="structboost_1_1hana_1_1_comparable_1_1equal__mcd.html">Comparable::equal_mcd</a> {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">auto</span> equal_impl(std::vector&lt;T&gt; xs, std::vector&lt;T&gt; ys)</div>
<div class="line">        { <span class="keywordflow">return</span> xs == ys; }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="group__core.html#structboost_1_1hana_1_1convert">convert</a>&lt;StdVector, StdList&gt; {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">        <span class="keyword">static</span> std::vector&lt;T&gt; <a class="code" href="group___functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::list&lt;T&gt; xs) {</div>
<div class="line">            std::vector&lt;T&gt; v{};</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> x: xs)</div>
<div class="line">                v.push_back(x);</div>
<div class="line">            <span class="keywordflow">return</span> v;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> xs = list(</div>
<div class="line">        std::list&lt;int&gt;{1, 2, 3, 4},</div>
<div class="line">        std::list&lt;char&gt;{<span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>},</div>
<div class="line">        std::list&lt;std::string&gt;{<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>}</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    assert(fmap(to&lt;StdVector&gt;, xs) == list(</div>
<div class="line">        std::vector&lt;int&gt;{1, 2, 3, 4},</div>
<div class="line">        std::vector&lt;char&gt;{<span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>},</div>
<div class="line">        std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>}</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> </div>
<p>Inherits boost::hana::core_detail::default_convert&lt; To, From &gt;.</p>

</div>
</div>
<a name="structboost_1_1hana_1_1when" id="structboost_1_1hana_1_1when"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::when</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;bool condition&gt;<br />
struct boost::hana::when&lt; condition &gt;</h3>

<p>Used to instantiate a type class based on the value of a predicate. </p>
<dl class="section note"><dt>Note</dt><dd><code>when</code> is provided whenever the header of a type class is included; including boost/hana/core.hpp is not necessary in that case.</dd></dl>
<p>Using <code>when</code> is necessary for two reasons. First, a non-type template argument may not depend on a template parameter of a partial specialization, so we need to wrap the <code>bool</code> result of the predicate into a type. Second, <code>when</code> is used to implement the priority of partially specialized instances over predicated instances, but we could also achieve the same by replacing <code>when&lt;true&gt;</code> with <code>void</code> and letting people use <code>enable_if</code>. </p>
</div>
</div>
</div>
<a name="structboost_1_1hana_1_1disable" id="structboost_1_1hana_1_1disable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::disable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Explicitly disable a type class instance. </p>
<p>This is meant as a way to disable a type class instance provided through a predicate which, for some reason, is not desirable for a given data type.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/detail/static_assert.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/ext/std/tuple.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/list/list.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>Foldable::instance&lt;StdTuple&gt; : <a class="code" href="group__core.html#structboost_1_1hana_1_1disable">disable</a> { };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Usually, List should provide Foldable.</span></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(instantiates&lt;List, StdTuple&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!instantiates&lt;Foldable, StdTuple&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --> </div>
<p>Inherited by boost::hana::Comparable::default_instance&lt; T, T &gt;.</p>

</div>
</div>
<a name="structboost_1_1hana_1_1datatype" id="structboost_1_1hana_1_1datatype"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::datatype</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename Enable = void&gt;<br />
struct boost::hana::datatype&lt; T, Enable &gt;</h3>

<p>Metafunction returning the data type associated to <code>T</code>. </p>
<p>By default, this metafunction returns <code>T::hana_datatype</code> if that expression is valid, and <code>T</code> otherwise. It can also be specialized to customize the data type of <code>T</code> without requiring <code>T</code> to have a nested <code>hana_datatype</code> type. A dummy parameter is also provided to allow <code>datatype</code> to be specialized for all types satisfying a predicate using <code>std::enable_if</code>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd><ul>
<li>Could this be related to <code>decltype_</code>? If so, how? It is a valid question whether <code>decltype_(list(...))</code> should be <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> or <code>&lt;garbage&gt;</code>.</li>
<li>Consider using two layers of specializations to improve performance if this is an issue. I suspect that using the enabler will hurt performance a lot because it requires the compiler to look at all the enablers each time <code>datatype</code> is instantiated. </li>
</ul>
</dd></dl>
</div>
</div>
</div>
<a name="structboost_1_1hana_1_1operators_1_1enable" id="structboost_1_1hana_1_1operators_1_1enable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::operators::enable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Allows operators in the <code>boost::hana::operators</code> namespace to be found by ADL. </p>
<p>Use this as a dummy template parameter or base class to make operators in the <code>boost::hana::operators</code> namespace ADL-findable for a type.</p>
<dl class="section note"><dt>Note</dt><dd>boost/hana/core.hpp does not need to be included when the header of a type class providing operators has been included.</dd>
<dd>
Nothing except operators should be defined in this namespace; otherwise, ambiguities can arise when <code>using namespace operators</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Is ADL really the best way of providing custom operators? This has (at least) the problem that templated types which have nothing to do with Boost.Hana could have their set of associated namespaces augmented with <code>boost::hana::operators</code> in an undesirable way: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>nothing_to_do_with_hana { };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = operators::enable&gt;</div>
<div class="line"><span class="keyword">struct </span>something_to_do_with_hana { };</div>
<div class="line"></div>
<div class="line">nothing_to_do_with_hana&lt;something_to_do_with_hana&lt;int&gt;&gt; x{};</div>
<div class="line">x == x; <span class="comment">// tries to use Comparable::equal_impl</span></div>
</div><!-- fragment --> </dd></dl>
</div>
<p>Inherited by boost::hana::constant_detail::constant&lt; T, t &gt;, boost::hana::ilist_detail::integer_list&lt; T, xs &gt;, boost::hana::integral_detail::integral&lt; T, t &gt;, boost::hana::tlist_detail::type_list&lt; xs &gt;::type, boost::hana::type_detail::make_type&lt; T &gt;::type_, boost::hana::ilist_detail::integer_list&lt; T, xs...&gt;, and boost::hana::integral_detail::integral&lt; typename detail::std::remove_cv&lt; T &gt;::type, v &gt;.</p>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac072d4434777cd5ee841a7766d41f1d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_TYPECLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;boost/hana/detail/typeclasses.hpp&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">                                                        \</div>
<div class="line">        template &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...&gt;                                 \</div>
<div class="line">        struct instance                                                     \</div>
<div class="line">            : instance&lt;T, ::boost::hana::when&lt;true&gt;&gt;                        \</div>
<div class="line">        { };                                                                \</div>
<div class="line">                                                                            \</div>
<div class="line">        template &lt;typename T, bool condition&gt;                               \</div>
<div class="line">        struct instance&lt;T, ::boost::hana::when&lt;condition&gt;&gt;                  \</div>
<div class="line">            : ::boost::hana::core_detail::default_instance&lt;                 \</div>
<div class="line">                void, NAME, T                                               \</div>
<div class="line">            &gt;<a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">::type</a>                                                         \</div>
<div class="line">        { }                                                                 \                                                     \</div>
<div class="ttc" id="group__datatypes_html_ab66de88586706cb474453dd937d13f8c"><div class="ttname"><a href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">boost::hana::Type::type</a></div><div class="ttdeci">constexpr type_detail::make_type&lt; T &gt;::type type</div><div class="ttdoc">Creates an object representing the C++ type T. </div><div class="ttdef"><b>Definition:</b> type.hpp:78</div></div>
</div><!-- fragment -->
<p>Defines a unary type class. </p>
<p>Use this macro at public scope when defining a type class to create the boilerplate necessary for a unary type class.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/detail/constexpr.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/detail/static_assert.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable {</div>
<div class="line">    <a class="code" href="group__core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Incrementable);</div>
<div class="line">    <span class="keyword">struct </span>next_mcd;</div>
<div class="line">    <span class="keyword">struct </span>next_n_mcd;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::next_impl(x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next_n = [](<span class="keyword">auto</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;hana::datatype_t&lt;decltype(x)&gt;&gt;::next_n_impl(x, n);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(X x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">        <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> x;</div>
<div class="line">        <span class="keywordflow">else</span>        <span class="keywordflow">return</span> next_n_impl(next(x), n - 1);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> next_n(x, 1); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;int&gt; : Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(<span class="keywordtype">int</span> x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;long&gt; : Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(<span class="keywordtype">long</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)</div>
<div class="line">    { <span class="keywordflow">return</span> x + n; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;T, hana::when&lt;std::is_floating_point&lt;T&gt;{}&gt;&gt;</div>
<div class="line">    : Incrementable::next_mcd</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1) == 2);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1, 3) == 4);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1l) == 2l);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1l, 3) == 4l);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next(1.0) == 2.0);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(next_n(1.0, 3) == 4.0);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gabc68f88756ee6bb3b727d8f0abea8ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_BINARY_TYPECLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;boost/hana/detail/typeclasses.hpp&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">                                                        \</div>
<div class="line">        template &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> ...&gt;                     \</div>
<div class="line">        struct instance                                                     \</div>
<div class="line">            : instance&lt;T, U, ::boost::hana::when&lt;true&gt;&gt;                     \</div>
<div class="line">        { };                                                                \</div>
<div class="line">                                                                            \</div>
<div class="line">        template &lt;typename T, typename U, bool condition&gt;                   \</div>
<div class="line">        struct instance&lt;T, U, ::boost::hana::when&lt;condition&gt;&gt;               \</div>
<div class="line">            : ::boost::hana::core_detail::default_instance&lt;                 \</div>
<div class="line">                void, NAME, T, U                                            \</div>
<div class="line">            &gt;<a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">::type</a>                                                         \</div>
<div class="line">        { }                                                                 \                                                     \</div>
<div class="ttc" id="group__datatypes_html_ab66de88586706cb474453dd937d13f8c"><div class="ttname"><a href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">boost::hana::Type::type</a></div><div class="ttdeci">constexpr type_detail::make_type&lt; T &gt;::type type</div><div class="ttdoc">Creates an object representing the C++ type T. </div><div class="ttdef"><b>Definition:</b> type.hpp:78</div></div>
</div><!-- fragment -->
<p>Defines a binary type class. </p>
<p>This is equivalent to <code>BOOST_HANA_TYPECLASS</code>, except it creates a type class with two arguments. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga0f5d717bbf6646619bb6219b104384dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = typedef when&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;boost/hana/detail/typeclasses.hpp&gt;</code></p>

<p>Used to instantiate a type class based on the validity of an expression. </p>
<p>Specifically, this is equivalent to <code>when&lt;true&gt;</code>, but SFINAE will cause the partial specialization to fail when the expression is ill-formed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga1505b4c072265b1461478be8e424e356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Typeclass , typename... Datatypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::instantiates</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;boost/hana/core.hpp&gt;</code></p>

<p>Whether the type class is instantiated with the given arguments. </p>
<p>This is provided in addition to <code>is_a</code> for type classes taking more than one argument or when no object of the data type is available. </p>

</div>
</div>
<a class="anchor" id="ga4f50738684d619fea95be73a38fd7f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Typeclass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr core_detail::is_a&lt;Typeclass&gt; boost::hana::is_a {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;boost/hana/core.hpp&gt;</code></p>

<p>Return whether an object is an instance of the given type class. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> row = list;</div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> check_table = [](<span class="keyword">auto</span> ...headers) {</div>
<div class="line">        <span class="keywordflow">return</span> [=](<span class="keyword">auto</span> ...rows) {</div>
<div class="line">            <span class="keyword">auto</span> row_is_correct = [=](<span class="keyword">auto</span> row) {</div>
<div class="line">                <span class="keywordflow">return</span> list(headers(head(row))...) == tail(row);</div>
<div class="line">            };</div>
<div class="line">            <span class="keyword">auto</span> typeclasses_match = all(row_is_correct, list(rows...));</div>
<div class="line">            static_assert(typeclasses_match(),</div>
<div class="line">            <span class="stringliteral">&quot;type classes in the table below are wrong&quot;</span>);</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    check_table(                      is_a&lt;Logical&gt;, is_an&lt;Iterable&gt;, is_a&lt;Monad&gt;   )(</div>
<div class="line">    row(just(1),                         false_,         false_,         true_      ),</div>
<div class="line">    row(list(1, <span class="charliteral">&#39;2&#39;</span>, 3.3),               false_,         true_,          true_      ),</div>
<div class="line">    row(std::make_tuple(<span class="stringliteral">&quot;abc&quot;</span>, <span class="charliteral">&#39;d&#39;</span>),     false_,         true_,          true_      ),</div>
<div class="line">    row(long_&lt;12&gt;,                       true_,          false_,         false_     ),</div>
<div class="line">    row(range(int_&lt;-4&gt;, int_&lt;15&gt;),       false_,         true_,          false_     )</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga2a7d85fcbf846d9b63a8270f547309be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr core_detail::to&lt;To&gt; boost::hana::to {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;boost/hana/core.hpp&gt;</code></p>

<p>Create an object of a data type from an object of another data type. </p>
<p>See <code>convert</code> for how to specify user-defined conversions.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        to&lt;List&gt;(std::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == list(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        to&lt;List&gt;(range(int_&lt;1&gt;, int_&lt;4&gt;)) == list(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        to&lt;List&gt;(std::array&lt;int, 3&gt;{{1, 2, 3}}) == list(1, 2, 3)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
