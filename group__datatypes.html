<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Boost.Hana: Data types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__datatypes.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Data types</div>  </div>
</div><!--header-->
<div class="contents">

<p>General purpose data types provided by the library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structboost_1_1hana_1_1_constant"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_constant">boost::hana::Constant</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_constant"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a compile-time constant.  <a href="group__datatypes.html#structboost_1_1hana_1_1_constant">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_constant"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_integral"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral">boost::hana::Integral</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_integral"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a compile-time value of an integral type.  <a href="group__datatypes.html#structboost_1_1hana_1_1_integral">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_integral"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_maybe"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe">boost::hana::Maybe</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_maybe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional value.  <a href="group__datatypes.html#structboost_1_1hana_1_1_maybe">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_maybe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_bottom"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_bottom">boost::hana::Bottom</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_bottom"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_bottom" title="The Bottom data type represents statically type-erased data. ">Bottom</a></code> data type represents statically type-erased data.  <a href="group__datatypes.html#structboost_1_1hana_1_1_bottom">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_bottom"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_integer_list"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integer_list">boost::hana::IntegerList</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_integer_list"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s of the same underlying type only.  <a href="group__datatypes.html#structboost_1_1hana_1_1_integer_list">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_integer_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_lazy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy">boost::hana::Lazy</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_lazy"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> data type implements superficial laziness via a monadic interface.  <a href="group__datatypes.html#structboost_1_1hana_1_1_lazy">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_lazy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_list"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list">boost::hana::List</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose index-based sequence.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_list">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_map"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_map">boost::hana::Map</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_map"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic associative array requiring unique and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> keys.  <a href="group__datatypes.html#structboost_1_1hana_1_1_map">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_pair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair">boost::hana::Pair</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_pair"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container of two elements.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_pair">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_pair"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_range"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_range">boost::hana::Range</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_range"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time half-open interval of <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s.  <a href="group__datatypes.html#structboost_1_1hana_1_1_range">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_range"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_set"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_set">boost::hana::Set</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic unordered container requiring <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> elements.  <a href="group__datatypes.html#structboost_1_1hana_1_1_set">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type">boost::hana::Type</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ type represented as a constexpr object.  <a href="group__datatypes.html#structboost_1_1hana_1_1_type">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_type_list"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type_list">boost::hana::TypeList</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_type_list"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s only.  <a href="group__datatypes.html#structboost_1_1hana_1_1_type_list">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_type_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>General purpose data types provided by the library. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structboost_1_1hana_1_1_constant" id="structboost_1_1hana_1_1_constant"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Constant</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a compile-time constant. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Integrate this with <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> and the rest of the library. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:afcc57cf7f8ee276eb9bae67cfa68fad2"><td class="memTemplParams" colspan="2">template&lt;typename T , T t&gt; </td></tr>
<tr class="memitem:afcc57cf7f8ee276eb9bae67cfa68fad2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
constant_detail::constant&lt; T, <br class="typebreak" />
t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#afcc57cf7f8ee276eb9bae67cfa68fad2">constant</a> {}</td></tr>
<tr class="memdesc:afcc57cf7f8ee276eb9bae67cfa68fad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a compile-time constant of the given type and holding the given value.  <a href="#afcc57cf7f8ee276eb9bae67cfa68fad2">More...</a><br /></td></tr>
<tr class="separator:afcc57cf7f8ee276eb9bae67cfa68fad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="afcc57cf7f8ee276eb9bae67cfa68fad2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr constant_detail::constant&lt;T, t&gt; constant {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a compile-time constant of the given type and holding the given value. </p>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_integral" id="structboost_1_1hana_1_1_integral"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Integral</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a compile-time value of an integral type. </p>
<p>Let <code>n</code> be an object of an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> data type. The compile-time value represented by <code>n</code> is accessible as <code>n()</code>, which is a <code>constexpr</code> object of the underlying integral type. <code>n</code> is also implicitly <code>constexpr</code>-convertible to the underlying integral type.</p>
<h2>Instance of</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> </p><hr/>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Implicit conversions to the underlying integral type can be problematic: <div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % int_&lt;2&gt;;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">if_(odd(int_&lt;1&gt;), something_of_type_A, something_of_type_B)</div>
</div><!-- fragment --> This will fail because <code>odd(int_&lt;1&gt;)</code> has type <code>Int&lt;1 % 2&gt;</code>, which is convertible to <code>bool</code> but not to <code>Bool&lt;...&gt;</code>. Because of this, the runtime <code>if_</code> is used and compilation fails. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a9fdcfeb2aec3af66ec8e83d02960d947"><td class="memTemplParams" colspan="2">template&lt;typename T , T v&gt; </td></tr>
<tr class="memitem:a9fdcfeb2aec3af66ec8e83d02960d947"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
integral_detail::integral<br class="typebreak" />
&lt; typename <br class="typebreak" />
detail::std::remove_cv&lt; T &gt;<br class="typebreak" />
::type, v &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a> {}</td></tr>
<tr class="memdesc:a9fdcfeb2aec3af66ec8e83d02960d947"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time integral value of the given type and value.  <a href="#a9fdcfeb2aec3af66ec8e83d02960d947">More...</a><br /></td></tr>
<tr class="separator:a9fdcfeb2aec3af66ec8e83d02960d947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a8576fc56fe55152b2478f190561f"><td class="memTemplParams" colspan="2">template&lt;bool b&gt; </td></tr>
<tr class="memitem:acf0a8576fc56fe55152b2478f190561f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#acf0a8576fc56fe55152b2478f190561f">bool_</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;bool, b&gt;){}</td></tr>
<tr class="separator:acf0a8576fc56fe55152b2478f190561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6096d56dd1b76bb9d37e4121eb5b33c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ae6096d56dd1b76bb9d37e4121eb5b33c">true_</a> = <a class="el" href="group__datatypes.html#acf0a8576fc56fe55152b2478f190561f">bool_</a>&lt;true&gt;</td></tr>
<tr class="separator:ae6096d56dd1b76bb9d37e4121eb5b33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb33fb686dbbe3e9718071ba2630641"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a1fb33fb686dbbe3e9718071ba2630641">false_</a> = <a class="el" href="group__datatypes.html#acf0a8576fc56fe55152b2478f190561f">bool_</a>&lt;false&gt;</td></tr>
<tr class="separator:a1fb33fb686dbbe3e9718071ba2630641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fa34981b7b50cbbb75482e3b95745c"><td class="memTemplParams" colspan="2">template&lt;char c&gt; </td></tr>
<tr class="memitem:ad2fa34981b7b50cbbb75482e3b95745c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ad2fa34981b7b50cbbb75482e3b95745c">char_</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;char, c&gt;){}</td></tr>
<tr class="separator:ad2fa34981b7b50cbbb75482e3b95745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84287b99d47602c48157098aa1beb529"><td class="memTemplParams" colspan="2">template&lt;short i&gt; </td></tr>
<tr class="memitem:a84287b99d47602c48157098aa1beb529"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a84287b99d47602c48157098aa1beb529">short_</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;short, i&gt;){}</td></tr>
<tr class="separator:a84287b99d47602c48157098aa1beb529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e80ee14529e7c6549266c51b2b953b"><td class="memTemplParams" colspan="2">template&lt;unsigned short i&gt; </td></tr>
<tr class="memitem:a22e80ee14529e7c6549266c51b2b953b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a22e80ee14529e7c6549266c51b2b953b">ushort</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned short, i&gt;){}</td></tr>
<tr class="separator:a22e80ee14529e7c6549266c51b2b953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bc46564313c4d3aeb0997bd92759e6"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:ab7bc46564313c4d3aeb0997bd92759e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ab7bc46564313c4d3aeb0997bd92759e6">int_</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;int, i&gt;){}</td></tr>
<tr class="separator:ab7bc46564313c4d3aeb0997bd92759e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3885aa06ddc4628710dc00cf74cbb9"><td class="memTemplParams" colspan="2">template&lt;unsigned int i&gt; </td></tr>
<tr class="memitem:ade3885aa06ddc4628710dc00cf74cbb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ade3885aa06ddc4628710dc00cf74cbb9">uint</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned int, i&gt;){}</td></tr>
<tr class="separator:ade3885aa06ddc4628710dc00cf74cbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f0f0f418542662d6d3d6ad92a896e0"><td class="memTemplParams" colspan="2">template&lt;long i&gt; </td></tr>
<tr class="memitem:ac9f0f0f418542662d6d3d6ad92a896e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ac9f0f0f418542662d6d3d6ad92a896e0">long_</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;long, i&gt;){}</td></tr>
<tr class="separator:ac9f0f0f418542662d6d3d6ad92a896e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa699749e8ef0e4d1bdad9a0749c9519d"><td class="memTemplParams" colspan="2">template&lt;unsigned long i&gt; </td></tr>
<tr class="memitem:aa699749e8ef0e4d1bdad9a0749c9519d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#aa699749e8ef0e4d1bdad9a0749c9519d">ulong</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned long, i&gt;){}</td></tr>
<tr class="separator:aa699749e8ef0e4d1bdad9a0749c9519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d39c4f98b84422263842b6c04ef0a7e"><td class="memTemplParams" colspan="2">template&lt;long long i&gt; </td></tr>
<tr class="memitem:a1d39c4f98b84422263842b6c04ef0a7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a1d39c4f98b84422263842b6c04ef0a7e">llong</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;long long, i&gt;){}</td></tr>
<tr class="separator:a1d39c4f98b84422263842b6c04ef0a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c81419f29a6116793e524ac98b5931b"><td class="memTemplParams" colspan="2">template&lt;unsigned long long i&gt; </td></tr>
<tr class="memitem:a2c81419f29a6116793e524ac98b5931b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a2c81419f29a6116793e524ac98b5931b">ullong</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned long long, i&gt;){}</td></tr>
<tr class="separator:a2c81419f29a6116793e524ac98b5931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd564787f4fd66ab9a0270cae08785d"><td class="memTemplParams" colspan="2">template&lt;detail::std::size_t i&gt; </td></tr>
<tr class="memitem:a0bd564787f4fd66ab9a0270cae08785d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a0bd564787f4fd66ab9a0270cae08785d">size_t</a> = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;detail::std::size_t, i&gt;){}</td></tr>
<tr class="separator:a0bd564787f4fd66ab9a0270cae08785d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c078fd00db48686ca9e0aa17f47344e"><td class="memTemplParams" colspan="2">template&lt;char... c&gt; </td></tr>
<tr class="memitem:a1c078fd00db48686ca9e0aa17f47344e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a1c078fd00db48686ca9e0aa17f47344e">operator&quot;&quot;_c</a> ()</td></tr>
<tr class="memdesc:a1c078fd00db48686ca9e0aa17f47344e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> from a literal.  <a href="#a1c078fd00db48686ca9e0aa17f47344e">More...</a><br /></td></tr>
<tr class="separator:a1c078fd00db48686ca9e0aa17f47344e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a9fdcfeb2aec3af66ec8e83d02960d947"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T v&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr integral_detail::integral&lt; typename detail::std::remove_cv&lt;T&gt;::type, v &gt; integral {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time integral value of the given type and value. </p>
<p>For convenience, common operators are overloaded to return the result of the corresponding operator as an <code>integral&lt;...&gt;</code>.</p>
<h3>Overloaded operators</h3>
<ul>
<li>Arithmetic: binary <code>+</code>, binary <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, unary <code>+</code>, unary <code>-</code></li>
<li>Bitwise: <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
<li><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a>: <code>||</code>, <code>&amp;&amp;</code>, <code>!</code></li>
<li>Member access: <code>*</code> (dereference)</li>
</ul>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(int_&lt;1&gt; + int_&lt;3&gt; == int_&lt;4&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(int_&lt;1&gt; + int_&lt;3&gt;) == decltype_(int_&lt;4&gt;));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Mixed-type operations are supported:</span></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(size_t&lt;3&gt; * ushort&lt;5&gt;) == decltype_(size_t&lt;15&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(size_t&lt;15&gt;) != decltype_(int_&lt;15&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(size_t&lt;3&gt; * ushort&lt;5&gt; == int_&lt;15&gt;);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For any <code>const-volatility</code> specifier <code>cv</code>, <code>integral&lt;T cv, n&gt;</code> is always the same as <code>integral&lt;T, n&gt;</code>.</dd></dl>
<h3>Rationale for striping cv-specifiers</h3>
<p>In the following idiom, </p><div class="fragment"><div class="line">integral&lt;decltype(Trait::value), Trait::value&gt;</div>
</div><!-- fragment --><p> if <code>Trait::value</code> is declared as <code>static const T value = ...;</code>, then <code>decltype(Trait::value)</code> is <code>T const</code> instead of <code>T</code>. This causes unintuitive behavior in some cases. For example, with a definition of <code>trait::is_floating_point</code> using the above idiom, </p><div class="fragment"><div class="line">static_assert(</div>
<div class="line">    decltype_(trait::is_floating_point(type&lt;char&gt;)) ==</div>
<div class="line">    decltype_(<a class="code" href="group__datatypes.html#a1fb33fb686dbbe3e9718071ba2630641">false_</a>)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> will fail, but the following will succeed </p><div class="fragment"><div class="line">static_assert(</div>
<div class="line">    decltype_(trait::is_floating_point(type&lt;char&gt;)) ==</div>
<div class="line">    decltype_(integral&lt;bool const, false&gt;)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Since there does not seem to be a lot of use cases for keeping cv-qualifiers in the integral type, we just remove them.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Do we want <code>char_&lt;1&gt; + char_&lt;2&gt; == char_&lt;3&gt;</code> or <code>char_&lt;1&gt; + char_&lt;2&gt; == int_&lt;3&gt;</code>? </dd></dl>

</div>
</div>
<a class="anchor" id="acf0a8576fc56fe55152b2478f190561f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool b&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bool_ = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;bool, b&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6096d56dd1b76bb9d37e4121eb5b33c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto true_ = <a class="el" href="group__datatypes.html#acf0a8576fc56fe55152b2478f190561f">bool_</a>&lt;true&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1fb33fb686dbbe3e9718071ba2630641"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto false_ = <a class="el" href="group__datatypes.html#acf0a8576fc56fe55152b2478f190561f">bool_</a>&lt;false&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2fa34981b7b50cbbb75482e3b95745c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;char c&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto char_ = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;char, c&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84287b99d47602c48157098aa1beb529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;short i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto short_ = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;short, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a22e80ee14529e7c6549266c51b2b953b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ushort = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned short, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7bc46564313c4d3aeb0997bd92759e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto int_ = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;int, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ade3885aa06ddc4628710dc00cf74cbb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto uint = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned int, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9f0f0f418542662d6d3d6ad92a896e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto long_ = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;long, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa699749e8ef0e4d1bdad9a0749c9519d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned long i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ulong = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned long, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d39c4f98b84422263842b6c04ef0a7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long long i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llong = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;long long, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2c81419f29a6116793e524ac98b5931b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned long long i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ullong = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;unsigned long long, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0bd564787f4fd66ab9a0270cae08785d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::std::size_t i&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto size_t = decltype(<a class="el" href="group__datatypes.html#a9fdcfeb2aec3af66ec8e83d02960d947">integral</a>&lt;detail::std::size_t, i&gt;){}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c078fd00db48686ca9e0aa17f47344e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;char... c&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&quot;&quot;_c </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> from a literal. </p>
<p>The literal is parsed at compile-time and the result is returned as an <code>llong&lt;...&gt;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>We use <code>llong&lt;...&gt;</code> instead of <code>ullong&lt;...&gt;</code> because using an unsigned type leads to unexpected behavior when doing stuff like <code>-1_c</code>. If we used an unsigned type, <code>-1_c</code> would be something like <code>ullong&lt;-1&gt;</code> which is actually <code>ullong&lt;something huge&gt;</code>.</dd></dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(1234_c == llong&lt;1234&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(1234_c) == decltype_(llong&lt;1234&gt;));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(-1234_c == llong&lt;-1234&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(-1234_c) == decltype_(llong&lt;-1234&gt;));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(sum(list(1_c, 2_c, 3_c, 4_c)) == 10_c);</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Add support for stuff like <code>0x1234_c</code>. </dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_maybe" id="structboost_1_1hana_1_1_maybe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Maybe</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents an optional value. </p>
<p>A <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code> either contains a value (represented as <code>just(x)</code>), or it is empty (represented as <code>nothing</code>). </p><hr/>
<h2>Instance of</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code> and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_foldable" title="Data structures that can be folded, i.e. summarized into a single value. ">Foldable</a></code> </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8ad818d6df7379b0adefa45d2ac844d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ad818d6df7379b0adefa45d2ac844d0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a8ad818d6df7379b0adefa45d2ac844d0">just</a></td></tr>
<tr class="memdesc:a8ad818d6df7379b0adefa45d2ac844d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an optional value containing <code>x</code>. <br /></td></tr>
<tr class="separator:a8ad818d6df7379b0adefa45d2ac844d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be2b3e89cab04d5f1e2b9edefdb2518"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2be2b3e89cab04d5f1e2b9edefdb2518"></a>
constexpr maybe_detail::nothing&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a2be2b3e89cab04d5f1e2b9edefdb2518">nothing</a></td></tr>
<tr class="memdesc:a2be2b3e89cab04d5f1e2b9edefdb2518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty optional value. <br /></td></tr>
<tr class="separator:a2be2b3e89cab04d5f1e2b9edefdb2518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6529e11cb228e99a05e81071752807d5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a6529e11cb228e99a05e81071752807d5">maybe</a></td></tr>
<tr class="memdesc:a6529e11cb228e99a05e81071752807d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to the contents of a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code>, with a fallback result.  <a href="#a6529e11cb228e99a05e81071752807d5">More...</a><br /></td></tr>
<tr class="separator:a6529e11cb228e99a05e81071752807d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1047a69893a62cd36eb0d2934f85e0e7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a1047a69893a62cd36eb0d2934f85e0e7">is_just</a></td></tr>
<tr class="memdesc:a1047a69893a62cd36eb0d2934f85e0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code> contains a value.  <a href="#a1047a69893a62cd36eb0d2934f85e0e7">More...</a><br /></td></tr>
<tr class="separator:a1047a69893a62cd36eb0d2934f85e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb266d123883c23853f7731a6c5953f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a4eb266d123883c23853f7731a6c5953f">is_nothing</a></td></tr>
<tr class="memdesc:a4eb266d123883c23853f7731a6c5953f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code> is empty.  <a href="#a4eb266d123883c23853f7731a6c5953f">More...</a><br /></td></tr>
<tr class="separator:a4eb266d123883c23853f7731a6c5953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb98884a58d911687bf2aa64a411d623"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#afb98884a58d911687bf2aa64a411d623">from_maybe</a></td></tr>
<tr class="memdesc:afb98884a58d911687bf2aa64a411d623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code>, or a default value if the <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code> is <code>nothing</code>.  <a href="#afb98884a58d911687bf2aa64a411d623">More...</a><br /></td></tr>
<tr class="separator:afb98884a58d911687bf2aa64a411d623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebdc9b916940e038e6f2e3043e4f796"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a2ebdc9b916940e038e6f2e3043e4f796">from_just</a></td></tr>
<tr class="memdesc:a2ebdc9b916940e038e6f2e3043e4f796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the value out of a <code>just</code>, or trigger a compile-time error if the argument is <code>nothing</code>.  <a href="#a2ebdc9b916940e038e6f2e3043e4f796">More...</a><br /></td></tr>
<tr class="separator:a2ebdc9b916940e038e6f2e3043e4f796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a6529e11cb228e99a05e81071752807d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto maybe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> default_, <span class="keyword">auto</span> f, <span class="keyword">auto</span> m) {</div>
<div class="line">        <span class="keywordflow">return</span> m.maybe_impl(default_, f);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Applies a function to the contents of a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code>, with a fallback result. </p>
<p>Specifically, <code>maybe</code> takes a default value, a function and an optional value. If the optional value is <code>nothing</code>, the default value is returned. Otherwise, the function is applied to the content of the <code>just</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> inc = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x + 1; };</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__datatypes.html#a6529e11cb228e99a05e81071752807d5">maybe</a>(0, inc, <a class="code" href="group__datatypes.html#a8ad818d6df7379b0adefa45d2ac844d0">just</a>(1)) == 2);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__datatypes.html#a6529e11cb228e99a05e81071752807d5">maybe</a>(0, inc, <a class="code" href="group__datatypes.html#a2be2b3e89cab04d5f1e2b9edefdb2518">nothing</a>) == 0);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1047a69893a62cd36eb0d2934f85e0e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto is_just</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> m) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__datatypes.html#a6529e11cb228e99a05e81071752807d5">maybe</a>(false_, [](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> true_; }, m);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code> contains a value. </p>

</div>
</div>
<a class="anchor" id="a4eb266d123883c23853f7731a6c5953f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto is_nothing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> m) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__datatypes.html#a6529e11cb228e99a05e81071752807d5">maybe</a>(true_, [](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> false_; }, m);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code> is empty. </p>

</div>
</div>
<a class="anchor" id="afb98884a58d911687bf2aa64a411d623"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto from_maybe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> default_, <span class="keyword">auto</span> m) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__datatypes.html#a6529e11cb228e99a05e81071752807d5">maybe</a>(default_, [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x; }, m);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns the contents of a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code>, or a default value if the <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_maybe" title="Represents an optional value. ">Maybe</a></code> is <code>nothing</code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__datatypes.html#afb98884a58d911687bf2aa64a411d623">from_maybe</a>(0, <a class="code" href="group__datatypes.html#a8ad818d6df7379b0adefa45d2ac844d0">just</a>(1)) == 1);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__datatypes.html#afb98884a58d911687bf2aa64a411d623">from_maybe</a>(0, <a class="code" href="group__datatypes.html#a2be2b3e89cab04d5f1e2b9edefdb2518">nothing</a>) == 0);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2ebdc9b916940e038e6f2e3043e4f796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto from_just</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> m) {</div>
<div class="line">        <span class="keyword">auto</span> err = [](<span class="keyword">auto</span> ...dum) {</div>
<div class="line">            constexpr <span class="keywordtype">bool</span> always_false = <span class="keyword">sizeof</span>...(dum) != 0;</div>
<div class="line">            static_assert(always_false,</div>
<div class="line">            <span class="stringliteral">&quot;trying to extract the value inside a boost::hana::nothing &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;with boost::hana::from_just&quot;</span>);</div>
<div class="line">        };</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__datatypes.html#a6529e11cb228e99a05e81071752807d5">maybe</a>(err, [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> [=] { <span class="keywordflow">return</span> x; }; }, m)();</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Extract the value out of a <code>just</code>, or trigger a compile-time error if the argument is <code>nothing</code>. </p>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_bottom" id="structboost_1_1hana_1_1_bottom"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Bottom</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_bottom" title="The Bottom data type represents statically type-erased data. ">Bottom</a></code> data type represents statically type-erased data. </p>
</div>
</div>
</div>
<a name="structboost_1_1hana_1_1_integer_list" id="structboost_1_1hana_1_1_integer_list"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::IntegerList</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s of the same underlying type only. </p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integer_list" title="List containing Integrals of the same underlying type only. ">IntegerList</a></code> may be more efficient than <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> because of optimizations. When possible, it should be preferred. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac11fe3aa29fccdcad358f085a643b4be"><td class="memTemplParams" colspan="2">template&lt;typename T , T... xs&gt; </td></tr>
<tr class="memitem:ac11fe3aa29fccdcad358f085a643b4be"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
ilist_detail::integer_list&lt; T, <br class="typebreak" />
xs...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ac11fe3aa29fccdcad358f085a643b4be">integer_list</a> {}</td></tr>
<tr class="memdesc:ac11fe3aa29fccdcad358f085a643b4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a list containing the given <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s.  <a href="#ac11fe3aa29fccdcad358f085a643b4be">More...</a><br /></td></tr>
<tr class="separator:ac11fe3aa29fccdcad358f085a643b4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="ac11fe3aa29fccdcad358f085a643b4be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T... xs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ilist_detail::integer_list&lt;T, xs...&gt; integer_list {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a list containing the given <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s. </p>
<p>This is functionally equivalent to <code>list(integral&lt;T, xs&gt;...)</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(to&lt;List&gt;(integer_list&lt;int, 0, 1, 2&gt;) == list(int_&lt;0&gt;, int_&lt;1&gt;, int_&lt;2&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(head(integer_list&lt;int, 0, 1, 2&gt;) == int_&lt;0&gt;);</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_lazy" id="structboost_1_1hana_1_1_lazy"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Lazy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> data type implements superficial laziness via a monadic interface. </p>
<p>It is important to understand that the laziness implemented by <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> is only superficial; only function applications made inside the <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> monad can be made lazy, not all their subexpressions. </p><hr/>
<h2>Instance of</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code> and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code></p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> only instantiates a few type classes because providing more functionality would require evaluating the lazy values in most cases. Since this raises some issues such as side effects and memoization, the data type is kept simple. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a></td></tr>
<tr class="memdesc:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a lazy value and return it.  <a href="#aae2998c08f1f80ed52a6acf57c4eec6c">More...</a><br /></td></tr>
<tr class="separator:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e14285897797737683aa2a776a6e0e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a73e14285897797737683aa2a776a6e0e">lazy</a></td></tr>
<tr class="memdesc:a73e14285897797737683aa2a776a6e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts a normal value to a lazy one.  <a href="#a73e14285897797737683aa2a776a6e0e">More...</a><br /></td></tr>
<tr class="separator:a73e14285897797737683aa2a776a6e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="aae2998c08f1f80ed52a6acf57c4eec6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto eval</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> lx) {</div>
<div class="line">        <span class="keywordflow">return</span> lx.storage([](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x; });</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Evaluate a lazy value and return it. </p>

</div>
</div>
<a class="anchor" id="a73e14285897797737683aa2a776a6e0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto lazy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keyword">auto</span> storage = [=](<span class="keyword">auto</span> <a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>) { <span class="keywordflow">return</span> x; };</div>
<div class="line">        <span class="keywordflow">return</span> lazy_detail::lazy&lt;decltype(storage)&gt;{storage};</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Lifts a normal value to a lazy one. </p>
<p>Additionally, <code>lazy(f)</code> is a function such that <code>lazy(f)(x1, ..., xN)</code> is equivalent to <code>ap(lazy(f), lift&lt;<a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a>&gt;(x1), ..., lift&lt;<a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_lazy" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a>&gt;(xN))</code>, which in turn is equivalent to <code>lazy(f(x1, ..., xN))</code>, except for the fact that the inner call to <code>f</code> is evaluated lazily. Note that <code>lazy(f)()</code> is equivalent to <code>lazy(f())</code>, with the inner call to <code>f</code> being evaluated lazily. This is provided for convenience even though <code>ap(lazy(f))</code> would be invalid because <code>ap</code> requires 2 arguments or more.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = <a class="code" href="group__datatypes.html#a73e14285897797737683aa2a776a6e0e">lazy</a>([](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> 1 / x;</div>
<div class="line">    });</div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> g = <a class="code" href="group__datatypes.html#a73e14285897797737683aa2a776a6e0e">lazy</a>([](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x + 1;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__datatypes.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a>(if_(false_, f(0), g(0))) == 0 + 1);</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_list" id="structboost_1_1hana_1_1_list"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::List</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>General purpose index-based sequence. </p>
<hr/>
<h2>Instance of (as a data type)</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_iterable" title="Data structures allowing external iteration. ">Iterable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_foldable" title="Data structures that can be folded, i.e. summarized into a single value. ">Foldable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_traversable" title="Data structures that can be traversed from left to right. ">Traversable</a></code>, and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> </p><hr/>
<h2>Laws (as a type class)</h2>
<p>For any two <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code>s <code>x</code> and <code>y</code>, </p><p class="formulaDsp">
\begin{align*} x = y \iff \tt{to&lt;List&gt;(x)} = \tt{to&lt;List&gt;(y)} \end{align*}
</p>
<p> This is basically saying that all <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> instances are isomorphic, and it therefore makes sense to define comparison for any two <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code>s. </p><hr/>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd><ul>
<li>It might be possible to optimize the implementation of homogeneous lists using an array.</li>
<li>How to implement iterate and repeat?</li>
<li>We could provide automatic unit testing for any instance because we have the isomorphisms.</li>
<li>There is a strong relationship between this and <code>MonadPlus</code>. Actually, they might be just the same. Check this out.</li>
<li>Implement the following methods:<ul>
<li><code>intersperse</code>, <code>intercalate</code>, <code>transpose</code>, <code>subsequences</code></li>
<li><code>split_at</code>, <code>span</code>, <code>break</code>, <code>group_by</code>, <code>group</code>, <code>inits</code>, <code>tails</code></li>
</ul>
</li>
<li>Consider implementing the following methods:<ul>
<li><code>nub_by</code>, <code>nub</code>, <code>delete_by</code>, <code>insert</code></li>
<li><code>set_difference_by</code>, <code>set_union_by</code>, <code>set_intersection_by</code> </li>
</ul>
</li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a7d7c9b8e94dfcac46c7427a9b82e3225"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a></td></tr>
<tr class="memdesc:a7d7c9b8e94dfcac46c7427a9b82e3225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code>xs...</code>.  <a href="#a7d7c9b8e94dfcac46c7427a9b82e3225">More...</a><br /></td></tr>
<tr class="separator:a7d7c9b8e94dfcac46c7427a9b82e3225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a></td></tr>
<tr class="memdesc:a30a6926751dfcafbe2bb67738e2da3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two lists together.  <a href="#a30a6926751dfcafbe2bb67738e2da3c4">More...</a><br /></td></tr>
<tr class="separator:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51732ddadf982e47f5757b092294df12"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a></td></tr>
<tr class="memdesc:a51732ddadf982e47f5757b092294df12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to the head of a list.  <a href="#a51732ddadf982e47f5757b092294df12">More...</a><br /></td></tr>
<tr class="separator:a51732ddadf982e47f5757b092294df12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929370eddd43bb1a4a11b00a7880eadb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a></td></tr>
<tr class="memdesc:a929370eddd43bb1a4a11b00a7880eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list containing only the elements satisfying the <code>predicate</code>.  <a href="#a929370eddd43bb1a4a11b00a7880eadb">More...</a><br /></td></tr>
<tr class="separator:a929370eddd43bb1a4a11b00a7880eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733fdb2e8686033466beea8323e53a26"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a733fdb2e8686033466beea8323e53a26">init</a></td></tr>
<tr class="memdesc:a733fdb2e8686033466beea8323e53a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of a non-empty list.  <a href="#a733fdb2e8686033466beea8323e53a26">More...</a><br /></td></tr>
<tr class="separator:a733fdb2e8686033466beea8323e53a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28529f82a678e8814fe6224f626115f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28529f82a678e8814fe6224f626115f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr list_detail::into&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a28529f82a678e8814fe6224f626115f3">into</a></td></tr>
<tr class="memdesc:a28529f82a678e8814fe6224f626115f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> with the given elements in it.  <a href="#a28529f82a678e8814fe6224f626115f3">More...</a><br /></td></tr>
<tr class="separator:a28529f82a678e8814fe6224f626115f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e654b583265053e4dde63fff0c0aea"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04e654b583265053e4dde63fff0c0aea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04e654b583265053e4dde63fff0c0aea"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a04e654b583265053e4dde63fff0c0aea">nil</a></td></tr>
<tr class="memdesc:a04e654b583265053e4dde63fff0c0aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty list. <br /></td></tr>
<tr class="separator:a04e654b583265053e4dde63fff0c0aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b65dd69bb016d647801718e840816"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a788b65dd69bb016d647801718e840816">partition</a></td></tr>
<tr class="memdesc:a788b65dd69bb016d647801718e840816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a list based on a <code>predicate</code>.  <a href="#a788b65dd69bb016d647801718e840816">More...</a><br /></td></tr>
<tr class="separator:a788b65dd69bb016d647801718e840816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a></td></tr>
<tr class="memdesc:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all the permutations of the given list.  <a href="#a45ec7767d19eb7eaabb71ead3796a7f1">More...</a><br /></td></tr>
<tr class="separator:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4471413ccc3835db5e48658683b8aba0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a4471413ccc3835db5e48658683b8aba0">reverse</a></td></tr>
<tr class="memdesc:a4471413ccc3835db5e48658683b8aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a list.  <a href="#a4471413ccc3835db5e48658683b8aba0">More...</a><br /></td></tr>
<tr class="separator:a4471413ccc3835db5e48658683b8aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb039a3d46931ef17fef56c77d8256c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a></td></tr>
<tr class="memdesc:adfb039a3d46931ef17fef56c77d8256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldl</code>, but returns a list of reduced values from the left.  <a href="#adfb039a3d46931ef17fef56c77d8256c">More...</a><br /></td></tr>
<tr class="separator:adfb039a3d46931ef17fef56c77d8256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62411eb57e86f3cb7394f22fd3651355"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a></td></tr>
<tr class="memdesc:a62411eb57e86f3cb7394f22fd3651355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanl</code> that has no starting value argument.  <a href="#a62411eb57e86f3cb7394f22fd3651355">More...</a><br /></td></tr>
<tr class="separator:a62411eb57e86f3cb7394f22fd3651355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb725e66aedc0c19c38b38a00302abf4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a></td></tr>
<tr class="memdesc:abb725e66aedc0c19c38b38a00302abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldr</code>, but returns a list of reduced values from the right.  <a href="#abb725e66aedc0c19c38b38a00302abf4">More...</a><br /></td></tr>
<tr class="separator:abb725e66aedc0c19c38b38a00302abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5948df39fe904d509f1bb073d53e3965"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a></td></tr>
<tr class="memdesc:a5948df39fe904d509f1bb073d53e3965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanr</code> that has no starting value argument.  <a href="#a5948df39fe904d509f1bb073d53e3965">More...</a><br /></td></tr>
<tr class="separator:a5948df39fe904d509f1bb073d53e3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95183c155c6180b31d4965aa203957d0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a></td></tr>
<tr class="memdesc:a95183c155c6180b31d4965aa203957d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to the end of a list.  <a href="#a95183c155c6180b31d4965aa203957d0">More...</a><br /></td></tr>
<tr class="separator:a95183c155c6180b31d4965aa203957d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1454689bf6d2264bc428dc1d039db"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a58c1454689bf6d2264bc428dc1d039db">sort</a></td></tr>
<tr class="memdesc:a58c1454689bf6d2264bc428dc1d039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list based on the <code>less</code> strict weak ordering.  <a href="#a58c1454689bf6d2264bc428dc1d039db">More...</a><br /></td></tr>
<tr class="separator:a58c1454689bf6d2264bc428dc1d039db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a></td></tr>
<tr class="memdesc:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list based on the given <code>predicate</code>.  <a href="#a6ed2907b48fcba3dd1059b4b0bfde624">More...</a><br /></td></tr>
<tr class="separator:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20028c5115dcf38063d322f27b4ee1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a></td></tr>
<tr class="memdesc:a2c20028c5115dcf38063d322f27b4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first <code>n</code> elements of a list.  <a href="#a2c20028c5115dcf38063d322f27b4ee1">More...</a><br /></td></tr>
<tr class="separator:a2c20028c5115dcf38063d322f27b4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a></td></tr>
<tr class="memdesc:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements until the <code>predicate</code> is satisfied.  <a href="#a27aa67fa9ffc3d89b23a6dce018013d4">More...</a><br /></td></tr>
<tr class="separator:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86916c5c62a42f01f85450b366ef6eff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a></td></tr>
<tr class="memdesc:a86916c5c62a42f01f85450b366ef6eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements while the <code>predicate</code> is satisfied.  <a href="#a86916c5c62a42f01f85450b366ef6eff">More...</a><br /></td></tr>
<tr class="separator:a86916c5c62a42f01f85450b366ef6eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b66272057350060d1c00e00d726ac23"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a3b66272057350060d1c00e00d726ac23"><td class="memTemplItemLeft" align="right" valign="top">constexpr list_detail::unfoldl&lt; L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a3b66272057350060d1c00e00d726ac23">unfoldl</a></td></tr>
<tr class="memdesc:a3b66272057350060d1c00e00d726ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldl</code> for lists.  <a href="#a3b66272057350060d1c00e00d726ac23">More...</a><br /></td></tr>
<tr class="separator:a3b66272057350060d1c00e00d726ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9393472189e8d49e2bc8a9e7730b7b60"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a9393472189e8d49e2bc8a9e7730b7b60"><td class="memTemplItemLeft" align="right" valign="top">constexpr list_detail::unfoldr&lt; L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a9393472189e8d49e2bc8a9e7730b7b60">unfoldr</a></td></tr>
<tr class="memdesc:a9393472189e8d49e2bc8a9e7730b7b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldr</code> for lists.  <a href="#a9393472189e8d49e2bc8a9e7730b7b60">More...</a><br /></td></tr>
<tr class="separator:a9393472189e8d49e2bc8a9e7730b7b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5308d966fbf95d317511a706d6d20a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#abe5308d966fbf95d317511a706d6d20a">unzip</a></td></tr>
<tr class="memdesc:abe5308d966fbf95d317511a706d6d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzip a list of lists.  <a href="#abe5308d966fbf95d317511a706d6d20a">More...</a><br /></td></tr>
<tr class="separator:abe5308d966fbf95d317511a706d6d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a></td></tr>
<tr class="memdesc:a23b6ac9e78577d70b9108a80e6b1534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one list or more.  <a href="#a23b6ac9e78577d70b9108a80e6b1534c">More...</a><br /></td></tr>
<tr class="separator:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a></td></tr>
<tr class="memdesc:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one list or more with a given function.  <a href="#a5eadaf63535ebb8cdd8d9e4c16b9bacd">More...</a><br /></td></tr>
<tr class="separator:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a7d7c9b8e94dfcac46c7427a9b82e3225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto list</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> ...xs) {</div>
<div class="line">        <span class="keyword">auto</span> storage = [=](<span class="keyword">auto</span> f) { <span class="keywordflow">return</span> f(xs...); };</div>
<div class="line">        <span class="keywordflow">return</span> list_detail::list&lt;decltype(storage)&gt;{storage};</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code>xs...</code>. </p>
<p>The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> data type is a general purpose compile-time heterogeneous sequence.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Consider having <code>list_of&lt;<a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a>&gt;</code>, <code>list_of&lt;<a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a>&gt;</code>, ..., <code>list_of&lt;Anything&gt;</code>, with <code>list == list_of&lt;Anything&gt;</code>. It does not fix the problem of partial type classes (e.g. <code>MplVector</code> is not <em>actually</em> a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code>), but at least we remove <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type_list" title="List containing Types only. ">TypeList</a></code> and <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integer_list" title="List containing Integrals of the same underlying type only. ">IntegerList</a></code>, which are arguably ugly. </dd></dl>

</div>
</div>
<a class="anchor" id="a30a6926751dfcafbe2bb67738e2da3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto concat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate two lists together. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, 4_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a51732ddadf982e47f5757b092294df12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cons</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend an element to the head of a list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>()) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, <a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(<span class="charliteral">&#39;2&#39;</span>, <a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(<span class="stringliteral">&quot;3&quot;</span>, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>()))) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a929370eddd43bb1a4a11b00a7880eadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list containing only the elements satisfying the <code>predicate</code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(trait_&lt;std::is_integral&gt;, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2.0, 3, 4.0)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a733fdb2e8686033466beea8323e53a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of a non-empty list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a733fdb2e8686033466beea8323e53a26">init</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>());</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a733fdb2e8686033466beea8323e53a26">init</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>, 4_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a28529f82a678e8814fe6224f626115f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr list_detail::into&lt;T&gt; into</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> with the given elements in it. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(unpack(into&lt;List&gt;, just(3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(unpack(into&lt;List&gt;, nothing) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>());</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(unpack(into&lt;List&gt;, std::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a788b65dd69bb016d647801718e840816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition a list based on a <code>predicate</code>. </p>
<p>Specifically, returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> whose first element is a list of the elements satisfying the predicate, and whose second element is a list of the elements that do not satisfy the predicate.</p>
<dl class="section note"><dt>Note</dt><dd>The predicate must return an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>.</dd></dl>
<h3>Example 1</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % int_&lt;2&gt; != int_&lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a788b65dd69bb016d647801718e840816">partition</a>(odd, integer_list&lt;int, 1, 2, 3, 4, 5, 6, 7&gt;)</div>
<div class="line">        ==</div>
<div class="line">        pair(</div>
<div class="line">            integer_list&lt;int, 1, 3, 5, 7&gt;,</div>
<div class="line">            integer_list&lt;int, 2, 4, 6&gt;</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment --> <h3>Example 2</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a788b65dd69bb016d647801718e840816">partition</a>(trait&lt;std::is_floating_point&gt;, type_list&lt;void, int, float, char, double&gt;)</div>
<div class="line">        ==</div>
<div class="line">        pair(</div>
<div class="line">            type_list&lt;float, double&gt;,</div>
<div class="line">            type_list&lt;void, int, char&gt;</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45ec7767d19eb7eaabb71ead3796a7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto permutations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of all the permutations of the given list. </p>
<p>The permutations are not guaranteed to be in any specific order.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> is_permutation_of = curry&lt;2&gt;([](<span class="keyword">auto</span> xs, <span class="keyword">auto</span> perm) {</div>
<div class="line">        <span class="keywordflow">return</span> any(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> == perm, <a class="code" href="group__typeclasses.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a>(xs));</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        all(is_permutation_of(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0)),</div>
<div class="line">            <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;1&#39;</span>, 3.0, 2),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, <span class="charliteral">&#39;1&#39;</span>, 3.0),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, 3.0, <span class="charliteral">&#39;1&#39;</span>),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.0, <span class="charliteral">&#39;1&#39;</span>, 2),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.0, 2, <span class="charliteral">&#39;1&#39;</span>)</div>
<div class="line">            )</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.permutations.time.png" alt="benchmark.list.permutations.time.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>Implementation taken from <a href="http://stackoverflow.com/a/2184129/627587">http://stackoverflow.com/a/2184129/627587</a>.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>We got a performance problem here. Generating the permutations of a list of more than 3 elements starts taking a long time (&gt;6s). </dd></dl>

</div>
</div>
<a class="anchor" id="a4471413ccc3835db5e48658683b8aba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse a list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a4471413ccc3835db5e48658683b8aba0">reverse</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, <span class="charliteral">&#39;2&#39;</span>, 1));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adfb039a3d46931ef17fef56c77d8256c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>foldl</code>, but returns a list of reduced values from the left. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a>(show, 1, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        1,</div>
<div class="line">        <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(((1 + 2) + 3) + 4)&quot;</span></div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanl.time.png" alt="benchmark.list.scanl.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a62411eb57e86f3cb7394f22fd3651355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <code>scanl</code> that has no starting value argument. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a>(show, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        1,</div>
<div class="line">        <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span></div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanl1.time.png" alt="benchmark.list.scanl1.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="abb725e66aedc0c19c38b38a00302abf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>foldr</code>, but returns a list of reduced values from the right. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a>(show, 4, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        <span class="stringliteral">&quot;(1 + (2 + (3 + 4)))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(2 + (3 + 4))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(3 + 4)&quot;</span>,</div>
<div class="line">        4</div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanr.time.png" alt="benchmark.list.scanr.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a5948df39fe904d509f1bb073d53e3965"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <code>scanr</code> that has no starting value argument. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a>(show, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        <span class="stringliteral">&quot;(1 + (2 + 3))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(2 + 3)&quot;</span>,</div>
<div class="line">        <span class="charliteral">&#39;3&#39;</span></div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanr1.time.png" alt="benchmark.list.scanr1.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a95183c155c6180b31d4965aa203957d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto snoc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an element to the end of a list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(), 1) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>), 3.3) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(), 1), <span class="charliteral">&#39;2&#39;</span>), 3.3) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a58c1454689bf6d2264bc428dc1d039db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a list based on the <code>less</code> strict weak ordering. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1_c, -2_c, 3_c, 0_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(-2_c, 0_c, 1_c, 3_c)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ed2907b48fcba3dd1059b4b0bfde624"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a list based on the given <code>predicate</code>. </p>
<p>The predicate must be a <a href="http://en.wikipedia.org/wiki/Strict_weak_ordering#Strict_weak_orderings">strict weak ordering</a>. The sort is guaranteed to be stable.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>&gt;<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1_c, -2_c, 3_c, 0_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3_c, 1_c, 0_c, -2_c)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c20028c5115dcf38063d322f27b4ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first <code>n</code> elements of a list. </p>
<p><code>n</code> must be a non-negative <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> representing the number of elements to keep. If <code>n</code> is greater than the length of the list, the whole list is returned.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(0_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>());</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(1_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(2_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(3_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(4_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27aa67fa9ffc3d89b23a6dce018013d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_until</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take elements until the <code>predicate</code> is satisfied. </p>
<p>This is equivalent to <code>take_while</code> with a negated predicate.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> &lt; 2_c, integer_list&lt;int, 3, 2, 1, 0&gt;) == integer_list&lt;int, 3, 2&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a86916c5c62a42f01f85450b366ef6eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_while</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take elements while the <code>predicate</code> is satisfied. </p>
<p>Specifically, returns the longest prefix of a list in which all elements satisfy the given predicate. The predicate must return an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> &lt; 2_c, integer_list&lt;int, 0, 1, 2, 3&gt;) == integer_list&lt;int, 0, 1&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3b66272057350060d1c00e00d726ac23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr list_detail::unfoldl&lt;L&gt; unfoldl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dual to <code>foldl</code> for lists. </p>
<p>While <code>foldl</code> reduces a list to a summary value, <code>unfoldl</code> builds a list from a seed value and a function. The function takes the initial value and returns <code>nothing</code> if it is done producing the list, and <code>just(P(init, elem))</code> otherwise, where <code>P</code> is an arbitrary <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> constructor and <code>elem</code> is the produced element which is appended to the list and <code>init</code> is the new initial value used in a recursive call to the function.</p>
<p>In some cases, <code>unfoldl</code> can undo a <code>foldl</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="group__typeclasses.html#a3b66272057350060d1c00e00d726ac23">unfoldl</a>(g, foldl(f, z, xs))</div>
</div><!-- fragment --><p> if the following holds </p><div class="fragment"><div class="line">g(f(y, x)) == just(pair(y, x))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x - int_&lt;1&gt;, x)));</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        unfoldl&lt;IntegerList&gt;(f, int_&lt;10&gt;) == integer_list&lt;int, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9393472189e8d49e2bc8a9e7730b7b60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr list_detail::unfoldr&lt;L&gt; unfoldr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dual to <code>foldr</code> for lists. </p>
<p>While <code>foldr</code> reduces a list to a summary value, <code>unfoldr</code> builds a list from a seed value and a function. The function takes the initial value and returns <code>nothing</code> if it is done producing the list, and <code>just(P(elem, init))</code> otherwise, where <code>P</code> is an arbitrary <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> constructor and <code>elem</code> is the produced element which is prepended to the list and <code>init</code> is the new initial value used in a recursive call to the function.</p>
<p>In some cases, <code>unfoldr</code> can undo a <code>foldr</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="group__typeclasses.html#a9393472189e8d49e2bc8a9e7730b7b60">unfoldr</a>(g, foldr(f, z, xs))</div>
</div><!-- fragment --><p> if the following holds </p><div class="fragment"><div class="line">g(f(x, y)) == just(pair(x, y))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x, x - int_&lt;1&gt;)));</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        unfoldr&lt;IntegerList&gt;(f, int_&lt;10&gt;) == integer_list&lt;int, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe5308d966fbf95d317511a706d6d20a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unzip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unzip a list of lists. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6)))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;4&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;2&#39;</span>, 5.5), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, 6))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6, <span class="stringliteral">&quot;ignored&quot;</span>)))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;4&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;2&#39;</span>, 5.5), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, 6))</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23b6ac9e78577d70b9108a80e6b1534c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip one list or more. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;a&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, 3.3))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;a&#39;</span>, 3.3))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;a&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, 3.3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2, 3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;a&#39;</span>, 3.3, <span class="charliteral">&#39;c&#39;</span>))</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5eadaf63535ebb8cdd8d9e4c16b9bacd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip_with</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip one list or more with a given function. </p>
<p>Specifically, returns a list whose i-th element is <code>f(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the i-th element of the k-th list passed as an argument. The returned list stops when the shortest input sequence is exhausted.</p>
<p>In other words, <code>zip_with(f, s1, ..., sn)</code> is a list of the form </p><div class="fragment"><div class="line">f(s1[0], ..., sn[0])</div>
<div class="line">f(s1[1], ..., sn[1])</div>
<div class="line">...</div>
<div class="line">f(s1[k], ..., sn[k])</div>
</div><!-- fragment --><p> where <code>k</code> is the length of the shortest list.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> * <a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2, 3, 4), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(5, 6, 7, 8, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(5, 12, 21, 32)</div>
<div class="line">    );</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd><ul>
<li>Consider allowing only two lists and achieving the variadic behavior in some other way. This would make it possible to automatically curry <code>zip_with</code>. It might be possible to achieve the variadic behavior with e.g. <a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a> Functors? </li>
</ul>
</dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_map" id="structboost_1_1hana_1_1_map"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Map</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A basic associative array requiring unique and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> keys. </p>
<p>The order of the elements of the map is unspecified. Also, all the keys must be comparable with each other and that comparison must yield a boolean <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a56ec5fd28fa8659b89fc526c89bdea6b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a56ec5fd28fa8659b89fc526c89bdea6b">map</a></td></tr>
<tr class="memdesc:a56ec5fd28fa8659b89fc526c89bdea6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_map" title="A basic associative array requiring unique and Comparable keys. ">Map</a></code> with the given key/value associations.  <a href="#a56ec5fd28fa8659b89fc526c89bdea6b">More...</a><br /></td></tr>
<tr class="separator:a56ec5fd28fa8659b89fc526c89bdea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f32260f859b2510dd16235b7bc011ac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a0f32260f859b2510dd16235b7bc011ac">keys</a></td></tr>
<tr class="memdesc:a0f32260f859b2510dd16235b7bc011ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the keys of the map, in unspecified order.  <a href="#a0f32260f859b2510dd16235b7bc011ac">More...</a><br /></td></tr>
<tr class="separator:a0f32260f859b2510dd16235b7bc011ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e016a68e3ec6eb25868fadb7ce80132"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a2e016a68e3ec6eb25868fadb7ce80132">values</a></td></tr>
<tr class="memdesc:a2e016a68e3ec6eb25868fadb7ce80132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the values of the map, in unspecified order.  <a href="#a2e016a68e3ec6eb25868fadb7ce80132">More...</a><br /></td></tr>
<tr class="separator:a2e016a68e3ec6eb25868fadb7ce80132"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a56ec5fd28fa8659b89fc526c89bdea6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> ...pairs) {</div>
<div class="line">        <span class="keywordflow">return</span> detail::wrap&lt;Map&gt;(list(pairs...));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Creates a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_map" title="A basic associative array requiring unique and Comparable keys. ">Map</a></code> with the given key/value associations. </p>
<dl class="section note"><dt>Note</dt><dd>The keys must all be unique. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f32260f859b2510dd16235b7bc011ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto keys</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <a class="code" href="group__datatypes.html#a56ec5fd28fa8659b89fc526c89bdea6b">map</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> fmap(first, detail::unwrap(<a class="code" href="group__datatypes.html#a56ec5fd28fa8659b89fc526c89bdea6b">map</a>));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a list of the keys of the map, in unspecified order. </p>

</div>
</div>
<a class="anchor" id="a2e016a68e3ec6eb25868fadb7ce80132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <a class="code" href="group__datatypes.html#a56ec5fd28fa8659b89fc526c89bdea6b">map</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> fmap(second, detail::unwrap(<a class="code" href="group__datatypes.html#a56ec5fd28fa8659b89fc526c89bdea6b">map</a>));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a list of the values of the map, in unspecified order. </p>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_pair" id="structboost_1_1hana_1_1_pair"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Pair</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Generic container of two elements. </p>
<p>As a type class, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> represents a container of two elements with means to extract each of them separately. Since the instance for <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> is unique up to isomorphism, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> is also a data type instantiating the <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> type class with the only possible instance up to isomorphism.</p>
<h2>Provided instances</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> </p><hr/>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>Provide and document instances for <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code> and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_foldable" title="Data structures that can be folded, i.e. summarized into a single value. ">Foldable</a></code>. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8d15743bd0fcc2cf033ed657e95998c1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a8d15743bd0fcc2cf033ed657e95998c1">pair</a></td></tr>
<tr class="memdesc:a8d15743bd0fcc2cf033ed657e95998c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> with the given elements.  <a href="#a8d15743bd0fcc2cf033ed657e95998c1">More...</a><br /></td></tr>
<tr class="separator:a8d15743bd0fcc2cf033ed657e95998c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6548bd227a06799a2e5abdfd9e9b0b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6548bd227a06799a2e5abdfd9e9b0b9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a></td></tr>
<tr class="memdesc:ab6548bd227a06799a2e5abdfd9e9b0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element of the pair. <br /></td></tr>
<tr class="separator:ab6548bd227a06799a2e5abdfd9e9b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2111e165329a8ded67dec73f2df4ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d2111e165329a8ded67dec73f2df4ae"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a></td></tr>
<tr class="memdesc:a5d2111e165329a8ded67dec73f2df4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second element of the pair. <br /></td></tr>
<tr class="separator:a5d2111e165329a8ded67dec73f2df4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a8d15743bd0fcc2cf033ed657e95998c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pair</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <a class="code" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a>, <span class="keyword">auto</span> <a class="code" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> pair_detail::pair&lt;</div>
<div class="line">            decltype(<a class="code" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a>), decltype(<a class="code" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a>)</div>
<div class="line">        &gt;{<a class="code" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a>, <a class="code" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a>};</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> with the given elements. </p>
<p>} </p>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_range" id="structboost_1_1hana_1_1_range"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Range</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Compile-time half-open interval of <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s. </p>
<h2>Instance of</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_iterable" title="Data structures allowing external iteration. ">Iterable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_foldable" title="Data structures that can be folded, i.e. summarized into a single value. ">Foldable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac3b5f08f5a346605377cf5fa9c4fb973"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ac3b5f08f5a346605377cf5fa9c4fb973">range</a></td></tr>
<tr class="memdesc:ac3b5f08f5a346605377cf5fa9c4fb973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_range" title="Compile-time half-open interval of Integrals. ">Range</a></code> containing the <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s in <code>[from, to)</code>.  <a href="#ac3b5f08f5a346605377cf5fa9c4fb973">More...</a><br /></td></tr>
<tr class="separator:ac3b5f08f5a346605377cf5fa9c4fb973"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="ac3b5f08f5a346605377cf5fa9c4fb973"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_range" title="Compile-time half-open interval of Integrals. ">Range</a></code> containing the <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s in <code>[from, to)</code>. </p>
<p><code>from</code> and <code>to</code> must be <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>s such that <code>from &lt;= to</code>. Otherwise, a compilation error is triggered.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(head(<a class="code" href="group__datatypes.html#ac3b5f08f5a346605377cf5fa9c4fb973">range</a>(0_c, 5_c)) == 0_c);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(last(<a class="code" href="group__datatypes.html#ac3b5f08f5a346605377cf5fa9c4fb973">range</a>(0_c, 5_c)) == 4_c);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(tail(<a class="code" href="group__datatypes.html#ac3b5f08f5a346605377cf5fa9c4fb973">range</a>(0_c, 5_c)) == <a class="code" href="group__datatypes.html#ac3b5f08f5a346605377cf5fa9c4fb973">range</a>(1_c, 5_c));</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_set" id="structboost_1_1hana_1_1_set"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Set</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A basic unordered container requiring <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> elements. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a7c6caacd6df4a89e8b62b369007d9602"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a7c6caacd6df4a89e8b62b369007d9602">set</a></td></tr>
<tr class="memdesc:a7c6caacd6df4a89e8b62b369007d9602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_set" title="A basic unordered container requiring Comparable elements. ">Set</a></code> containing the given elements.  <a href="#a7c6caacd6df4a89e8b62b369007d9602">More...</a><br /></td></tr>
<tr class="separator:a7c6caacd6df4a89e8b62b369007d9602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a7c6caacd6df4a89e8b62b369007d9602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> ...elements) {</div>
<div class="line">        <span class="keywordflow">return</span> detail::wrap&lt;Set&gt;(list(elements...));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Creates a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_set" title="A basic unordered container requiring Comparable elements. ">Set</a></code> containing the given elements. </p>
<dl class="section note"><dt>Note</dt><dd>There must not be duplicate elements. </dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_type" id="structboost_1_1hana_1_1_type"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>C++ type represented as a constexpr object. </p>
<h2>Instance of</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd><ul>
<li>Completely figure out and document the category theoretical foundation of this data type.</li>
<li>Consider instantiating <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code> and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code> if that's possible.</li>
<li>Consider having a <code>.name()</code> method that would return the (demangled?) <code>typeid(T).name()</code>.</li>
<li>Use more lambdas once <a href="http://llvm.org/bugs/show_bug.cgi?id=20046">http://llvm.org/bugs/show_bug.cgi?id=20046</a> is fixed. </li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab66de88586706cb474453dd937d13f8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab66de88586706cb474453dd937d13f8c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
type_detail::make_type&lt; T &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a></td></tr>
<tr class="memdesc:ab66de88586706cb474453dd937d13f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object representing the C++ type <code>T</code>.  <a href="#ab66de88586706cb474453dd937d13f8c">More...</a><br /></td></tr>
<tr class="separator:ab66de88586706cb474453dd937d13f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f30da3c8d927156d17ec09b8a2a4de"><td class="memItemLeft" align="right" valign="top">constexpr type_detail::decltype_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a81f30da3c8d927156d17ec09b8a2a4de">decltype_</a> {}</td></tr>
<tr class="memdesc:a81f30da3c8d927156d17ec09b8a2a4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of an object as a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>.  <a href="#a81f30da3c8d927156d17ec09b8a2a4de">More...</a><br /></td></tr>
<tr class="separator:a81f30da3c8d927156d17ec09b8a2a4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5286be1cfdaca72680089a7d15a5c14c"><td class="memItemLeft" align="right" valign="top">constexpr type_detail::sizeof_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a5286be1cfdaca72680089a7d15a5c14c">sizeof_</a> {}</td></tr>
<tr class="memdesc:a5286be1cfdaca72680089a7d15a5c14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the C++ type represented by a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>.  <a href="#a5286be1cfdaca72680089a7d15a5c14c">More...</a><br /></td></tr>
<tr class="separator:a5286be1cfdaca72680089a7d15a5c14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503dafb950079297ba2ec206ed8d5c36"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class f&gt; </td></tr>
<tr class="memitem:a503dafb950079297ba2ec206ed8d5c36"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
type_detail::template_&lt; f &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a503dafb950079297ba2ec206ed8d5c36">template_</a> {}</td></tr>
<tr class="memdesc:a503dafb950079297ba2ec206ed8d5c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift a template to a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s.  <a href="#a503dafb950079297ba2ec206ed8d5c36">More...</a><br /></td></tr>
<tr class="separator:a503dafb950079297ba2ec206ed8d5c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bfabe7d39900f3ac536b008ef2ad39"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class f&gt; </td></tr>
<tr class="memitem:ae9bfabe7d39900f3ac536b008ef2ad39"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
type_detail::metafunction&lt; f &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#ae9bfabe7d39900f3ac536b008ef2ad39">metafunction</a> {}</td></tr>
<tr class="memdesc:ae9bfabe7d39900f3ac536b008ef2ad39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift a metafunction to a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s.  <a href="#ae9bfabe7d39900f3ac536b008ef2ad39">More...</a><br /></td></tr>
<tr class="separator:ae9bfabe7d39900f3ac536b008ef2ad39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58734f5a67f0a7bfbc5351896934610b"><td class="memTemplParams" colspan="2">template&lt;typename f &gt; </td></tr>
<tr class="memitem:a58734f5a67f0a7bfbc5351896934610b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
type_detail::metafunction_class<br class="typebreak" />
&lt; f &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a58734f5a67f0a7bfbc5351896934610b">metafunction_class</a> {}</td></tr>
<tr class="memdesc:a58734f5a67f0a7bfbc5351896934610b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift a metafunction class to a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s.  <a href="#a58734f5a67f0a7bfbc5351896934610b">More...</a><br /></td></tr>
<tr class="separator:a58734f5a67f0a7bfbc5351896934610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4f287f903e6a0a75e53b86da1cbae8"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class f&gt; </td></tr>
<tr class="memitem:acf4f287f903e6a0a75e53b86da1cbae8"><td class="memTemplItemLeft" align="right" valign="top">constexpr type_detail::trait&lt; f &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#acf4f287f903e6a0a75e53b86da1cbae8">trait</a> {}</td></tr>
<tr class="memdesc:acf4f287f903e6a0a75e53b86da1cbae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift a metafunction to a function taking <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s and returning a default-constructed object.  <a href="#acf4f287f903e6a0a75e53b86da1cbae8">More...</a><br /></td></tr>
<tr class="separator:acf4f287f903e6a0a75e53b86da1cbae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5157ade103ca188ea16e378e2d528fb7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class f&gt; </td></tr>
<tr class="memitem:a5157ade103ca188ea16e378e2d528fb7"><td class="memTemplItemLeft" align="right" valign="top">constexpr type_detail::trait_&lt; f &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#a5157ade103ca188ea16e378e2d528fb7">trait_</a> {}</td></tr>
<tr class="memdesc:a5157ade103ca188ea16e378e2d528fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>compose(trait&lt;f&gt;, decltype_)</code>; provided for convenience.  <a href="#a5157ade103ca188ea16e378e2d528fb7">More...</a><br /></td></tr>
<tr class="separator:a5157ade103ca188ea16e378e2d528fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="ab66de88586706cb474453dd937d13f8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::make_type&lt;T&gt;::type type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object representing the C++ type <code>T</code>. </p>
<p><code>type&lt;T&gt;</code> is a function returning an object of type <code>T</code> constructed with the arguments passed to it: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> age;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator==(Person x, Person y)</div>
<div class="line">{ <span class="keywordflow">return</span> x.name == y.name &amp;&amp; x.age == y.age; }</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John Doe&quot;</span>, 30};</div>
<div class="line">    assert(type&lt;Person&gt;(<span class="stringliteral">&quot;John Doe&quot;</span>, 30u) == john);</div>
<div class="line">}</div>
</div><!-- fragment --><p> To use an initializer list, one should construct it explicitly: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; v{1, 2, 3};</div>
<div class="line">    <span class="keyword">auto</span> u = type&lt;std::vector&lt;int&gt;&gt;(std::initializer_list&lt;int&gt;{1, 2, 3});</div>
<div class="line">    assert(u == v);</div>
</div><!-- fragment --><p> <code>decltype(type&lt;T&gt;)</code> also has a nested alias to <code>T</code> named <code>type</code>. Hence, it can be used as a metafunction returning <code>T</code>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keyword">using</span> largest = decltype(maximum_by(<a class="code" href="group___functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>&lt;<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>, <a class="code" href="group__datatypes.html#a5286be1cfdaca72680089a7d15a5c14c">sizeof_</a>), type_list&lt;T...&gt;));</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> size&gt;</div>
<div class="line"><span class="keyword">struct </span>storage { <span class="keywordtype">char</span> s[size]; };</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    largest&lt;storage&lt;1&gt;, storage&lt;2&gt;, storage&lt;3&gt;&gt;::<a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>,</div>
<div class="line">    storage&lt;3&gt;</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a81f30da3c8d927156d17ec09b8a2a4de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::decltype_ decltype_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of an object as a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">struct </span>X { };</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(type&lt;X&gt; == <a class="code" href="group__datatypes.html#a81f30da3c8d927156d17ec09b8a2a4de">decltype_</a>(X{}));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(type&lt;int&gt; == <a class="code" href="group__datatypes.html#a81f30da3c8d927156d17ec09b8a2a4de">decltype_</a>(1));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5286be1cfdaca72680089a7d15a5c14c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::sizeof_ sizeof_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the C++ type represented by a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">struct </span>X { };</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__datatypes.html#a5286be1cfdaca72680089a7d15a5c14c">sizeof_</a>(type&lt;X&gt;) == <span class="keyword">sizeof</span>(X));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__datatypes.html#a5286be1cfdaca72680089a7d15a5c14c">sizeof_</a>(type&lt;int&gt;) == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>Should we also support non-<code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s? That could definitely be useful. </dd></dl>

</div>
</div>
<a class="anchor" id="a503dafb950079297ba2ec206ed8d5c36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::template_&lt;f&gt; template_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lift a template to a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s. </p>
<p>Specifically, <code>template_&lt;f&gt;</code> is a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s satisfying </p><div class="fragment"><div class="line">template_&lt;f&gt;(type&lt;x1&gt;, ..., type&lt;xN&gt;) == <a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>&lt;f&lt;x1, ..., xN&gt;&gt;</div>
</div><!-- fragment --><p><code>decltype(template_&lt;f&gt;)</code> is also a metafunction class such that </p><div class="fragment"><div class="line">decltype(template_&lt;f&gt;)::<a class="code" href="group___functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>&lt;x1, ..., xN&gt;::<a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a> == f&lt;x1, ..., xN&gt;</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt; <span class="keyword">struct </span>f;</div>
<div class="line"><span class="keyword">struct </span>x;</div>
<div class="line"><span class="keyword">struct </span>y;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(template_&lt;f&gt;() == <a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>&lt;f&lt;&gt;&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(template_&lt;f&gt;(type&lt;x&gt;) == <a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>&lt;f&lt;x&gt;&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(template_&lt;f&gt;(type&lt;x&gt;, type&lt;y&gt;) == <a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>&lt;f&lt;x, y&gt;&gt;);</div>
<div class="line"></div>
<div class="line">    static_assert(std::is_same&lt;</div>
<div class="line">        decltype(template_&lt;f&gt;)::apply&lt;x, y&gt;::type,</div>
<div class="line">        f&lt;x, y&gt;</div>
<div class="line">    &gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae9bfabe7d39900f3ac536b008ef2ad39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::metafunction&lt;f&gt; metafunction {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lift a metafunction to a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s. </p>
<p>Specifically, <code>metafunction&lt;f&gt;</code> is a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s satisfying </p><div class="fragment"><div class="line">metafunction&lt;f&gt;(type&lt;x1&gt;, ..., type&lt;xN&gt;) == <a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>&lt;f&lt;x1, ..., xN&gt;::type&gt;</div>
</div><!-- fragment --><p><code>decltype(metafunction&lt;f&gt;)</code> is also a metafunction class such that </p><div class="fragment"><div class="line">decltype(metafunction&lt;f&gt;)::<a class="code" href="group___functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>&lt;x1, ..., xN&gt; == f&lt;x1, ..., xN&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a58734f5a67f0a7bfbc5351896934610b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename f &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::metafunction_class&lt;f&gt; metafunction_class {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lift a metafunction class to a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s. </p>
<p>Specifically, <code>metafunction_class&lt;f&gt;</code> is a function on <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s satisfying </p><div class="fragment"><div class="line">metafunction_class&lt;f&gt;(type&lt;x1&gt;, ..., type&lt;xN&gt;) == <a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>&lt;f::apply&lt;x1, ..., xN&gt;::type&gt;</div>
</div><!-- fragment --><p><code>decltype(metafunction_class&lt;f&gt;)</code> is also a metafunction class such that </p><div class="fragment"><div class="line">decltype(metafunction_class&lt;f&gt;)::<a class="code" href="group___functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>&lt;x1, ..., xN&gt; == f::<a class="code" href="group___functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>&lt;x1, ..., xN&gt;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acf4f287f903e6a0a75e53b86da1cbae8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::trait&lt;f&gt; trait {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lift a metafunction to a function taking <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s and returning a default-constructed object. </p>
<p>Specifically, <code>trait&lt;f&gt;(t...)</code> is equivalent to <code>template_&lt;f&gt;(t...)()</code>. The principal use case for <code>trait</code> is to transform metafunctions inheriting from a meaningful base like <code>std::integral_constant</code> into functions returning e.g. an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>.</p>
<p>The word <code>trait</code> is used because a name was needed and the principal use case involves metafunctions from the standard that we also call type traits.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(trait&lt;std::is_integral&gt;(type&lt;int&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!trait&lt;std::is_integral&gt;(type&lt;float&gt;));</div>
</div><!-- fragment --><p> Note that not all metafunctions of the standard library can be lifted this way. For example, <code>std::aligned_storage</code> can't be lifted because it requires non-type template parameters. Since there is no uniform way of dealing with non-type template parameters, one must resort to using e.g. an inline lambda to "lift" those metafunctions. In practice, however, this should not be a problem.</p>
<h3>Example of a non-liftable metafunction</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> extent = [](<span class="keyword">auto</span> t, <span class="keyword">auto</span> n) {</div>
<div class="line">        <span class="keywordflow">return</span> std::extent&lt;typename decltype(t)::type, n()&gt;{};</div>
<div class="line">    };</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(extent(type&lt;char&gt;, int_&lt;1&gt;) == int_&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(extent(<a class="code" href="group__datatypes.html#ab66de88586706cb474453dd937d13f8c">type</a>&lt;<span class="keywordtype">char</span>[1][2]&gt;, int_&lt;1&gt;) == int_&lt;2&gt;);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>When using <code>trait</code> with metafunctions returning <code>std::integral_constant</code>s, don't forget to include the boost/hana/ext/std/integral_constant.hpp header!</dd>
<dd>
Since <code>trait&lt;f&gt;</code> does not return a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>, it does not really make sense to make <code>decltype(trait&lt;f&gt;)</code> a metafunction class, which explains the omission. </dd></dl>

</div>
</div>
<a class="anchor" id="a5157ade103ca188ea16e378e2d528fb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr type_detail::trait_&lt;f&gt; trait_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>compose(trait&lt;f&gt;, decltype_)</code>; provided for convenience. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(trait_&lt;std::is_integral&gt;(2));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(trait_&lt;std::is_integral&gt;(2ll));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!trait_&lt;std::is_integral&gt;(2.2));</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Since <code>trait_&lt;f&gt;</code> does not return a <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>, it does not really make sense to make <code>decltype(trait_&lt;f&gt;)</code> a metafunction class, which explains the omission. </dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_type_list" id="structboost_1_1hana_1_1_type_list"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::TypeList</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s only. </p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type_list" title="List containing Types only. ">TypeList</a></code> may be more efficient than <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> because of optimizations. When possible, it should be preferred.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd><ul>
<li>Efficient membership testing is possible.</li>
<li><code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type_list" title="List containing Types only. ">TypeList</a></code> is not really a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code> because the function must map from <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s to <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s. Should it be modified so that <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type_list" title="List containing Types only. ">TypeList</a></code> becomes <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> if we try to store something else than <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a></code>s? The same issue goes for <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integer_list" title="List containing Integrals of the same underlying type only. ">IntegerList</a></code>. </li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:acfe56da5da5e9e8ed2c3d47197ab754e"><td class="memTemplParams" colspan="2">template&lt;typename... xs&gt; </td></tr>
<tr class="memitem:acfe56da5da5e9e8ed2c3d47197ab754e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
tlist_detail::type_list&lt; xs...&gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__datatypes.html#acfe56da5da5e9e8ed2c3d47197ab754e">type_list</a> {}</td></tr>
<tr class="memdesc:acfe56da5da5e9e8ed2c3d47197ab754e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a list containing the given types.  <a href="#acfe56da5da5e9e8ed2c3d47197ab754e">More...</a><br /></td></tr>
<tr class="separator:acfe56da5da5e9e8ed2c3d47197ab754e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="acfe56da5da5e9e8ed2c3d47197ab754e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... xs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr tlist_detail::type_list&lt;xs...&gt;::type type_list {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a list containing the given types. </p>
<p>This is functionally equivalent to <code>list(type&lt;xs&gt;...)</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(to&lt;List&gt;(type_list&lt;void, int, float&gt;) == list(type&lt;void&gt;, type&lt;int&gt;, type&lt;float&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(head(type_list&lt;void, int, float&gt;) == type&lt;void&gt;);</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
