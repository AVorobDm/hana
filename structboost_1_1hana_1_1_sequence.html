<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Sequence Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_sequence.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_sequence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Sequence Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> concept represents generic index-based sequences. </p>
<p>The <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> concept is very specific. It represents generic index-based sequences. The reason why such a specific concept is provided is because there are a lot of models that behave exactly the same while being implemented in wildly different ways. It is useful to regroup all those data types under the same umbrella for the purpose of generic programming.</p>
<p>In fact, models of this concept are not only <em>similar</em>. They are actually <em>isomorphic</em>, in a sense that we define below, which is a fancy way of rigorously saying that they behave exactly the same to an external observer.</p>
<h2>Laws </h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd></dd></dl>
<h2>Minimal complete definition </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>, <code>empty</code>, <code>prepend</code>, and explicitly specialize <code>models</code> The <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> concept does not provide basic methods that could be used as a minimal complete definition; it instead borrows methods from other concepts and add laws to them. For this reason, it is necessary to specialize the <code>models</code> metafunction in the <code>boost::hana</code> namespace in addition to defining the above methods. Defining the <code>models</code> metafunction can be seen like a seal saying "this data type satisfies
the additional laws of a Sequence", even though they can't be checked syntactically.</li>
</ol>
<h2>Superclasses </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> (definition provided automatically)<br />
Two <code><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s are equal if and only if they contain the same number of elements and their elements at any given index are equal. <div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) == make&lt;Tuple&gt;(1, 2, 3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) != make&lt;Tuple&gt;(1, 2, 3, 4));</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code> (definition provided automatically)<br />
Sequences are ordered using the traditional lexicographical ordering. <div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) &lt; make&lt;Tuple&gt;(2, 3, 4));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) &lt; make&lt;Tuple&gt;(1, 2, 3, 4));</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_traversable.html" title="The Traversable concept represents types admitting a structure- preserving right fold with an Applica...">Traversable</a></code> (definition provided automatically)<br />
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    sequence&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;a2&quot;</span>s),</div>
<div class="line">                    make&lt;Tuple&gt;(<span class="stringliteral">&quot;b1&quot;</span>s),</div>
<div class="line">                    make&lt;Tuple&gt;(<span class="stringliteral">&quot;c1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s))</div>
<div class="line">    )</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c1&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s),</div>
<div class="line"></div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c1&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s)</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> half = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> if_(x % int_&lt;2&gt; == int_&lt;0&gt;,</div>
<div class="line">        just(x / int_&lt;2&gt;),</div>
<div class="line">        nothing</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;4&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    just(make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    nothing</div>
<div class="line">);</div>
</div><!-- fragment --></dd></dl>
</li>
<li><code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> (definition provided automatically)<br />
Sequences implement <code>transform</code> as the mapping of a function over each element of the sequence. This is somewhat equivalent to what <code>std::transform</code> does to ranges of iterators. Also note that mapping a function over an empty sequence returns an empty sequence and never applies the function, as would be expected. <div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    transform(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>, std::string{<span class="stringliteral">&quot;67&quot;</span>}), to_string) ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;345&quot;</span>, <span class="stringliteral">&quot;67&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> (definition provided automatically)<br />
First, <code>lift</code>ing a value into a <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> is the same as creating a singleton sequence containing that value. Second, applying a sequence of functions to a sequence of values will apply each function to all the values in the sequence, and then return a list of all the results. In other words, <div class="fragment"><div class="line">ap([f1, ..., fN], [x1, ..., xM]) == [</div>
<div class="line">    f1(x1), ..., f1(xM),</div>
<div class="line">    ...</div>
<div class="line">    fN(x1), ..., fN(xM)</div>
<div class="line">]</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(lift&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(equal(lift&lt;ext::std::Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>), std::make_tuple(<span class="charliteral">&#39;x&#39;</span>)));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = pair;</div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> g = <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(pair);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    ap(make&lt;Tuple&gt;(f, g), make&lt;Tuple&gt;(1, 2, 3), make&lt;Tuple&gt;(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>))</div>
<div class="line">        ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        f(1, <span class="charliteral">&#39;a&#39;</span>), f(1, <span class="charliteral">&#39;b&#39;</span>), f(2, <span class="charliteral">&#39;a&#39;</span>), f(2, <span class="charliteral">&#39;b&#39;</span>), f(3, <span class="charliteral">&#39;a&#39;</span>), f(3, <span class="charliteral">&#39;b&#39;</span>),</div>
<div class="line">        g(1, <span class="charliteral">&#39;a&#39;</span>), g(1, <span class="charliteral">&#39;b&#39;</span>), g(2, <span class="charliteral">&#39;a&#39;</span>), g(2, <span class="charliteral">&#39;b&#39;</span>), g(3, <span class="charliteral">&#39;a&#39;</span>), g(3, <span class="charliteral">&#39;b&#39;</span>)</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> (definition provided automatically)<br />
First, <code>flaten</code>ning a <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> takes a sequence of sequences and concatenates them to get a larger sequence. In other words, <div class="fragment"><div class="line">flatten([[a1, ..., aN], ..., [z1, ..., zM]]) == [</div>
<div class="line">    a1, ..., aN, ..., z1, ..., zM</div>
<div class="line">]</div>
</div><!-- fragment --> Also note that the model of <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> for Sequences can be seen as modeling nondeterminism. A nondeterministic computation can be modeled as a function which returns a sequence of possible results. In this line of thought, <code>bind</code>ing such a function to a sequence of values will return a sequence of all the possible output values, i.e. a sequence of all the values applied to all the functions in the sequences. <div class="fragment"><div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> make&lt;Tuple&gt;(x, -x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>((make&lt;Tuple&gt;(1, 2, 3) | f) == make&lt;Tuple&gt;(1, -1, 2, -2, 3, -3));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    flatten(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2), make&lt;Tuple&gt;(3, 4), make&lt;Tuple&gt;(make&lt;Tuple&gt;(5, 6))))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(1, 2, 3, 4, make&lt;Tuple&gt;(5, 6))</div>
<div class="line">);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> (minimal complete definition modified)<br />
Sequences are models of the <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> concept by considering the empty sequence as the unit of <code>concat</code>, and sequence concatenation as the combining operation. Note that the minimal complete definition of <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> includes the <code>prepend</code> and the <code>empty</code> methods, which are part of the <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> concept. When those methods are provided, the <code>concat</code> method is automatically defined and hence it is not strictly required to implement it in order to model <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>. <div class="fragment"></div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> (definition provided automatically)<br />
The model of <a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> for Sequences is uniquely determined by the model of <a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a>. The automatically provided model is the one provided by the <a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> concept.</li>
<li><code><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code><br />
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd></dd></dl>
</li>
<li><code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> (definition provided automatically)<br />
Searching through a <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> is equivalent to just searching through a list of the values it contains. The keys and the values on which the search is performed are both the elements of the sequence. <div class="fragment"></div><!-- fragment --></li>
</ol>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>Implement these methods: <code>intercalate</code>, <code>transpose</code>, <code>subsequences</code>, <code>split_at</code>, <code>break</code>, <code>inits</code>, <code>tails</code>, <code>iterate</code></dd></dl>
<p>And perhaps also these: <code>nub_by</code>, <code>nub</code>, <code>delete_by</code>, <code>insert</code>, <code>set_difference_by</code>, <code>set_union_by</code>, <code>set_intersection_by</code></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>Document the <a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> -&gt; <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> conversion, and also the <code>make</code> function. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:ad855f1d86e9bf0d31d67c191412a9082"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#ad855f1d86e9bf0d31d67c191412a9082">group_by</a></td></tr>
<tr class="memdesc:ad855f1d86e9bf0d31d67c191412a9082"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> the elements of a sequence into subgroups of adjacent elements that are "equal" with respect to a predicate.  <a href="#ad855f1d86e9bf0d31d67c191412a9082">More...</a><br /></td></tr>
<tr class="separator:ad855f1d86e9bf0d31d67c191412a9082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a></td></tr>
<tr class="memdesc:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> the elements of a sequence into subsequences of equal adjacent elements.  <a href="#a83d9b8f0f293c6fe7cfccd2359dec330">More...</a><br /></td></tr>
<tr class="separator:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733fdb2e8686033466beea8323e53a26"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a733fdb2e8686033466beea8323e53a26">init</a></td></tr>
<tr class="memdesc:a733fdb2e8686033466beea8323e53a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element of a non-empty sequence.  <a href="#a733fdb2e8686033466beea8323e53a26">More...</a><br /></td></tr>
<tr class="separator:a733fdb2e8686033466beea8323e53a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#ab6e88c5dd3f638a60c0a451ad6db95ec">intersperse</a></td></tr>
<tr class="memdesc:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value between each pair of elements in a sequence.  <a href="#ab6e88c5dd3f638a60c0a451ad6db95ec">More...</a><br /></td></tr>
<tr class="separator:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b65dd69bb016d647801718e840816"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a788b65dd69bb016d647801718e840816">partition</a></td></tr>
<tr class="memdesc:a788b65dd69bb016d647801718e840816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a sequence based on a <code>predicate</code>.  <a href="#a788b65dd69bb016d647801718e840816">More...</a><br /></td></tr>
<tr class="separator:a788b65dd69bb016d647801718e840816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a></td></tr>
<tr class="memdesc:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sequence of all the permutations of the given sequence.  <a href="#a45ec7767d19eb7eaabb71ead3796a7f1">More...</a><br /></td></tr>
<tr class="separator:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65295edabe2029007e7ecf640ae7bb0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a65295edabe2029007e7ecf640ae7bb0b">remove_at</a></td></tr>
<tr class="memdesc:a65295edabe2029007e7ecf640ae7bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element at a given index from a sequence.  <a href="#a65295edabe2029007e7ecf640ae7bb0b">More...</a><br /></td></tr>
<tr class="separator:a65295edabe2029007e7ecf640ae7bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597b243b348503860e1179065c508ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:aa597b243b348503860e1179065c508ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#aa597b243b348503860e1179065c508ec">remove_at_c</a></td></tr>
<tr class="memdesc:aa597b243b348503860e1179065c508ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>remove_at</code>; provided for convenience.  <a href="#aa597b243b348503860e1179065c508ec">More...</a><br /></td></tr>
<tr class="separator:aa597b243b348503860e1179065c508ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4471413ccc3835db5e48658683b8aba0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a4471413ccc3835db5e48658683b8aba0">reverse</a></td></tr>
<tr class="memdesc:a4471413ccc3835db5e48658683b8aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a sequence.  <a href="#a4471413ccc3835db5e48658683b8aba0">More...</a><br /></td></tr>
<tr class="separator:a4471413ccc3835db5e48658683b8aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb039a3d46931ef17fef56c77d8256c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a></td></tr>
<tr class="memdesc:adfb039a3d46931ef17fef56c77d8256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldl</code>, but returns a sequence of reduced values from the left.  <a href="#adfb039a3d46931ef17fef56c77d8256c">More...</a><br /></td></tr>
<tr class="separator:adfb039a3d46931ef17fef56c77d8256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62411eb57e86f3cb7394f22fd3651355"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a></td></tr>
<tr class="memdesc:a62411eb57e86f3cb7394f22fd3651355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanl</code> that has no starting value argument.  <a href="#a62411eb57e86f3cb7394f22fd3651355">More...</a><br /></td></tr>
<tr class="separator:a62411eb57e86f3cb7394f22fd3651355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb725e66aedc0c19c38b38a00302abf4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a></td></tr>
<tr class="memdesc:abb725e66aedc0c19c38b38a00302abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldr</code>, but returns a sequence of reduced values from the right.  <a href="#abb725e66aedc0c19c38b38a00302abf4">More...</a><br /></td></tr>
<tr class="separator:abb725e66aedc0c19c38b38a00302abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5948df39fe904d509f1bb073d53e3965"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a></td></tr>
<tr class="memdesc:a5948df39fe904d509f1bb073d53e3965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanr</code> that has no starting value argument.  <a href="#a5948df39fe904d509f1bb073d53e3965">More...</a><br /></td></tr>
<tr class="separator:a5948df39fe904d509f1bb073d53e3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18968c488a8b0cdc2697296024da9293"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a18968c488a8b0cdc2697296024da9293">slice</a></td></tr>
<tr class="memdesc:a18968c488a8b0cdc2697296024da9293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subsequence delimited by the given indices.  <a href="#a18968c488a8b0cdc2697296024da9293">More...</a><br /></td></tr>
<tr class="separator:a18968c488a8b0cdc2697296024da9293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplParams" colspan="2">template&lt;std::size_t from, std::size_t to&gt; </td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#afa204f71aac9f461d8574653295c67ba">slice_c</a></td></tr>
<tr class="memdesc:afa204f71aac9f461d8574653295c67ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>slice</code>; provided for convenience.  <a href="#afa204f71aac9f461d8574653295c67ba">More...</a><br /></td></tr>
<tr class="separator:afa204f71aac9f461d8574653295c67ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a></td></tr>
<tr class="memdesc:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a sequence based on the given <code>predicate</code>.  <a href="#a6ed2907b48fcba3dd1059b4b0bfde624">More...</a><br /></td></tr>
<tr class="separator:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1454689bf6d2264bc428dc1d039db"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a></td></tr>
<tr class="memdesc:a58c1454689bf6d2264bc428dc1d039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a sequence based on the total order induced by the <code>less</code> method.  <a href="#a58c1454689bf6d2264bc428dc1d039db">More...</a><br /></td></tr>
<tr class="separator:a58c1454689bf6d2264bc428dc1d039db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663fc84c23656a41d4dfcb586f0085c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a></td></tr>
<tr class="memdesc:ab663fc84c23656a41d4dfcb586f0085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a sequence satisfying a predicate, and the rest of the sequence.  <a href="#ab663fc84c23656a41d4dfcb586f0085c">More...</a><br /></td></tr>
<tr class="separator:ab663fc84c23656a41d4dfcb586f0085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20028c5115dcf38063d322f27b4ee1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a> = see documentation</td></tr>
<tr class="memdesc:a2c20028c5115dcf38063d322f27b4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first <code>n</code> elements of a sequence.  <a href="#a2c20028c5115dcf38063d322f27b4ee1">More...</a><br /></td></tr>
<tr class="separator:a2c20028c5115dcf38063d322f27b4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a63f9ab281c8e979adfd7f6678383c46b">take_c</a></td></tr>
<tr class="memdesc:a63f9ab281c8e979adfd7f6678383c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>take</code>; provided for convenience.  <a href="#a63f9ab281c8e979adfd7f6678383c46b">More...</a><br /></td></tr>
<tr class="separator:a63f9ab281c8e979adfd7f6678383c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a></td></tr>
<tr class="memdesc:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements from a sequence until the <code>predicate</code> is satisfied.  <a href="#a27aa67fa9ffc3d89b23a6dce018013d4">More...</a><br /></td></tr>
<tr class="separator:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86916c5c62a42f01f85450b366ef6eff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a></td></tr>
<tr class="memdesc:a86916c5c62a42f01f85450b366ef6eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements from a sequence while the <code>predicate</code> is satisfied.  <a href="#a86916c5c62a42f01f85450b366ef6eff">More...</a><br /></td></tr>
<tr class="separator:a86916c5c62a42f01f85450b366ef6eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8c7ea5db04febb890469a024fcd58b"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a2c8c7ea5db04febb890469a024fcd58b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a2c8c7ea5db04febb890469a024fcd58b">unfoldl</a></td></tr>
<tr class="memdesc:a2c8c7ea5db04febb890469a024fcd58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldl</code> for sequences.  <a href="#a2c8c7ea5db04febb890469a024fcd58b">More...</a><br /></td></tr>
<tr class="separator:a2c8c7ea5db04febb890469a024fcd58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#ab8e70b7be1022d132ff5369d7b1b6c2c">unfoldr</a></td></tr>
<tr class="memdesc:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldr</code> for sequences.  <a href="#ab8e70b7be1022d132ff5369d7b1b6c2c">More...</a><br /></td></tr>
<tr class="separator:ab8e70b7be1022d132ff5369d7b1b6c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5308d966fbf95d317511a706d6d20a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#abe5308d966fbf95d317511a706d6d20a">unzip</a></td></tr>
<tr class="memdesc:abe5308d966fbf95d317511a706d6d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzip a sequence of sequences.  <a href="#abe5308d966fbf95d317511a706d6d20a">More...</a><br /></td></tr>
<tr class="separator:abe5308d966fbf95d317511a706d6d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a> = see documentation</td></tr>
<tr class="memdesc:a23b6ac9e78577d70b9108a80e6b1534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one sequence or more, either with a given function or into a <a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>.  <a href="#a23b6ac9e78577d70b9108a80e6b1534c">More...</a><br /></td></tr>
<tr class="separator:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="ad855f1d86e9bf0d31d67c191412a9082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto group_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> the elements of a sequence into subgroups of adjacent elements that are "equal" with respect to a predicate. </p>
<p>Specifically, <code>group_by</code> takes a sequence and returns a sequence of sequences such that the concatenation of the result is equal to the argument. Moreover, each subsequence contains only elements for which the predicate is satisfied when applied to two adjacent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A binary function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are <em>adjacent</em> elements in the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether both elements should be in the same group (subsequence) of the result. The result returned by <code>predicate</code> has to be a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. Also, <code>predicate</code> has to define an equivalence relation as defined by the <code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> concept.</td></tr>
    <tr><td class="paramname">xs</td><td>The sequence to split into groups.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#ad855f1d86e9bf0d31d67c191412a9082">group_by</a>(equal ^<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>^ decltype_,</div>
<div class="line">        make&lt;Tuple&gt;(1, 2, 3, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, 4.4, 5.5)</div>
<div class="line">    )</div>
<div class="line">    == make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(1, 2, 3),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>),</div>
<div class="line">        make&lt;Tuple&gt;(4.4, 5.5)</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/group_by.ctime.png" alt="group_by.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a83d9b8f0f293c6fe7cfccd2359dec330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto group</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><a class="el" href="structboost_1_1hana_1_1_group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> the elements of a sequence into subsequences of equal adjacent elements. </p>
<p>Specifically, <code>group(xs)</code> is equivalent to <code>group_by(equal, xs)</code>. For this method to work, comparing adjacent elements have to return a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to split into groups.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(make&lt;Tuple&gt;(int_&lt;1&gt;, long_&lt;1&gt;, type&lt;int&gt;, char_&lt;&#39;x&#39;&gt;, char_&lt;&#39;x&#39;&gt;))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(int_&lt;1&gt;, long_&lt;1&gt;),</div>
<div class="line">        make&lt;Tuple&gt;(type&lt;int&gt;),</div>
<div class="line">        make&lt;Tuple&gt;(char_&lt;&#39;x&#39;&gt;, char_&lt;&#39;x&#39;&gt;)</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a733fdb2e8686033466beea8323e53a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the last element of a non-empty sequence. </p>
<p>If the sequence is empty, a compile-time assertion is triggered. Otherwise, a copy of the original sequence with its last element removed is returned.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a733fdb2e8686033466beea8323e53a26">init</a>(make&lt;Tuple&gt;(1)) == make&lt;Tuple&gt;());</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a733fdb2e8686033466beea8323e53a26">init</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab6e88c5dd3f638a60c0a451ad6db95ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto intersperse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; z) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Insert a value between each pair of elements in a sequence. </p>
<p>Specifically, <code>intersperse([x1, x2, ..., xn], z)</code> is a sequence equivalent to <code>[x1, z, x2, z, x3, ..., xn-1, z, xn]</code>. If the sequence is empty or has a single element, then <code>intersperse</code> returns the sequence as-is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence in which a value is interspersed.</td></tr>
    <tr><td class="paramname">z</td><td>The value to be interspersed in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#ab6e88c5dd3f638a60c0a451ad6db95ec">intersperse</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, 3.3)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#ab6e88c5dd3f638a60c0a451ad6db95ec">intersperse</a>(make&lt;Tuple&gt;(), <span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;());</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a788b65dd69bb016d647801718e840816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Partition a sequence based on a <code>predicate</code>. </p>
<p>Specifically, returns an unspecified <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> whose first element is a sequence of the elements satisfying the predicate, and whose second element is a sequence of the elements that do not satisfy the predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to be partitioned.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for each element <code>x</code> in the sequence and returning a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. If the result of <code>predicate</code> is true, then <code>x</code> is added to the sequence in the first component of the resulting <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>. Otherwise, <code>x</code> is added to the sequence in the second component.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a788b65dd69bb016d647801718e840816">partition</a>(tuple_c&lt;int, 1, 2, 3, 4, 5, 6, 7&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % int_&lt;2&gt; != int_&lt;0&gt;;</div>
<div class="line">    })</div>
<div class="line">    ==</div>
<div class="line">    pair(</div>
<div class="line">        tuple_c&lt;int, 1, 3, 5, 7&gt;,</div>
<div class="line">        tuple_c&lt;int, 2, 4, 6&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a788b65dd69bb016d647801718e840816">partition</a>(tuple_t&lt;void, int, float, char, double&gt;, trait&lt;std::is_floating_point&gt;)</div>
<div class="line">    ==</div>
<div class="line">    pair(</div>
<div class="line">        tuple_t&lt;float, double&gt;,</div>
<div class="line">        tuple_t&lt;void, int, char&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45ec7767d19eb7eaabb71ead3796a7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto permutations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a sequence of all the permutations of the given sequence. </p>
<p>Specifically, <code>permutations(xs)</code> is a sequence whose elements are permutations of the original sequence <code>xs</code>. The permutations are not guaranteed to be in any specific order. Also note that the number of permutations grows very rapidly as the length of the original sequence increases. The growth rate is <code>O(length(xs)!)</code>; with a sequence <code>xs</code> of length only 8, <code>permutations(xs)</code> contains over 40 000 elements!</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> is_permutation_of = curry&lt;2&gt;([](<span class="keyword">auto</span> xs, <span class="keyword">auto</span> perm) {</div>
<div class="line">    <span class="keywordflow">return</span> elem(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a>(xs), perm);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    all(</div>
<div class="line">        make&lt;Tuple&gt;(</div>
<div class="line">            make&lt;Tuple&gt;(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0),</div>
<div class="line">            make&lt;Tuple&gt;(<span class="charliteral">&#39;1&#39;</span>, 3.0, 2),</div>
<div class="line">            make&lt;Tuple&gt;(2, <span class="charliteral">&#39;1&#39;</span>, 3.0),</div>
<div class="line">            make&lt;Tuple&gt;(2, 3.0, <span class="charliteral">&#39;1&#39;</span>),</div>
<div class="line">            make&lt;Tuple&gt;(3.0, <span class="charliteral">&#39;1&#39;</span>, 2),</div>
<div class="line">            make&lt;Tuple&gt;(3.0, 2, <span class="charliteral">&#39;1&#39;</span>)</div>
<div class="line">        ),</div>
<div class="line">        is_permutation_of(make&lt;Tuple&gt;(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0))</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/permutations.ctime.png" alt="permutations.ctime.png"/>
</div>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>When the size of the sequence is known at compile-time, we can generate the indices <code>constexpr</code> and then simply use <code>at_c</code>. This could vastly improve the compilation time. </dd></dl>

</div>
</div>
<a class="anchor" id="a65295edabe2029007e7ecf640ae7bb0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_at</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; n, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the element at a given index from a sequence. </p>
<p><code>remove_at</code> returns a new sequence identical to the original, except that the element at the given index is removed. Specifically, <code>remove_at(n, [x0, ..., xn-1, xn, xn+1, ..., xm])</code> is a new sequence equivalent to <code>[x0, ..., xn-1, xn+1, ..., xm]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>An non-negative <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the index of the element to be removed from the sequence.</td></tr>
    <tr><td class="paramname">xs</td><td>A sequence from which an element is to be removed.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a65295edabe2029007e7ecf640ae7bb0b">remove_at</a>(int_&lt;2&gt;, make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u)) == make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 3u)</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/remove_at.ctime.png" alt="remove_at.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="aa597b243b348503860e1179065c508ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_at_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_sequence.html#a65295edabe2029007e7ecf640ae7bb0b">remove_at</a>(size_t&lt;n&gt;, forwarded(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>remove_at</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    remove_at_c&lt;2&gt;(make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u)) == make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 3u)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4471413ccc3835db5e48658683b8aba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Reverse a sequence. </p>
<p>Specifically, <code>reverse(xs)</code> is a new sequence containing the same elements as <code>xs</code>, except in reverse order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to reverse.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a4471413ccc3835db5e48658683b8aba0">reverse</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(3.3, <span class="charliteral">&#39;2&#39;</span>, 1));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adfb039a3d46931ef17fef56c77d8256c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Similar to <code>foldl</code>, but returns a sequence of reduced values from the left. </p>
<p><code>scanl</code> folds a sequence from the left, like <code>foldl</code>, but it builds up a sequence of the intermediary results computed along the way and returns that instead. Specifically, the <code>i</code>th element of the <code>scanl([x1, ..., xn], state, f)</code> sequence is equivalent to <code>foldl([x1, ..., xi], state, f)</code>. For example, consider this left fold on a short sequence: </p><div class="fragment"><div class="line">foldl([x1, x2, x3], state, f) == f(f(f(state, x1), x2), x3)</div>
</div><!-- fragment --><p> The analogous sequence generated with <code>scanl</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a>([x1, x2, x3], state, f) == [</div>
<div class="line">    state,</div>
<div class="line">    f(state, x1),</div>
<div class="line">    f(f(state, x1), x2),</div>
<div class="line">    f(f(f(state, x1), x2), x3)</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to fold from the left.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. This will always be the first element of the resulting sequence.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a>(make&lt;Tuple&gt;(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>), 1, show) == make&lt;Tuple&gt;(</div>
<div class="line">    1,</div>
<div class="line">    <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;(((1 + 2) + 3) + 4)&quot;</span></div>
<div class="line">));</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/scanl.ctime.png" alt="scanl.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a62411eb57e86f3cb7394f22fd3651355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Variant of <code>scanl</code> that has no starting value argument. </p>
<p><code>scanl1</code> is to <code>scanl</code> what <code>foldl1</code> is to <code>foldl</code>. Like <code>scanl</code>, <code>scanl1</code> folds a sequence from the left and build up a sequence of the intermediary results. However, it uses the first element of the sequence as an initial state instead of taking it as an argument. For example, consider this left fold on a short sequence: </p><div class="fragment"><div class="line">foldl1([x1, x2, x3, x4], f) == f(f(f(x1, x2), x3), x4)</div>
</div><!-- fragment --><p> The analogous sequence generated with <code>scanl1</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a>([x1, x2, x3, x4], f) == [</div>
<div class="line">    x1,</div>
<div class="line">    f(x1, x2),</div>
<div class="line">    f(f(x1, x2), x3),</div>
<div class="line">    f(f(f(x1, x2), x3), x4)</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Unlike <code>foldl1</code>, which fails when it is applied to an empty structure, <code>scanl1</code> can be called on an empty sequence, in which case it will simply return an empty sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to fold from the left.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a>(make&lt;Tuple&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), show) == make&lt;Tuple&gt;(</div>
<div class="line">    1,</div>
<div class="line">    <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span></div>
<div class="line">));</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/scanl1.ctime.png" alt="scanl1.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="abb725e66aedc0c19c38b38a00302abf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Similar to <code>foldr</code>, but returns a sequence of reduced values from the right. </p>
<p><code>scanr</code> folds a sequence from the right, like <code>foldr</code>, but it builds up a sequence of the intermediary results computed along the way and returns that instead. For example, consider this right fold on a short sequence: </p><div class="fragment"><div class="line">foldr([x1, x2, x3], state, f) == f(x1, f(x2, f(x3, state)))</div>
</div><!-- fragment --><p> The analogous sequence generated with <code>scanr</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a>([x1, x2, x3], state, f) == [</div>
<div class="line">    f(x1, f(x2, f(x3, state))),</div>
<div class="line">          f(x2, f(x3, state)),</div>
<div class="line">                f(x3, state),</div>
<div class="line">                      state</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to fold from the right.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. This will always be the last element of the resulting sequence.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a>(make&lt;Tuple&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), 4, show) == make&lt;Tuple&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;(1 + (2 + (3 + 4)))&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;(2 + (3 + 4))&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;(3 + 4)&quot;</span>,</div>
<div class="line">    4</div>
<div class="line">));</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/scanr.ctime.png" alt="scanr.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a5948df39fe904d509f1bb073d53e3965"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Variant of <code>scanr</code> that has no starting value argument. </p>
<p><code>scanr1</code> is to <code>scanr</code> what <code>foldr1</code> is to <code>foldr</code>. Like <code>scanr</code>, <code>scanr1</code> folds a sequence from the right and build up a sequence of the intermediary results. However, it uses the last element of the sequence as an initial state instead of taking it as an argument. For example, consider this right fold on a short sequence: </p><div class="fragment"><div class="line">foldr1([x1, x2, x3, x4], f) == f(x1, f(x2, f(x3, x4)))</div>
</div><!-- fragment --><p> The analogous sequence generated with <code>scanr1</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a>([x1, x2, x3, x4], f) == [</div>
<div class="line">    f(x1, f(x2, f(x3, x4))),</div>
<div class="line">          f(x2, f(x3, x4)),</div>
<div class="line">                f(x3, x4),</div>
<div class="line">                      x4</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Unlike <code>foldr1</code>, which fails when it is applied to an empty structure, <code>scanr1</code> can be called on an empty sequence, in which case it will simply return an empty sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to fold from the right.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a>(make&lt;Tuple&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), show) == make&lt;Tuple&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;(1 + (2 + 3))&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;(2 + 3)&quot;</span>,</div>
<div class="line">    <span class="charliteral">&#39;3&#39;</span></div>
<div class="line">));</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/scanr1.ctime.png" alt="scanr1.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a18968c488a8b0cdc2697296024da9293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; from, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Extract a subsequence delimited by the given indices. </p>
<p>Specifically, <code>slice(xs, from, to)</code> is a sequence containing all the elements of <code>xs</code> at indices in the half-open interval delimited by [<code>from</code>, <code>to</code>). Note that the indices are 0-based. For this operation to be valid, <code>xs</code> must contain at least <code>to + 1</code> elements, and it must be true that <code>from &lt;= to</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to slice.</td></tr>
    <tr><td class="paramname">from</td><td>The index of the first element in the slice. <code>from</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type.</td></tr>
    <tr><td class="paramname">to</td><td>One-past the index of the last element in the slice. <code>to</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type such that <code>from &lt;= to</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a18968c488a8b0cdc2697296024da9293">slice</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, type&lt;float&gt;), int_&lt;1&gt;, int_&lt;3&gt;)</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">);</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>Should this be <code>slice(xs, from, length)</code> instead? </dd></dl>

</div>
</div>
<a class="anchor" id="afa204f71aac9f461d8574653295c67ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t from, std::size_t to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_sequence.html#a18968c488a8b0cdc2697296024da9293">slice</a>(forwarded(xs), size_t&lt;from&gt;, size_t&lt;to&gt;);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>slice</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    slice_c&lt;1, 3&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, type&lt;float&gt;))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ed2907b48fcba3dd1059b4b0bfde624"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sort a sequence based on the given <code>predicate</code>. </p>
<p>Specifically, <code>sort_by</code> returns a new sequence containing the same elements as the original, except they are ordered in such a way that if <code>x</code> comes before <code>y</code> in the sequence, then either <code>predicate(x, y)</code> is true, or both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false. Also note that the sort is guaranteed to be stable. Hence, if <code>x</code> comes before <code>y</code> in the original sequence and both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false, then <code>x</code> will come before <code>y</code> in the resulting sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code> for two elements <code>x</code> and <code>y</code> of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should appear <b>before</b> <code>y</code> in the resulting sequence. More specifically, <code>predicate</code> must define a [strict weak ordering][1] on the elements of the sequence. In the current version of the library, also note that <code>predicate</code> must return a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> when called with any two elements of the sequence.</td></tr>
    <tr><td class="paramname">xs</td><td>The sequence to sort.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>&gt;<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>, make&lt;Tuple&gt;(1_c, -2_c, 3_c, 0_c))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(3_c, 1_c, 0_c, -2_c)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a58c1454689bf6d2264bc428dc1d039db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sort a sequence based on the total order induced by the <code>less</code> method. </p>
<p>The elements in the sequence must all be <code><a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code>. Also, in the current version of the library, the <code>less</code> method must return a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> when called with any two elements of the sequence.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(make&lt;Tuple&gt;(1_c, -2_c, 3_c, 0_c)) == make&lt;Tuple&gt;(-2_c, 0_c, 1_c, 3_c)</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/sort.ctime.png" alt="sort.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="ab663fc84c23656a41d4dfcb586f0085c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto span</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a sequence satisfying a predicate, and the rest of the sequence. </p>
<p>The first component of the returned <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a sequence for which all elements satisfy the given predicate. The second component of the returned <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a sequence containing the remainder of the argument. Both or either sequences may be empty, depending on the input argument. Specifically, <code>span(xs, predicate)</code> is equivalent to </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, predicate) == pair(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(xs, predicate),</div>
<div class="line">                            drop_while(xs, predicate))</div>
</div><!-- fragment --><p> except that <code>pair</code> may be an arbitrary <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to break into two parts.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>. In the current implementation of the library,</code>predicate<code>has to return a</code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> Logical`.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> xs = make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;4&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;3&gt;)</div>
<div class="line">    ==</div>
<div class="line">    pair(make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;), make&lt;Tuple&gt;(int_&lt;3&gt;, int_&lt;4&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;0&gt;)</div>
<div class="line">    ==</div>
<div class="line">    pair(make&lt;Tuple&gt;(), xs)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;5&gt;)</div>
<div class="line">    ==</div>
<div class="line">    pair(xs, make&lt;Tuple&gt;())</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c20028c5115dcf38063d322f27b4ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first <code>n</code> elements of a sequence. </p>
<p>Broadly speaking, <code>take(n, xs)</code> is a new sequence containing the first <code>n</code> elements of <code>xs</code>, in the same order. <code>n</code> must be a <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> of an unsigned integral type. However, there are different ways of calling <code>take</code>, which correspond to different policies in case the length of the sequence is less than <code>n</code>: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(n, xs)         = <a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.at_most(n, xs)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.at_most(n, xs) = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.exactly(n, xs) = see below</div>
</div><!-- fragment --><p>In case <code>length(xs) &lt; n</code>, the <code>take.at_most</code> variant will simply take the whole sequence, without failing. In contrast, the <code>take.exactly</code> variant assumes that <code>length(xs) &gt;= n</code>, which makes it possible to perform some optimizations.</p>
<p>All of the different variants are tag-dispatched methods that can be overriden. Here is how each variant is tag-dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.at_most       -&gt;  take_at_most_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.exactly       -&gt;  take_exactly_impl</div>
</div><!-- fragment --><p> <code>take</code> is not tag dispatched, because it is just an alias to <code>take.at_most</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the number of elements to keep in the resulting sequence. If <code>length(xs) &lt; n</code>, the exact behavior is determined by the chosen policy (either <code>take.at_most</code> or <code>take.exactly</code>).</td></tr>
    <tr><td class="paramname">xs</td><td>The sequence to take the elements from.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(0_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;());</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(1_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(2_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(3_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(4_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/take.ctime.png" alt="take.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a63f9ab281c8e979adfd7f6678383c46b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(size_t&lt;n&gt;, forwarded(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>take</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(take_c&lt;2&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27aa67fa9ffc3d89b23a6dce018013d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_until</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Take elements from a sequence until the <code>predicate</code> is satisfied. </p>
<p>Specifically, <code>take_until</code> returns a new sequence containing the longest prefix of <code>xs</code> in which all elements do not satisfy the predicate. This is effectively equivalent to <code>take_while</code> with a negated predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to take the elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether the resulting sequence should stop at the element before <code>x</code>. In the current version of the library, <code>predicate</code> has to return a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a>(tuple_c&lt;int, 3, 2, 1, 0&gt;, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 2_c)</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 3, 2&gt;</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/take_until.ctime.png" alt="take_until.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a86916c5c62a42f01f85450b366ef6eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_while</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Take elements from a sequence while the <code>predicate</code> is satisfied. </p>
<p>Specifically, <code>take_while</code> returns a new sequence containing the longest prefix of <code>xs</code> in which all the elements satisfy the given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to take elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should be included in the resulting sequence. In the current version of the library, <code>predicate</code> has to return a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(tuple_c&lt;int, 0, 1, 2, 3&gt;, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 2_c)</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 0, 1&gt;</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/take_while.ctime.png" alt="take_while.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a2c8c7ea5db04febb890469a024fcd58b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unfoldl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="structboost_1_1hana_1_1_sequence.html#a733fdb2e8686033466beea8323e53a26">init</a>) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Dual to <code>foldl</code> for sequences. </p>
<p>While <code>foldl</code> reduces a structure to a summary value, <code>unfoldl</code> builds a sequence from a seed value and a function. In some cases, <code>unfoldl</code> can undo a <code>foldl</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a2c8c7ea5db04febb890469a024fcd58b">unfoldl</a>(g, foldl(xs, z, f))</div>
</div><!-- fragment --><p>if the following holds </p><div class="fragment"><div class="line">g(f(y, x)) == just(pair(y, x))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The data type of the sequence to build up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function called as <code>f(init)</code>, where <code>init</code> is an initial value, and returning<ol type="1">
<li><code>nothing</code> if it is done producing the sequence.</li>
<li><code>just(pair(init, x))</code> if it isn't, where <code>init</code> is the new initial value used in the next call to <code>f</code> and <code>x</code> is an element to be appended to the resulting sequence. Also note that <code>pair</code> may actually be replaced by any <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</li>
</ol>
</td></tr>
    <tr><td class="paramname">init</td><td>An initial value to build the sequence from.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x - int_&lt;1&gt;, x)));</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    unfoldl&lt;Tuple&gt;(f, int_&lt;10&gt;)</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab8e70b7be1022d132ff5369d7b1b6c2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unfoldr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="structboost_1_1hana_1_1_sequence.html#a733fdb2e8686033466beea8323e53a26">init</a>) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Dual to <code>foldr</code> for sequences. </p>
<p>While <code>foldr</code> reduces a structure to a summary value, <code>unfoldr</code> builds a sequence from a seed value and a function. In some cases, <code>unfoldr</code> can undo a <code>foldr</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#ab8e70b7be1022d132ff5369d7b1b6c2c">unfoldr</a>(g, foldr(xs, z, f))</div>
</div><!-- fragment --><p>if the following holds </p><div class="fragment"><div class="line">g(f(x, y)) == just(pair(x, y))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The data type of the sequence to build up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function called as <code>f(init)</code>, where <code>init</code> is an initial value, and returning<ol type="1">
<li><code>nothing</code> if it is done producing the sequence.</li>
<li><code>just(pair(x, init))</code> if it isn't, where <code>init</code> is the new initial value used in a recursive call to <code>f</code> and <code>x</code> is an element prepended to the resulting sequence. Also note that <code>pair</code> may actually be replaced by any <code><a class="el" href="structboost_1_1hana_1_1_product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</li>
</ol>
</td></tr>
    <tr><td class="paramname">init</td><td>An initial value to build the list from.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x, x - int_&lt;1&gt;)));</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    unfoldr&lt;Tuple&gt;(f, int_&lt;10&gt;)</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&gt;</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe5308d966fbf95d317511a706d6d20a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unzip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Unzip a sequence of sequences. </p>
<p><code>unzip</code> can undo a <code>zip</code> operation. Specifically, it takes a sequence of the form </p><div class="fragment"><div class="line">[s1, s2, ..., sn]</div>
</div><!-- fragment --><p> where each <code>si</code> is a sequence, and returns a sequence equivalent to <code>zip(s1, s2, ..., sn)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A sequence of sequences to unzip.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), make&lt;Tuple&gt;(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;4&#39;</span>), make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 5.5), make&lt;Tuple&gt;(3.3, 6))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), make&lt;Tuple&gt;(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6, <span class="stringliteral">&quot;ignored&quot;</span>)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;4&#39;</span>), make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 5.5), make&lt;Tuple&gt;(3.3, 6))</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23b6ac9e78577d70b9108a80e6b1534c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip one sequence or more, either with a given function or into a <a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>. </p>
<p>In a general setting, zipping several sequences with a function refers to the following operation. Given <code>n</code> sequences <code>s1, ..., sn</code> and a function <code>f</code> that takes <code>n</code> arguments, zipping produces a sequence whose i-th element is <code>f(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the i-th element of the k-th sequence passed as an argument. In other words, it produces a sequence of the form </p><div class="fragment"><div class="line">[</div>
<div class="line">    f(s1[0], ..., sn[0]),</div>
<div class="line">    f(s1[1], ..., sn[1]),</div>
<div class="line">    ...</div>
<div class="line">    f(s1[M], ..., sn[M])</div>
<div class="line">]</div>
</div><!-- fragment --><p> , where <code>M</code> is usually the length of the shortest sequence. As this suggests, there are several different ways of zipping that one might want; zip with a function, zip without a function, zip up to the shortest sequence, zip up to the longest sequence or assume all the sequences are of the same size. In Hana, all these different ways of zipping are provided, except for the "up to the longest sequence" one.</p>
<blockquote class="doxtable">
<h4>Rationale for not providing a <code>zip.longest</code> variant</h4>
<p>It would require either (1) padding the shortest sequences with an arbitrary object, or (2) pad the shortest sequences with an object provided by the user when calling <code>zip.longest</code>. Since there is no requirement that all the zipped sequences have elements of similar types, there is no way to provide a single consistent padding object in all cases. A tuple of padding objects should be provided, but I find it perhaps too complicated to be worth it for now. If you need this functionality, open a GitHub issue. </p>
</blockquote>
<p>The <code>zip</code> method is actually a function object that can be called in several different ways, each of them providing a slightly different kind of zipping. Here are the different ways of calling <code>zip</code>: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(s1, ..., sn)         = <a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest(s1, ..., sn)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.with(f, s1, ..., sn) = <a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest.with(f, s1, ..., sn)</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest(s1, ..., sn)         = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest.with(f, s1, ..., sn) = see below</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe(s1, ..., sn)         = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe.with(f, s1, ..., sn) = see below</div>
</div><!-- fragment --><p>First, one sees that calling <code>zip</code> or <code>zip.with</code> is equivalent to calling <code>zip.shortest</code> or <code>zip.shortest.with</code>, respectively. The <code>shortest</code> variant signifies that the returned sequence should stop when the shortest input sequence is exhausted, which is the usual behavior for <code>zip</code> operations.</p>
<p>Then, there are also the <code>zip.unsafe</code> and <code>zip.unsafe.with</code> variants, which both assume that all the sequences are of the same size. This allows the library to perform some optimizations. If you know that all the sequences you are about to zip are of the same length, you should use these variants.</p>
<p>Finally, the <code>with</code> variants offer the possibility of providing a custom function to do the zipping, as was explained above. The non-<code>with</code> variants, which do not accept a custom function, will zip using a tuple. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.*(s1, ..., sn) == <a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.*.with(make&lt;Tuple&gt;, s1, ..., sn)</div>
<div class="line">                   == [</div>
<div class="line">                        make&lt;Tuple&gt;(s1[0], ..., sn[0]),</div>
<div class="line">                        make&lt;Tuple&gt;(s1[1], ..., sn[1]),</div>
<div class="line">                        ...</div>
<div class="line">                        make&lt;Tuple&gt;(s1[M], ..., sn[M])</div>
<div class="line">                   ]</div>
</div><!-- fragment --><p>All of the different zipping variants are tag-dispatched methods that can be overriden. Here is how each variant is tag-dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest       -&gt;  zip_shortest_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest.with  -&gt;  zip_shortest_with_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe         -&gt;  zip_unsafe_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe.with    -&gt;  zip_unsafe_with_impl</div>
</div><!-- fragment --><p> <code>zip</code> and <code>zip.with</code> are not tag dispatched, because they are just aliases to <code>zip.shortest</code> and <code>zip.shortest.with</code>, respectively. Also note that all the sequences must have the same data type, and only the data type of the first one is used for tag-dispatching.</p>
<dl class="section note"><dt>Note</dt><dd>At least one sequence must be provided. Otherwise, it is an error.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;a&#39;</span>), make&lt;Tuple&gt;(2, 3.3))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2), make&lt;Tuple&gt;(<span class="charliteral">&#39;a&#39;</span>, 3.3))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;a&#39;</span>), make&lt;Tuple&gt;(2, 3.3), make&lt;Tuple&gt;(3, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2, 3), make&lt;Tuple&gt;(<span class="charliteral">&#39;a&#39;</span>, 3.3, <span class="charliteral">&#39;c&#39;</span>))</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/zip_with.ctime.png" alt="zip_with.ctime.png"/>
</div>
 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_sequence.html">Sequence</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
