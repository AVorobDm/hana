<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Lazy Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_lazy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_lazy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Lazy Struct Reference<div class="ingroups"><a class="el" href="group__group-datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> data type implements superficial laziness via a monadic interface. </p>
<p>It is important to understand that the laziness implemented by <code><a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> is only superficial; only function applications made inside the <code><a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> monad can be made lazy, not all their subexpressions.</p>
<h2>Modeled concepts </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code><br />
Applying a function over a lazy value with <code>transform</code> returns the result of applying the function, as a lazy value. <div class="fragment"><div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_lazy.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a>(transform(<a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>(4 / <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(1), <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> * 3)) == (4 / 1) * 3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">transform(<a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>(4 / <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(0), <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> * 3); <span class="comment">// never evaluated</span></div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code><br />
A normal value can be lifted into a lazy value by using <code>lift&lt;<a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a>&gt;</code>. A lazy function can be lazily applied to a lazy value by using <code>ap</code>.</li>
<li><code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> (operators provided)<br />
The <code><a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> monad allows combining lazy computations into larger lazy computations. <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> read_ = [](std::istream&amp; stream) {</div>
<div class="line">    T x;</div>
<div class="line">    stream &gt;&gt; x;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;read &quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; from the stream\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    <span class="keywordtype">int</span> in = 123;</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;creating the monadic chain...\n&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> out = <a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>(read_&lt;int&gt;)(std::ref(ss))</div>
<div class="line">        | [](<span class="keyword">auto</span> x) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;performing x + 1...\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>(x + 1);</div>
<div class="line">        }</div>
<div class="line">        | [](<span class="keyword">auto</span> x) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;performing x / 2...\n&quot;</span>;</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>(x / 2);</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;putting &quot;</span> &lt;&lt; in &lt;&lt; <span class="stringliteral">&quot; in the stream...\n&quot;</span>;</div>
<div class="line">    ss &lt;&lt; in; <span class="comment">// nothing is evaluated yet</span></div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;evaluating the monadic chain...\n&quot;</span>;</div>
<div class="line">    <span class="keyword">auto</span> eout = <a class="code" href="structboost_1_1hana_1_1_lazy.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a>(out);</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;the result of the monadic chain is &quot;</span> &lt;&lt; eout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(eout == (in + 1) / 2);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1_comonad.html" title="The Comonad concept represents context-sensitive computations and data. ">Comonad</a></code><br />
The <code><a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> comonad allows evaluating a lazy computation to get its result and lazily applying functions taking lazy inputs to lazy values. This <a href="http://ldionne.com/2015/03/16/laziness-as-a-comonad">blog post</a> goes into more details about lazy evaluation and comonads. <div class="fragment"><div class="line">std::stringstream s(<span class="stringliteral">&quot;1 2 3&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> i = <a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>([&amp;] {</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    s &gt;&gt; i;</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">})();</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> i_plus_one = extend(i, [](<span class="keyword">auto</span> lazy_int) {</div>
<div class="line">    <span class="keywordflow">return</span> succ(<a class="code" href="structboost_1_1hana_1_1_lazy.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a>(lazy_int));</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(extract(i_plus_one) == 2);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(extract(i_plus_one) == 3);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(extract(i_plus_one) == 4);</div>
</div><!-- fragment --></li>
</ol>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> only models a few concepts because providing more functionality would require evaluating the lazy values in most cases. Since this raises some issues such as side effects and memoization, the interface is kept minimal. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_lazy.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a></td></tr>
<tr class="memdesc:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a lazy value and return it.  <a href="#aae2998c08f1f80ed52a6acf57c4eec6c">More...</a><br /></td></tr>
<tr class="separator:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e14285897797737683aa2a776a6e0e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a></td></tr>
<tr class="memdesc:a73e14285897797737683aa2a776a6e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts a normal value to a lazy one.  <a href="#a73e14285897797737683aa2a776a6e0e">More...</a><br /></td></tr>
<tr class="separator:a73e14285897797737683aa2a776a6e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="aae2998c08f1f80ed52a6acf57c4eec6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto eval</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; see_documentation) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Evaluate a lazy value and return it. </p>
<p>Given a lazy expression <code>expr</code>, <code>eval</code> evaluates <code>expr</code> and returns the result as a normal value. However, for convenience, <code>eval</code> can also be used with nullary and unary function objects. Specifically, if <code>expr</code> does not have the <code><a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a></code> generalized type, it is called with no arguments at all and the result of that call is returned, i.e. <code>expr()</code> is returned. Otherwise, if <code>expr()</code> is ill-formed, then <code>expr(hana::id)</code> is returned instead. If that expression is ill-formed, then a compile-time error is triggered.</p>
<p>The reason for allowing nullary callables in <code>eval</code> is because this allows using nullary lambdas as lazy branches to <code>eval_if</code>, which is convenient. The reason for allowing unary callables and calling them with <code>hana::id</code> is because this allows deferring the compile-time evaluation of selected expressions inside the callable. How this can be achieve is documented by <code>eval_if</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_lazy.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a>(<a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> + 1)(3)) == 4, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a73e14285897797737683aa2a776a6e0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto lazy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keywordflow">return</span> unspecified-type;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Lifts a normal value to a lazy one. </p>
<p>Additionally, <code>lazy(f)</code> is a function such that <code>lazy(f)(x1, ..., xN)</code> is equivalent to <code>ap(lazy(f), lift&lt;<a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a>&gt;(x1), ..., lift&lt;<a class="el" href="structboost_1_1hana_1_1_lazy.html" title="The Lazy data type implements superficial laziness via a monadic interface. ">Lazy</a>&gt;(xN))</code>, which in turn is equivalent to <code>lazy(f(x1, ..., xN))</code>, except for the fact that the inner call to <code>f</code> is evaluated lazily. Note that <code>lazy(f)()</code> is equivalent to <code>lazy(f())</code>, with the inner call to <code>f</code> being evaluated lazily. This is provided for convenience even though <code>ap(lazy(f))</code> would be invalid because <code>ap</code> requires 2 arguments or more.</p>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> f = <a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>([](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> 1 / x;</div>
<div class="line">});</div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> g = <a class="code" href="structboost_1_1hana_1_1_lazy.html#a73e14285897797737683aa2a776a6e0e">lazy</a>([](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x + 1;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_lazy.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a>(if_(false_, f(0), g(0))) == 0 + 1);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_lazy.html">Lazy</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
