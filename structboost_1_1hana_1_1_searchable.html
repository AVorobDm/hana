<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Boost.Hana: boost::hana::Searchable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_searchable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="#nested-classes">Instances and minimal complete definitions</a> &#124;
<a href="structboost_1_1hana_1_1_searchable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Searchable Struct Reference<div class="ingroups"><a class="el" href="group__typeclasses.html">Type classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Data structures that can be searched. </p>
<p><code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="Data structures that can be searched. ">Searchable</a></code>s have a concept of keys and values. Searching is always done on the keys and the result is always the associated value. There is no requirement that the keys and values be different. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a></td></tr>
<tr class="memdesc:a67dd29f7921b76f7d2bd372605f73f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any key of the structure satisfies the <code>predicate</code>.  <a href="#a67dd29f7921b76f7d2bd372605f73f7c">More...</a><br /></td></tr>
<tr class="separator:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc05dc4553467aa0a2235088de41b4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a></td></tr>
<tr class="memdesc:a2dc05dc4553467aa0a2235088de41b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any key of the structure is true-valued.  <a href="#a2dc05dc4553467aa0a2235088de41b4b">More...</a><br /></td></tr>
<tr class="separator:a2dc05dc4553467aa0a2235088de41b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a></td></tr>
<tr class="memdesc:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the keys of the structure satisfy the <code>predicate</code>.  <a href="#a695907e4a3ef7d0e9ab34f5afff709b2">More...</a><br /></td></tr>
<tr class="separator:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd57241c497cbe1a2ce5ac57549080"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a></td></tr>
<tr class="memdesc:adadd57241c497cbe1a2ce5ac57549080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the keys of the structure are true-valued.  <a href="#adadd57241c497cbe1a2ce5ac57549080">More...</a><br /></td></tr>
<tr class="separator:adadd57241c497cbe1a2ce5ac57549080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365b793fe547271e48fa719a7f4854d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a></td></tr>
<tr class="memdesc:a9365b793fe547271e48fa719a7f4854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether none of the keys of the structure satisfy the <code>predicate</code>.  <a href="#a9365b793fe547271e48fa719a7f4854d">More...</a><br /></td></tr>
<tr class="separator:a9365b793fe547271e48fa719a7f4854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a></td></tr>
<tr class="memdesc:abf1dbf83a1d98c62994e207ea18eea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all of the keys of the structure are false-valued.  <a href="#abf1dbf83a1d98c62994e207ea18eea8a">More...</a><br /></td></tr>
<tr class="separator:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a></td></tr>
<tr class="memdesc:a04e413e4acd1dac89e442df2f30f3e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the key occurs in the structure.  <a href="#a04e413e4acd1dac89e442df2f30f3e2d">More...</a><br /></td></tr>
<tr class="separator:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a></td></tr>
<tr class="memdesc:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the value associated to the first key satisfying a predicate.  <a href="#a2772d97163d2e2ca3f51b2d16d13ff66">More...</a><br /></td></tr>
<tr class="separator:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e67ada9561f5e1176faab8eb94a064"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a></td></tr>
<tr class="memdesc:a82e67ada9561f5e1176faab8eb94a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the value associated to the given key in a structure.  <a href="#a82e67ada9561f5e1176faab8eb94a064">More...</a><br /></td></tr>
<tr class="separator:a82e67ada9561f5e1176faab8eb94a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Instances and minimal complete definitions</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1find__mcd.html">find_mcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal complete definition: <code>find</code> and <code>any</code>  <a href="structboost_1_1hana_1_1_searchable_1_1find__mcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_map_01_4.html">instance&lt; Map &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map can be searched by its keys with a predicate yielding a boolean <code><a class="el" href="structboost_1_1hana_1_1_integral.html" title="Represents a compile-time value of an integral type. ">Integral</a></code>.  <a href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_map_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_maybe_01_4.html">instance&lt; Maybe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searching a <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code> is equivalent to searching a list containing <code>x</code> for <code>just(x)</code> and an empty list for <code>nothing</code>.  <a href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_maybe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_set_01_4.html">instance&lt; Set &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The keys and the values of a <code><a class="el" href="structboost_1_1hana_1_1_set.html" title="A basic unordered container requiring Comparable elements. ">Set</a></code> are its elements; the <code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="Data structures that can be searched. ">Searchable</a></code>  instance follows naturally from that.  <a href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_set_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a67dd29f7921b76f7d2bd372605f73f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> predicate, <span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::any_impl(predicate, searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether any key of the structure satisfies the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to be satisfied after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(odd, list(1, 2)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(odd, list(2_c, 4_c)));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(trait&lt;std::is_void&gt;, list(type&lt;void&gt;, type&lt;char&amp;&gt;))</div>
<div class="line">    );</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        !<a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(trait&lt;std::is_integral&gt;, list(type&lt;void&gt;, type&lt;char&amp;&gt;))</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2dc05dc4553467aa0a2235088de41b4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::any_of_impl(searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether any key of the structure is true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(list(<span class="keyword">false</span>, false_, true_)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(list(<span class="keyword">false</span>, false_, false_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a695907e4a3ef7d0e9ab34f5afff709b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> predicate, <span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::all_impl(predicate, searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether all the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a false- valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(odd, list(1, 3)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(odd, list(3_c, 4_c)));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        !<a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(trait&lt;std::is_void&gt;, list(type&lt;void&gt;, type&lt;char&amp;&gt;))</div>
<div class="line">    );</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(trait&lt;std::is_integral&gt;, list(type&lt;int&gt;, type&lt;char&gt;))</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adadd57241c497cbe1a2ce5ac57549080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::all_of_impl(searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether all the keys of the structure are true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>s. If the structure is not finite, a false-valued key must appear at a finite "index" in order for this method to finish.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(list(true_, <span class="keyword">true</span>, true_)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(list(true_, false_, true_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9365b793fe547271e48fa719a7f4854d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> predicate, <span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::none_impl(predicate, searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether none of the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a true- valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(odd, list(2_c, 4_c)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(odd, list(1, 2)));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        !<a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(trait&lt;std::is_void&gt;, list(type&lt;void&gt;, type&lt;char&amp;&gt;))</div>
<div class="line">    );</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(trait&lt;std::is_integral&gt;, list(type&lt;void&gt;, type&lt;char&amp;&gt;))</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abf1dbf83a1d98c62994e207ea18eea8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::none_of_impl(searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether all of the keys of the structure are false-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(list(<span class="keyword">false</span>, false_, false_)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(list(<span class="keyword">false</span>, false_, true_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a04e413e4acd1dac89e442df2f30f3e2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto elem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> key, <span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::elem_impl(key, searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether the key occurs in the structure. </p>
<p>Specifically, returns whether any of the keys of the structure is equal to the given <code>key</code>. If the structure is not finite, an equal key has to appear at a finite "index" in the structure for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> with the other keys of the structure.</td></tr>
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(int_&lt;3&gt;, list(2, int_&lt;2&gt;, int_&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(type&lt;int&gt;, set(1, <span class="charliteral">&#39;2&#39;</span>, type&lt;int&gt;, <span class="stringliteral">&quot;foobar&quot;</span>)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2772d97163d2e2ca3f51b2d16d13ff66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto find</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> predicate, <span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::find_impl(predicate, searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Find the value associated to the first key satisfying a predicate. </p>
<p>Specifically, returns <code>just</code> the first value whose key satisfies the <code>predicate</code>, or <code>nothing</code> if there is no such key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>. Note that in the current version of the library, the <code>predicate</code> has to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>, i.e. one allowing values of different types in <code>if_</code>. This is because <code>find</code> returns a <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code>, which is an heterogeneous data type.</td></tr>
    <tr><td class="paramname">searchable</td><td>The structure to be searched.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(trait_&lt;std::is_integral&gt;, list(1.0, 2, <span class="charliteral">&#39;3&#39;</span>)) == just(2));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(trait_&lt;std::is_class&gt;, list(1.0, 2, <span class="charliteral">&#39;3&#39;</span>)) == nothing);</div>
<div class="line"></div>
<div class="line">    constexpr <span class="keyword">auto</span> types = type_list&lt;char, int, unsigned, long, unsigned long&gt;;</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(<a class="code" href="group__functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> == type&lt;unsigned&gt;, types) == just(type&lt;unsigned&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(<a class="code" href="group__functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> == type&lt;void&gt;, types) == nothing);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a82e67ada9561f5e1176faab8eb94a064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto lookup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> key, <span class="keyword">auto</span> searchable) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::lookup_impl(key, searchable);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Find the value associated to the given key in a structure. </p>
<p>Specifically, returns <code>just</code> the first value whose key is equal to the given <code>key</code>, or <code>nothing</code> if there is no such key. Comparison is done with <code>equal</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> with the other keys of the structure. In the current version of the library, the comparison of <code>key</code> with any other key of the structure must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>, i.e. one allowing values of different types in <code>if_</code>. This is because <code>lookup</code> returns a <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code>, which is an heterogeneous data type.</td></tr>
    <tr><td class="paramname">searchable</td><td>The structure to be searched.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a>(type&lt;int&gt;, list(int_&lt;1&gt;, type&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>)) == just(type&lt;int&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a>(type&lt;void&gt;, list(int_&lt;1&gt;, type&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>)) == nothing);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a>(type&lt;float&gt;, map(</div>
<div class="line">        pair(1, <span class="charliteral">&#39;x&#39;</span>),</div>
<div class="line">        pair(type&lt;float&gt;, 3.3),</div>
<div class="line">        pair(type&lt;char&gt;, type&lt;int&gt;)</div>
<div class="line">    )) == just(3.3));</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_searchable.html">Searchable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
