<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Sequence Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Sequence.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1Sequence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Sequence Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> concept represents generic index-based sequences. </p>
<p>Compared to other abstract concepts, the <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> concept is very specific. It represents generic index-based sequences. The reason why such a specific concept is provided is because there are a lot of models that behave exactly the same while being implemented in wildly different ways. It is useful to regroup all those data types under the same umbrella for the purpose of generic programming.</p>
<p>In fact, models of this concept are not only <em>similar</em>. They are actually <em>isomorphic</em>, in a sense that we define below, which is a fancy way of rigorously saying that they behave exactly the same to an external observer.</p>
<h2>Laws </h2>
<p>For any <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> data type <code>S</code>, the <code>to&lt;<a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> conversion from <code>S</code> (as a <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a>, see below) must be a natural isomorphism. Furthermore, it must be the unique (up to implementation) bijective natural <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> and <a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> isomorphism between <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> and <code>S</code>. Intuitively, this means that all Sequences act exactly like <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code>s, but their implementation may differ. This is ensured by stating that conversion to and from a <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> preserves both information quantity and organization.</p>
<p>First, information quantity is preserved by requiring <code>to&lt;<a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> to be bijective. Hence, the <code>S</code> and <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> data types contain the same amount of objects, and information quantity is preserved. Note that we explicitly require the isomorphism to be bijective because <a href="http://en.wikipedia.org/wiki/Isomorphism#Isomorphism_vs._bijective_morphism">not all isomorphisms are bijective</a>.</p>
<p>Then, information organization is preserved by requiring <code>to&lt;<a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> to be the unique natural <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> isomorphism between <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> and <code>S</code>. Since everything in <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> is implemented in terms of <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>, <a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> and other superclasses, this effectively gives us laws that must be respected for the methods of <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a>. The result is that for any <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> <code>xs</code> of data type <code>S</code> and any n-ary function <code>f</code> (suppose without loss of generality that <code>f</code> takes its <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> argument in the first parameter), </p><div class="fragment"><div class="line">to&lt;Tuple&gt;(f(xs, -, ..., -)) == f(to&lt;Tuple&gt;(xs), -, ..., -)</div>
</div><!-- fragment --><p>If <code>f</code> does not return a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a>, then simply change the above for </p><div class="fragment"><div class="line">f(xs, -, ..., -) == f(to&lt;Tuple&gt;(xs), -, ..., -)</div>
</div><!-- fragment --><p>Here, the notation <code>f(xs, -, ..., -)</code> denotes the partial application of the function <code>f</code> to its <code>xs</code> argument, with all the other arguments left unbound. Hence, these comparisons are comparisons between functions, and they express the fact that any <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> is just as good as a <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> for an external observer (the function <code>f</code>).</p>
<h2>Minimal complete definition </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>, <code>empty</code>, <code>prepend</code>, <code>models</code><br />
The <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> concept does not provide basic methods that could be used as a minimal complete definition; instead, it borrows methods from other concepts and add laws to them. For this reason, it is necessary to specialize the <code>models</code> metafunction in the <code>boost::hana</code> namespace in addition to defining the above methods. Explicitly specializing the <code>models</code> metafunction can be seen like a seal saying "this data type
satisfies the additional laws of a `Sequence`", since those can't be checked by Hana automatically.</li>
</ol>
<h2>Superclasses </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> (definition provided automatically)<br />
Two <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s are equal if and only if they contain the same number of elements and their elements at any given index are equal. <div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) == make&lt;Tuple&gt;(1, 2, 3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) != make&lt;Tuple&gt;(1, 2, 3, 4));</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code> (definition provided automatically)<br />
<code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s are ordered using the traditional lexicographical ordering. <div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) &lt; make&lt;Tuple&gt;(2, 3, 4));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(make&lt;Tuple&gt;(1, 2, 3) &lt; make&lt;Tuple&gt;(1, 2, 3, 4));</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> (definition provided automatically)<br />
<code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s implement <code>transform</code> as the mapping of a function over each element of the sequence. This is somewhat equivalent to what <code>std::transform</code> does to ranges of iterators. Also note that mapping a function over an empty sequence returns an empty sequence and never applies the function, as would be expected. <div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    transform(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>, std::string{<span class="stringliteral">&quot;67&quot;</span>}), to_string) ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;345&quot;</span>, <span class="stringliteral">&quot;67&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> (definition provided automatically)<br />
First, <code>lift</code>ing a value into a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> is the same as creating a singleton sequence containing that value. Second, applying a sequence of functions to a sequence of values will apply each function to all the values in the sequence, and then return a list of all the results. In other words, <div class="fragment"><div class="line">ap([f1, ..., fN], [x1, ..., xM]) == [</div>
<div class="line">    f1(x1), ..., f1(xM),</div>
<div class="line">    ...</div>
<div class="line">    fN(x1), ..., fN(xM)</div>
<div class="line">]</div>
</div><!-- fragment --> Example: <div class="fragment"><div class="line">static_assert(lift&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(equal(lift&lt;ext::std::Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>), std::make_tuple(<span class="charliteral">&#39;x&#39;</span>)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> f = make_pair;</div>
<div class="line">constexpr <span class="keyword">auto</span> g = <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(make_pair);</div>
<div class="line">static_assert(</div>
<div class="line">    ap(make&lt;Tuple&gt;(f, g), make&lt;Tuple&gt;(1, 2, 3), make&lt;Tuple&gt;(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>))</div>
<div class="line">        ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        f(1, <span class="charliteral">&#39;a&#39;</span>), f(1, <span class="charliteral">&#39;b&#39;</span>), f(2, <span class="charliteral">&#39;a&#39;</span>), f(2, <span class="charliteral">&#39;b&#39;</span>), f(3, <span class="charliteral">&#39;a&#39;</span>), f(3, <span class="charliteral">&#39;b&#39;</span>),</div>
<div class="line">        g(1, <span class="charliteral">&#39;a&#39;</span>), g(1, <span class="charliteral">&#39;b&#39;</span>), g(2, <span class="charliteral">&#39;a&#39;</span>), g(2, <span class="charliteral">&#39;b&#39;</span>), g(3, <span class="charliteral">&#39;a&#39;</span>), g(3, <span class="charliteral">&#39;b&#39;</span>)</div>
<div class="line">    )</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> (definition provided automatically)<br />
First, <code>flaten</code>ning a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> takes a sequence of sequences and concatenates them to get a larger sequence. In other words, <div class="fragment"><div class="line">flatten([[a1, ..., aN], ..., [z1, ..., zM]]) == [</div>
<div class="line">    a1, ..., aN, ..., z1, ..., zM</div>
<div class="line">]</div>
</div><!-- fragment --> This acts like a <code>std::tuple_cat</code> function, except it receives a sequence of sequences instead of a variadic pack of sequences to flatten.<br />
<b>Example</b>: <div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    flatten(make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(1, 2),</div>
<div class="line">        make&lt;Tuple&gt;(3, 4),</div>
<div class="line">        make&lt;Tuple&gt;(make&lt;Tuple&gt;(5, 6))</div>
<div class="line">    ))</div>
<div class="line">    == make&lt;Tuple&gt;(1, 2, 3, 4, make&lt;Tuple&gt;(5, 6))</div>
<div class="line">);</div>
</div><!-- fragment --> Also note that the model of <code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> for <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s can be seen as modeling nondeterminism. A nondeterministic computation can be modeled as a function which returns a sequence of possible results. In this line of thought, <code>chain</code>ing a sequence of values into such a function will return a sequence of all the possible output values, i.e. a sequence of all the values applied to all the functions in the sequences.<br />
<b>Example</b>: <div class="fragment"><div class="line"><span class="comment">// Using the Tuple Monad, we generate all the possible combinations of</span></div>
<div class="line"><span class="comment">// cv-qualifiers and reference qualifiers. Then, we use the Maybe Monad</span></div>
<div class="line"><span class="comment">// to make sure that our generic function can be called with arguments</span></div>
<div class="line"><span class="comment">// of any of those types.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// cv_qualifiers : Type -&gt; Tuple(Type)</span></div>
<div class="line"><span class="keyword">auto</span> cv_qualifiers = [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keywordflow">return</span> make_tuple(</div>
<div class="line">        t,</div>
<div class="line">        traits::add_const(t),</div>
<div class="line">        traits::add_volatile(t),</div>
<div class="line">        traits::add_volatile(traits::add_const(t))</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// ref_qualifiers : Type -&gt; Tuple(Type)</span></div>
<div class="line"><span class="keyword">auto</span> ref_qualifiers = [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keywordflow">return</span> make_tuple(</div>
<div class="line">        traits::add_lvalue_reference(t),</div>
<div class="line">        traits::add_rvalue_reference(t)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> possible_args = cv_qualifiers(type&lt;int&gt;) | ref_qualifiers;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    possible_args == make&lt;Tuple&gt;(</div>
<div class="line">                        type&lt;int&amp;&gt;,</div>
<div class="line">                        type&lt;int&amp;&amp;&gt;,</div>
<div class="line">                        type&lt;int const&amp;&gt;,</div>
<div class="line">                        type&lt;int const&amp;&amp;&gt;,</div>
<div class="line">                        type&lt;int volatile&amp;&gt;,</div>
<div class="line">                        type&lt;int volatile&amp;&amp;&gt;,</div>
<div class="line">                        type&lt;int const volatile&amp;&gt;,</div>
<div class="line">                        type&lt;int const volatile&amp;&amp;&gt;</div>
<div class="line">                    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> my_generic_function = [](<span class="keyword">auto</span>&amp;&amp;) { <span class="keywordflow">return</span> 1; };</div>
<div class="line"></div>
<div class="line">for_each(possible_args, [=](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> decltype(t)::type;</div>
<div class="line">    static_assert(decltype(is_just(sfinae(my_generic_function)(std::declval&lt;T&gt;()))){},</div>
<div class="line">    <span class="stringliteral">&quot;my_generic_function should be callable with any type of argument&quot;</span>);</div>
<div class="line">});</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> (minimal complete definition modified)<br />
<code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s are models of the <code><a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> concept by considering the empty sequence as the unit of <code>concat</code>, and sequence concatenation as the combining operation. Note that the minimal complete definition of <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> includes the <code>prepend</code> and the <code>empty</code> methods, which are part of the <code><a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> concept. When those methods are provided, the <code>concat</code> method is automatically defined and hence it is not strictly required to implement it in order to model <code><a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code>. <div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(empty&lt;Tuple&gt;() == make&lt;Tuple&gt;());</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    append(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="keyword">nullptr</span>) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="keyword">nullptr</span>)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    concat(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), make&lt;Tuple&gt;(<span class="stringliteral">&quot;abcdef&quot;</span>s)) ==</div>
<div class="line">    make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abcdef&quot;</span>s)</div>
<div class="line">);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> (definition provided automatically)<br />
The model of <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> for <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s is uniquely determined by the model of <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>. The automatically provided model is the one provided by the <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code> concept. <div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(fold.left(make&lt;Tuple&gt;(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>), <span class="stringliteral">&quot;1&quot;</span>, show) == <span class="stringliteral">&quot;(((1 + 2) + 3) + 4)&quot;</span>);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code><br />
The model of <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code> for <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s corresponds to iteration over each element of the sequence, in order. <div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(head(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == 1);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(tail(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!is_empty(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(is_empty(make&lt;Tuple&gt;()));</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> (definition provided automatically)<br />
Searching through a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> is equivalent to just searching through a list of the values it contains. The keys and the values on which the search is performed are both the elements of the sequence. <div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    find_if(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abc&quot;</span>s), is_a&lt;std::string&gt;) == just(<span class="stringliteral">&quot;abc&quot;</span>s)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    <span class="stringliteral">&quot;abc&quot;</span>s ^in^ make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abc&quot;</span>s)</div>
<div class="line">);</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a></code> (definition provided automatically)<br />
The model of <code><a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a></code> for <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s allows turning a sequence of <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>s into an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> containing a sequence. <div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    sequence&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;a2&quot;</span>s),</div>
<div class="line">                    make&lt;Tuple&gt;(<span class="stringliteral">&quot;b1&quot;</span>s),</div>
<div class="line">                    make&lt;Tuple&gt;(<span class="stringliteral">&quot;c1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s))</div>
<div class="line">    )</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c1&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s),</div>
<div class="line"></div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c1&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s)</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> half = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> if_(x % int_&lt;2&gt; == int_&lt;0&gt;,</div>
<div class="line">        just(x / int_&lt;2&gt;),</div>
<div class="line">        nothing</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;4&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    just(make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    nothing</div>
<div class="line">);</div>
</div><!-- fragment --></li>
</ol>
<h2>Provided <code>make</code> </h2>
<p>For any <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S</code>, the <code>make&lt;S&gt;</code> method is defined automatically as </p><div class="fragment"><div class="line">make&lt;S&gt;(x1, ..., xn) == fold.right(make&lt;Tuple&gt;(x1, ..., xn), prepend, empty&lt;S&gt;())</div>
<div class="line">                     == [x1, ..., xn] <span class="comment">// of data type S</span></div>
</div><!-- fragment --><p>While this definition is correct, it can be compile-time inefficient. Hence, implementers of new sequences are encouraged to override this default definition. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a> = see documentation</td></tr>
<tr class="memdesc:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1Group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> adjacent elements of a sequence that all respect a binary predicate, by default equality.  <a href="#a83d9b8f0f293c6fe7cfccd2359dec330">More...</a><br /></td></tr>
<tr class="separator:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733fdb2e8686033466beea8323e53a26"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a733fdb2e8686033466beea8323e53a26">init</a></td></tr>
<tr class="memdesc:a733fdb2e8686033466beea8323e53a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element of a non-empty sequence.  <a href="#a733fdb2e8686033466beea8323e53a26">More...</a><br /></td></tr>
<tr class="separator:a733fdb2e8686033466beea8323e53a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#ab6e88c5dd3f638a60c0a451ad6db95ec">intersperse</a></td></tr>
<tr class="memdesc:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value between each pair of elements in a sequence.  <a href="#ab6e88c5dd3f638a60c0a451ad6db95ec">More...</a><br /></td></tr>
<tr class="separator:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b65dd69bb016d647801718e840816"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a></td></tr>
<tr class="memdesc:a788b65dd69bb016d647801718e840816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a sequence based on a <code>predicate</code>.  <a href="#a788b65dd69bb016d647801718e840816">More...</a><br /></td></tr>
<tr class="separator:a788b65dd69bb016d647801718e840816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a></td></tr>
<tr class="memdesc:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sequence of all the permutations of the given sequence.  <a href="#a45ec7767d19eb7eaabb71ead3796a7f1">More...</a><br /></td></tr>
<tr class="separator:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65295edabe2029007e7ecf640ae7bb0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a65295edabe2029007e7ecf640ae7bb0b">remove_at</a></td></tr>
<tr class="memdesc:a65295edabe2029007e7ecf640ae7bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element at a given index from a sequence.  <a href="#a65295edabe2029007e7ecf640ae7bb0b">More...</a><br /></td></tr>
<tr class="separator:a65295edabe2029007e7ecf640ae7bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597b243b348503860e1179065c508ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:aa597b243b348503860e1179065c508ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#aa597b243b348503860e1179065c508ec">remove_at_c</a></td></tr>
<tr class="memdesc:aa597b243b348503860e1179065c508ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>remove_at</code>; provided for convenience.  <a href="#aa597b243b348503860e1179065c508ec">More...</a><br /></td></tr>
<tr class="separator:aa597b243b348503860e1179065c508ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4471413ccc3835db5e48658683b8aba0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a4471413ccc3835db5e48658683b8aba0">reverse</a></td></tr>
<tr class="memdesc:a4471413ccc3835db5e48658683b8aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a sequence.  <a href="#a4471413ccc3835db5e48658683b8aba0">More...</a><br /></td></tr>
<tr class="separator:a4471413ccc3835db5e48658683b8aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37751569a9f7188ab64a2c288168b404"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a37751569a9f7188ab64a2c288168b404">scan</a> = see documentation</td></tr>
<tr class="memdesc:a37751569a9f7188ab64a2c288168b404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> and return a list containing the successive reduction states.  <a href="#a37751569a9f7188ab64a2c288168b404">More...</a><br /></td></tr>
<tr class="separator:a37751569a9f7188ab64a2c288168b404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18968c488a8b0cdc2697296024da9293"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a18968c488a8b0cdc2697296024da9293">slice</a></td></tr>
<tr class="memdesc:a18968c488a8b0cdc2697296024da9293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subsequence delimited by the given indices.  <a href="#a18968c488a8b0cdc2697296024da9293">More...</a><br /></td></tr>
<tr class="separator:a18968c488a8b0cdc2697296024da9293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplParams" colspan="2">template&lt;std::size_t from, std::size_t to&gt; </td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#afa204f71aac9f461d8574653295c67ba">slice_c</a></td></tr>
<tr class="memdesc:afa204f71aac9f461d8574653295c67ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>slice</code>; provided for convenience.  <a href="#afa204f71aac9f461d8574653295c67ba">More...</a><br /></td></tr>
<tr class="separator:afa204f71aac9f461d8574653295c67ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1454689bf6d2264bc428dc1d039db"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a> = see documentation</td></tr>
<tr class="memdesc:a58c1454689bf6d2264bc428dc1d039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a sequence, optionally based on a custom <code>predicate</code>.  <a href="#a58c1454689bf6d2264bc428dc1d039db">More...</a><br /></td></tr>
<tr class="separator:a58c1454689bf6d2264bc428dc1d039db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663fc84c23656a41d4dfcb586f0085c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a></td></tr>
<tr class="memdesc:ab663fc84c23656a41d4dfcb586f0085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a sequence satisfying a predicate, and the rest of the sequence.  <a href="#ab663fc84c23656a41d4dfcb586f0085c">More...</a><br /></td></tr>
<tr class="separator:ab663fc84c23656a41d4dfcb586f0085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b5d2d363fb5e2d444e8bfe6bc712c7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a65b5d2d363fb5e2d444e8bfe6bc712c7">subsequence</a></td></tr>
<tr class="memdesc:a65b5d2d363fb5e2d444e8bfe6bc712c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements at the given indices of a sequence.  <a href="#a65b5d2d363fb5e2d444e8bfe6bc712c7">More...</a><br /></td></tr>
<tr class="separator:a65b5d2d363fb5e2d444e8bfe6bc712c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20028c5115dcf38063d322f27b4ee1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a> = see documentation</td></tr>
<tr class="memdesc:a2c20028c5115dcf38063d322f27b4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first <code>n</code> elements of a sequence.  <a href="#a2c20028c5115dcf38063d322f27b4ee1">More...</a><br /></td></tr>
<tr class="separator:a2c20028c5115dcf38063d322f27b4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a63f9ab281c8e979adfd7f6678383c46b">take_c</a></td></tr>
<tr class="memdesc:a63f9ab281c8e979adfd7f6678383c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>take</code>; provided for convenience.  <a href="#a63f9ab281c8e979adfd7f6678383c46b">More...</a><br /></td></tr>
<tr class="separator:a63f9ab281c8e979adfd7f6678383c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a></td></tr>
<tr class="memdesc:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements from a sequence until the <code>predicate</code> is satisfied.  <a href="#a27aa67fa9ffc3d89b23a6dce018013d4">More...</a><br /></td></tr>
<tr class="separator:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86916c5c62a42f01f85450b366ef6eff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a></td></tr>
<tr class="memdesc:a86916c5c62a42f01f85450b366ef6eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements from a sequence while the <code>predicate</code> is satisfied.  <a href="#a86916c5c62a42f01f85450b366ef6eff">More...</a><br /></td></tr>
<tr class="separator:a86916c5c62a42f01f85450b366ef6eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bed7da3a1bc6d0e8d11e5440d879c3"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a08bed7da3a1bc6d0e8d11e5440d879c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a08bed7da3a1bc6d0e8d11e5440d879c3">unfold</a> = see documentation</td></tr>
<tr class="memdesc:a08bed7da3a1bc6d0e8d11e5440d879c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual operation to <code>fold</code> for sequences.  <a href="#a08bed7da3a1bc6d0e8d11e5440d879c3">More...</a><br /></td></tr>
<tr class="separator:a08bed7da3a1bc6d0e8d11e5440d879c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5308d966fbf95d317511a706d6d20a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#abe5308d966fbf95d317511a706d6d20a">unzip</a></td></tr>
<tr class="memdesc:abe5308d966fbf95d317511a706d6d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzip a sequence of sequences.  <a href="#abe5308d966fbf95d317511a706d6d20a">More...</a><br /></td></tr>
<tr class="separator:abe5308d966fbf95d317511a706d6d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a> = see documentation</td></tr>
<tr class="memdesc:a23b6ac9e78577d70b9108a80e6b1534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one sequence or more, either with a given function or into a <a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>.  <a href="#a23b6ac9e78577d70b9108a80e6b1534c">More...</a><br /></td></tr>
<tr class="separator:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a83d9b8f0f293c6fe7cfccd2359dec330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto group = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structboost_1_1hana_1_1Group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> adjacent elements of a sequence that all respect a binary predicate, by default equality. </p>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> and an optional predicate (by default <code>equal</code>), <code>group</code> returns a sequence of subsequences representing groups of adjacent elements that are "equal" with respect to the predicate. In other words, the groups are such that the predicate is satisfied when it is applied to any two adjacent elements in that group. The sequence returned by <code>group</code> is such that the concatenation of its elements is equal to the original sequence, which is equivalent to saying that the order of the elements is not changed.</p>
<p>If no predicate is provided, adjacent elements in the sequence must all be compile-time <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> <code>s</code> of data type <code>S(T)</code>, a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a predicate \( pred : T \times T \to Bool \), <code>group</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathrm{group} : S(T) \times (T \times T \to Bool) \to S(S(T)) \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a>. The signature is then </p><p class="formulaDsp">
\[ \mathrm{group} : S(T) \to S(S(T)) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to split into groups.</td></tr>
    <tr><td class="paramname">predicate</td><td>A binary function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are <em>adjacent</em> elements in the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether both elements should be in the same group (subsequence) of the result. The result returned by <code>predicate</code> has to be a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. Also, <code>predicate</code> has to define an equivalence relation as defined by the <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> concept. When this predicate is not provided, it defaults to <code>equal</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>group.by</code>) </h2>
<p><code>group</code> can be called in a third way, which provides a nice syntax especially when working with the <code>comparing</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>.by(predicate) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>group(-, predicate)</code> denotes the partial application of <code>group</code> to <code>predicate</code>.</p>
<h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>group</code> are tag-dispatched methods, and hence they can be customized independently. Here is how the different versions of <code>group</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">group_impl&lt;data type of xs&gt;::apply</a>(xs)</div>
<div class="line">group(xs, pred) -&gt; group_pred_impl&lt;data type of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div>
</div><!-- fragment --><p>Also note that <code>group.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>group</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// without a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(make&lt;Tuple&gt;(int_&lt;1&gt;, long_&lt;1&gt;, type&lt;int&gt;, char_&lt;&#39;x&#39;&gt;, char_&lt;&#39;x&#39;&gt;))</div>
<div class="line">        == make&lt;Tuple&gt;(</div>
<div class="line">            make&lt;Tuple&gt;(int_&lt;1&gt;, long_&lt;1&gt;),</div>
<div class="line">            make&lt;Tuple&gt;(type&lt;int&gt;),</div>
<div class="line">            make&lt;Tuple&gt;(char_&lt;&#39;x&#39;&gt;, char_&lt;&#39;x&#39;&gt;)</div>
<div class="line">        )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// with a predicate</span></div>
<div class="line"><span class="keyword">auto</span> tuples = make&lt;Tuple&gt;(</div>
<div class="line">    range_c&lt;int, 0, 1&gt;,</div>
<div class="line">    range_c&lt;int, 0, 2&gt;,</div>
<div class="line">    range_c&lt;int, 1, 3&gt;,</div>
<div class="line">    range_c&lt;int, 2, 6&gt;</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(tuples, comparing(length))</div>
<div class="line">        == make&lt;Tuple&gt;(</div>
<div class="line">            make&lt;Tuple&gt;(</div>
<div class="line">                range_c&lt;int, 0, 1&gt;</div>
<div class="line">            ),</div>
<div class="line">            make&lt;Tuple&gt;(</div>
<div class="line">                range_c&lt;int, 0, 2&gt;,</div>
<div class="line">                range_c&lt;int, 1, 3&gt;</div>
<div class="line">            ),</div>
<div class="line">            make&lt;Tuple&gt;(</div>
<div class="line">                range_c&lt;int, 2, 6&gt;</div>
<div class="line">            )</div>
<div class="line">        )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    group.by(comparing(decltype_), make&lt;Tuple&gt;(1, 2, 3, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, 4.4, 5.5))</div>
<div class="line">        == make&lt;Tuple&gt;(</div>
<div class="line">            make&lt;Tuple&gt;(1, 2, 3),</div>
<div class="line">            make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>),</div>
<div class="line">            make&lt;Tuple&gt;(4.4, 5.5)</div>
<div class="line">        )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a733fdb2e8686033466beea8323e53a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the last element of a non-empty sequence. </p>
<p>If the sequence is empty, a compile-time assertion is triggered. Otherwise, a copy of the original sequence with its last element removed is returned.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a733fdb2e8686033466beea8323e53a26">init</a>(make&lt;Tuple&gt;(1)) == make&lt;Tuple&gt;());</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a733fdb2e8686033466beea8323e53a26">init</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab6e88c5dd3f638a60c0a451ad6db95ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto intersperse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; z) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Insert a value between each pair of elements in a sequence. </p>
<p>Specifically, <code>intersperse([x1, x2, ..., xn], z)</code> is a sequence equivalent to <code>[x1, z, x2, z, x3, ..., xn-1, z, xn]</code>. If the sequence is empty or has a single element, then <code>intersperse</code> returns the sequence as-is.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence in which a value is interspersed.</td></tr>
    <tr><td class="paramname">z</td><td>The value to be interspersed in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#ab6e88c5dd3f638a60c0a451ad6db95ec">intersperse</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, 3.3)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#ab6e88c5dd3f638a60c0a451ad6db95ec">intersperse</a>(make&lt;Tuple&gt;(), <span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;());</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a788b65dd69bb016d647801718e840816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Partition a sequence based on a <code>predicate</code>. </p>
<p>Specifically, returns an unspecified <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> whose first element is a sequence of the elements satisfying the predicate, and whose second element is a sequence of the elements that do not satisfy the predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to be partitioned.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for each element <code>x</code> in the sequence and returning a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. If the result of <code>predicate</code> is true, then <code>x</code> is added to the sequence in the first component of the resulting <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>. Otherwise, <code>x</code> is added to the sequence in the second component.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a>(tuple_c&lt;int, 1, 2, 3, 4, 5, 6, 7&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % int_&lt;2&gt; != int_&lt;0&gt;;</div>
<div class="line">    })</div>
<div class="line">    ==</div>
<div class="line">    make_pair(</div>
<div class="line">        tuple_c&lt;int, 1, 3, 5, 7&gt;,</div>
<div class="line">        tuple_c&lt;int, 2, 4, 6&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a>(tuple_t&lt;void, int, float, char, double&gt;, trait&lt;std::is_floating_point&gt;)</div>
<div class="line">    ==</div>
<div class="line">    make_pair(</div>
<div class="line">        tuple_t&lt;float, double&gt;,</div>
<div class="line">        tuple_t&lt;void, int, char&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45ec7767d19eb7eaabb71ead3796a7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto permutations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a sequence of all the permutations of the given sequence. </p>
<p>Specifically, <code>permutations(xs)</code> is a sequence whose elements are permutations of the original sequence <code>xs</code>. The permutations are not guaranteed to be in any specific order. Also note that the number of permutations grows very rapidly as the length of the original sequence increases. The growth rate is <code>O(length(xs)!)</code>; with a sequence <code>xs</code> of length only 8, <code>permutations(xs)</code> contains over 40 000 elements!</p>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_permutation_of = curry&lt;2&gt;([](<span class="keyword">auto</span> xs, <span class="keyword">auto</span> perm) {</div>
<div class="line">    <span class="keywordflow">return</span> elem(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a>(xs), perm);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    all_of(</div>
<div class="line">        make&lt;Tuple&gt;(</div>
<div class="line">            make&lt;Tuple&gt;(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0),</div>
<div class="line">            make&lt;Tuple&gt;(<span class="charliteral">&#39;1&#39;</span>, 3.0, 2),</div>
<div class="line">            make&lt;Tuple&gt;(2, <span class="charliteral">&#39;1&#39;</span>, 3.0),</div>
<div class="line">            make&lt;Tuple&gt;(2, 3.0, <span class="charliteral">&#39;1&#39;</span>),</div>
<div class="line">            make&lt;Tuple&gt;(3.0, <span class="charliteral">&#39;1&#39;</span>, 2),</div>
<div class="line">            make&lt;Tuple&gt;(3.0, 2, <span class="charliteral">&#39;1&#39;</span>)</div>
<div class="line">        ),</div>
<div class="line">        is_permutation_of(make&lt;Tuple&gt;(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0))</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/permutations.ctime.png" alt="permutations.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a65295edabe2029007e7ecf640ae7bb0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_at</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; n, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the element at a given index from a sequence. </p>
<p><code>remove_at</code> returns a new sequence identical to the original, except that the element at the given index is removed. Specifically, <code>remove_at(n, [x0, ..., xn-1, xn, xn+1, ..., xm])</code> is a new sequence equivalent to <code>[x0, ..., xn-1, xn+1, ..., xm]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>An non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the index of the element to be removed from the sequence.</td></tr>
    <tr><td class="paramname">xs</td><td>A sequence from which an element is to be removed.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a65295edabe2029007e7ecf640ae7bb0b">remove_at</a>(int_&lt;2&gt;, make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u)) == make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 3u)</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/remove_at.ctime.png" alt="remove_at.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="aa597b243b348503860e1179065c508ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_at_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Sequence.html#a65295edabe2029007e7ecf640ae7bb0b">remove_at</a>(size_t&lt;n&gt;, forwarded(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>remove_at</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    remove_at_c&lt;2&gt;(make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u)) == make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, 3u)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4471413ccc3835db5e48658683b8aba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Reverse a sequence. </p>
<p>Specifically, <code>reverse(xs)</code> is a new sequence containing the same elements as <code>xs</code>, except in reverse order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to reverse.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a4471413ccc3835db5e48658683b8aba0">reverse</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(3.3, <span class="charliteral">&#39;2&#39;</span>, 1));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a37751569a9f7188ab64a2c288168b404"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scan = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> and return a list containing the successive reduction states. </p>
<p>Like <code>fold</code>, <code>scan</code> reduces a sequence to a single value. However, unlike <code>fold</code>, it builds up a sequence of the intermediary results computed along the way and returns that instead. In the same way as <code>fold</code> comes with several variants (left/right folds, with/without an initial state), <code>scan</code> offers the same 4 flavors. This method may be used to access all of these variants by using the different syntaxes documented below. Here is an overview: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a37751569a9f7188ab64a2c288168b404">scan</a>.left(xs, state, f) = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a37751569a9f7188ab64a2c288168b404">scan</a>.left(xs, f) = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a37751569a9f7188ab64a2c288168b404">scan</a> = scan.left</div>
<div class="line"></div>
<div class="line">scan.right(xs, state, f) = see below</div>
<div class="line">scan.right(xs, f) = see below</div>
</div><!-- fragment --><p>In the above, <code>xs</code> is the sequence to be folded, <code>state</code> is the optional initial accumulation state that can be provided, and <code>f</code> is a binary operation used to reduce the sequence.</p>
<p>When the sequence is empty, two things may arise. If an initial state was provided, a singleton list containing that state is returned. Otherwise, if no initial state was provided, an empty list is returned. In particular, unlike for <code>fold</code>, using <code>scan</code> on an empty sequence without an initial state is not an error.</p>
<h2>Left scans (<code>scan.left</code>)</h2>
<p><code>scan.left</code> is a left associative scan of a sequence. Specifically, the <code>i</code>th element of <code>scan.left([x1, ..., xn], state, f)</code> is equivalent to <code>fold.left([x1, ..., xi], state, f)</code>, with the no-state variant handled analogously. For example, consider this left fold on a short sequence: </p><div class="fragment"><div class="line">fold.left([x1, x2, x3], state, f) == f(f(f(state, x1), x2), x3)</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan.left</code> will be </p><div class="fragment"><div class="line">scan.left([x1, x2, x3], state, f) == [</div>
<div class="line">    state,</div>
<div class="line">    f(state, x1),</div>
<div class="line">    f(f(state, x1), x2),</div>
<div class="line">    f(f(f(state, x1), x2), x3)</div>
<div class="line">]</div>
</div><!-- fragment --><p>Similarly, consider this left fold (without an initial state) on a short sequence: </p><div class="fragment"><div class="line">fold.left([x1, x2, x3, x4], f) == f(f(f(x1, x2), x3), x4)</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan.left</code> will be </p><div class="fragment"><div class="line">scan.left([x1, x2, x3, x4], f) == [</div>
<div class="line">    x1,</div>
<div class="line">    f(x1, x2),</div>
<div class="line">    f(f(x1, x2), x3),</div>
<div class="line">    f(f(f(x1, x2), x3), x4)</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to fold from the left.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence. If no initial state is provided, <code>f</code> is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are both elements of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>scan</code> is equivalent to <code>scan.left</code>, so <code>scan(xs, f)</code> and <code>scan(xs, state, f)</code> are equivalent to <code>scan.left(xs, f)</code> and <code>scan.left(xs, state, f)</code> respectively. This is provided solely for convenience.</dd></dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> f = [=](<span class="keyword">auto</span> state, <span class="keyword">auto</span> element) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + to_string(state) + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// with initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(scan.left(make&lt;Tuple&gt;(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>), 1, f) == make&lt;Tuple&gt;(</div>
<div class="line">    1,</div>
<div class="line">    <span class="stringliteral">&quot;f(1, 2)&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;f(f(1, 2), 3)&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;f(f(f(1, 2), 3), 4)&quot;</span></div>
<div class="line">));</div>
<div class="line"></div>
<div class="line"><span class="comment">// without initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(scan.left(make&lt;Tuple&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), f) == make&lt;Tuple&gt;(</div>
<div class="line">    1,</div>
<div class="line">    <span class="stringliteral">&quot;f(1, 2)&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;f(f(1, 2), 3)&quot;</span></div>
<div class="line">));</div>
</div><!-- fragment --><h2>Right scans (<code>scan.right</code>)</h2>
<p><code>scan.right</code> is a right associative scan of a sequence. Specifically, the <code>i</code>th element of <code>scan.right([x1, ..., xn], state, f)</code> is equivalent to <code>fold.right([xi, ..., xn], state, f)</code>, with the no-state variant handled analogously. For example, consider this right fold on a short sequence: </p><div class="fragment"><div class="line">fold.right([x1, x2, x3], state, f) == f(x1, f(x2, f(x3, state)))</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan.right</code> will be </p><div class="fragment"><div class="line">scan.right([x1, x2, x3], state, f) == [</div>
<div class="line">    f(x1, f(x2, f(x3, state))),</div>
<div class="line">          f(x2, f(x3, state)),</div>
<div class="line">                f(x3, state),</div>
<div class="line">                      state</div>
<div class="line">]</div>
</div><!-- fragment --><p>Similarly, consider this right fold (without an initial state) on a short sequence: </p><div class="fragment"><div class="line">fold.right([x1, x2, x3, x4], f) == f(x1, f(x2, f(x3, x4)))</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan.left</code> will be </p><div class="fragment"><div class="line">scan.right([x1, x2, x3, x4], f) == [</div>
<div class="line">    f(x1, f(x2, f(x3, x4))),</div>
<div class="line">          f(x2, f(x3, x4)),</div>
<div class="line">                f(x3, x4),</div>
<div class="line">                      x4</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to fold from the right.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence. When no initial state is provided, <code>f</code> is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> f = [=](<span class="keyword">auto</span> element, <span class="keyword">auto</span> state) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + to_string(element) + <span class="stringliteral">&quot;, &quot;</span> + to_string(state) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// with initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(scan.right(make&lt;Tuple&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), 4, f) == make&lt;Tuple&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;f(1, f(2, f(3, 4)))&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;f(2, f(3, 4))&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;f(3, 4)&quot;</span>,</div>
<div class="line">    4</div>
<div class="line">));</div>
<div class="line"></div>
<div class="line"><span class="comment">// without initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(scan.right(make&lt;Tuple&gt;(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), f) == make&lt;Tuple&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;f(1, f(2, 3))&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;f(2, 3)&quot;</span>,</div>
<div class="line">    <span class="charliteral">&#39;3&#39;</span></div>
<div class="line">));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a18968c488a8b0cdc2697296024da9293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; from, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Extract a subsequence delimited by the given indices. </p>
<p>Specifically, <code>slice(xs, from, to)</code> is a sequence containing all the elements of <code>xs</code> at indices in the half-open interval delimited by [<code>from</code>, <code>to</code>). Note that the indices are 0-based. For this operation to be valid, <code>xs</code> must contain at least <code>to + 1</code> elements, and it must be true that <code>from &lt;= to</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to slice.</td></tr>
    <tr><td class="paramname">from</td><td>The index of the first element in the slice. <code>from</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type.</td></tr>
    <tr><td class="paramname">to</td><td>One-past the index of the last element in the slice. <code>to</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type such that <code>from &lt;= to</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a18968c488a8b0cdc2697296024da9293">slice</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, type&lt;float&gt;), int_&lt;1&gt;, int_&lt;3&gt;)</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afa204f71aac9f461d8574653295c67ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t from, std::size_t to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Sequence.html#a18968c488a8b0cdc2697296024da9293">slice</a>(forwarded(xs), size_t&lt;from&gt;, size_t&lt;to&gt;);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>slice</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    slice_c&lt;1, 3&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, type&lt;float&gt;))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a58c1454689bf6d2264bc428dc1d039db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a sequence, optionally based on a custom <code>predicate</code>. </p>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> and an optional predicate (by default <code>less</code>), <code>sort</code> returns a new sequence containing the same elements as the original, except they are ordered in such a way that if <code>x</code> comes before <code>y</code> in the sequence, then either <code>predicate(x, y)</code> is true, or both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false.</p>
<p>Also note that the sort is guaranteed to be stable. Hence, if <code>x</code> comes before <code>y</code> in the original sequence and both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false, then <code>x</code> will come before <code>y</code> in the resulting sequence.</p>
<p>If no predicate is provided, the elements in the sequence must all be compile-time <code><a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code>.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> <code>s</code> of data type <code>S(T)</code>, a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a predicate \( pred : T \times T \to Bool \), <code>sort</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathrm{sort} : S(T) \times (T \times T \to Bool) \to S(T) \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>. The signature is then </p><p class="formulaDsp">
\[ \mathrm{sort} : S(T) \to S(T) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to sort.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code> for two elements <code>x</code> and <code>y</code> of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> is to be considered <em>less</em> than <code>y</code>, i.e. whether <code>x</code> should appear <em>before</em> <code>y</code> in the resulting sequence. More specifically, <code>predicate</code> must define a <a href="http://en.wikipedia.org/wiki/Strict_weak_ordering">strict weak ordering</a> on the elements of the sequence. In the current version of the library, also note that <code>predicate</code> must return a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> when called with any two elements of the sequence. When the predicate is not specified, this defaults to <code>less</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>sort.by</code>) </h2>
<p><code>sort</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>.by(predicate) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>sort(-, predicate)</code> denotes the partial application of <code>sort</code> to <code>predicate</code>.</p>
<h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>sort</code> are tag-dispatched methods, and hence they can be customized independently. One reason for this is that some structures are able to provide a much more efficient implementation of <code>sort</code> when the <code>less</code> predicate is used. Here is how the different versions of <code>sort</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">sort_impl&lt;data type of xs&gt;::apply</a>(xs)</div>
<div class="line">sort(xs, pred) -&gt; sort_pred_impl&lt;data type of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div>
</div><!-- fragment --><p>Also note that <code>sort.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>sort</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"></div>
<div class="line"><span class="comment">// without a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(make&lt;Tuple&gt;(1_c, -2_c, 3_c, 0_c)) ==</div>
<div class="line">        make&lt;Tuple&gt;(-2_c, 0_c, 1_c, 3_c)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// with a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(make&lt;Tuple&gt;(1_c, -2_c, 3_c, 0_c), greater) ==</div>
<div class="line">        make&lt;Tuple&gt;(3_c, 1_c, 0_c, -2_c)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> tuples = make&lt;Tuple&gt;(</div>
<div class="line">    make&lt;Tuple&gt;(2_c, <span class="charliteral">&#39;x&#39;</span>, <span class="keyword">nullptr</span>),</div>
<div class="line">    make&lt;Tuple&gt;(1_c, std::string{<span class="stringliteral">&quot;foobar&quot;</span>}, int_&lt;4&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    sort.by(ordering(head), tuples)</div>
<div class="line">        == make&lt;Tuple&gt;(</div>
<div class="line">            make&lt;Tuple&gt;(1_c, std::string{<span class="stringliteral">&quot;foobar&quot;</span>}, int_&lt;4&gt;),</div>
<div class="line">            make&lt;Tuple&gt;(2_c, <span class="charliteral">&#39;x&#39;</span>, <span class="keyword">nullptr</span>)</div>
<div class="line">        )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab663fc84c23656a41d4dfcb586f0085c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto span</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a sequence satisfying a predicate, and the rest of the sequence. </p>
<p>The first component of the returned <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a sequence for which all elements satisfy the given predicate. The second component of the returned <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a sequence containing the remainder of the argument. Both or either sequences may be empty, depending on the input argument. More specifically, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, predicate) == make_pair(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(xs, predicate),</div>
<div class="line">                                 drop_while(xs, predicate))</div>
</div><!-- fragment --><p> except that <code>make_pair</code> may be an arbitrary <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to break into two parts.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>. In the current implementation of the library,</code>predicate<code>has to return a</code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> Logical`.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> xs = make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;4&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;3&gt;)</div>
<div class="line">    ==</div>
<div class="line">    make_pair(make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;), make&lt;Tuple&gt;(int_&lt;3&gt;, int_&lt;4&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;0&gt;)</div>
<div class="line">    ==</div>
<div class="line">    make_pair(make&lt;Tuple&gt;(), xs)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; int_&lt;5&gt;)</div>
<div class="line">    ==</div>
<div class="line">    make_pair(xs, make&lt;Tuple&gt;())</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65b5d2d363fb5e2d444e8bfe6bc712c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto subsequence</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; indices) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns the elements at the given indices of a sequence. </p>
<p>Given a (finite) and compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> containing indices, <code>subsequence</code> returns a new <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> of the elements of the original sequence that appear at those indices. The indices must be <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s of an unsigned integral type. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a65b5d2d363fb5e2d444e8bfe6bc712c7">subsequence</a>([x1, ..., xn], [i1, ..., ik]) == [xi1, ..., xik]</div>
</div><!-- fragment --><p>In particular, note that indices do not have to be ordered or sequential in any particular way, and they may contain duplicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence from which a subsequence is extracted.</td></tr>
    <tr><td class="paramname">indices</td><td>A compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> holding <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s of an unsigned integral type, and whose linearization represents the indices of the elements in the returned sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> letters = to&lt;Tuple&gt;(range_c&lt;char, &#39;a&#39;, &#39;z&#39;&gt;);</div>
<div class="line">constexpr <span class="keyword">auto</span> indices = to&lt;Tuple&gt;(make&lt;Range&gt;(int_&lt;0&gt;, length(letters)));</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> even_indices = filter(indices, [](<span class="keyword">auto</span> n) {</div>
<div class="line">    <span class="keywordflow">return</span> n % uint&lt;2&gt; == uint&lt;0&gt;;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a65b5d2d363fb5e2d444e8bfe6bc712c7">subsequence</a>(letters, even_indices) == tuple_c&lt;<span class="keywordtype">char</span>,</div>
<div class="line">        <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;k&#39;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="charliteral">&#39;y&#39;</span></div>
<div class="line">    &gt;</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c20028c5115dcf38063d322f27b4ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first <code>n</code> elements of a sequence. </p>
<p>Broadly speaking, <code>take(n, xs)</code> is a new sequence containing the first <code>n</code> elements of <code>xs</code>, in the same order. <code>n</code> must be a <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> of an unsigned integral type. However, there are different ways of calling <code>take</code>, which correspond to different policies in case the length of the sequence is less than <code>n</code>: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(n, xs)         = <a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.at_most(n, xs)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.at_most(n, xs) = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.exactly(n, xs) = see below</div>
</div><!-- fragment --><p>In case <code>length(xs) &lt; n</code>, the <code>take.at_most</code> variant will simply take the whole sequence, without failing. In contrast, the <code>take.exactly</code> variant assumes that <code>length(xs) &gt;= n</code>, which makes it possible to perform some optimizations.</p>
<p>All of the different variants are tag-dispatched methods that can be overriden. Here is how each variant is tag-dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.at_most       -&gt;  take_at_most_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>.exactly       -&gt;  take_exactly_impl</div>
</div><!-- fragment --><p> <code>take</code> is not tag dispatched, because it is just an alias to <code>take.at_most</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the number of elements to keep in the resulting sequence. If <code>length(xs) &lt; n</code>, the exact behavior is determined by the chosen policy (either <code>take.at_most</code> or <code>take.exactly</code>).</td></tr>
    <tr><td class="paramname">xs</td><td>The sequence to take the elements from.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(0_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;());</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(1_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(2_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(3_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(4_c, make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/take.ctime.png" alt="take.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a63f9ab281c8e979adfd7f6678383c46b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(size_t&lt;n&gt;, forwarded(xs));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>take</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(take_c&lt;2&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27aa67fa9ffc3d89b23a6dce018013d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_until</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Take elements from a sequence until the <code>predicate</code> is satisfied. </p>
<p>Specifically, <code>take_until</code> returns a new sequence containing the longest prefix of <code>xs</code> in which all elements do not satisfy the predicate. This is effectively equivalent to <code>take_while</code> with a negated predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to take the elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether the resulting sequence should stop at the element before <code>x</code>. In the current version of the library, <code>predicate</code> has to return a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a>(tuple_c&lt;int, 3, 2, 1, 0&gt;, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 2_c)</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 3, 2&gt;</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/take_until.ctime.png" alt="take_until.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a86916c5c62a42f01f85450b366ef6eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_while</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Take elements from a sequence while the <code>predicate</code> is satisfied. </p>
<p>Specifically, <code>take_while</code> returns a new sequence containing the longest prefix of <code>xs</code> in which all the elements satisfy the given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to take elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should be included in the resulting sequence. In the current version of the library, <code>predicate</code> has to return a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(tuple_c&lt;int, 0, 1, 2, 3&gt;, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 2_c)</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 0, 1&gt;</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/take_while.ctime.png" alt="take_while.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a08bed7da3a1bc6d0e8d11e5440d879c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unfold = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dual operation to <code>fold</code> for sequences. </p>
<p>While <code>fold</code> reduces a structure to a summary value, <code>unfold</code> builds a sequence from a seed value and a function. As explained in the documentation for <code>fold</code>, there are several different flavors of folds. In particular, there are folds which are left associative and folds which are right associative. Similarly, there are two versions of <code>unfold</code>; one which builds the sequence from the left, and another one which builds the sequence from the right. Those two variants are accessible through <code>unfold&lt;S&gt;.left</code> and <code>unfold&lt;S&gt;.right</code>, respectively. Also note that for convenience, <code>unfold&lt;S&gt;</code> is an alias to <code>unfold&lt;S&gt;.left</code>.</p>
<h3>Fun fact</h3>
<p>In some cases, <code>unfold</code> can undo a <code>fold</code> operation: </p><div class="fragment"><div class="line">unfold&lt;S&gt;.left(fold.left(xs, z, f), g) == xs</div>
<div class="line">unfold&lt;S&gt;.right(fold.right(xs, z, f), g) == xs</div>
</div><!-- fragment --><p>if the following holds </p><div class="fragment"><div class="line">g(f(x, y)) == just(make_pair(x, y))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> data type <code>S</code>, an initial value <code>init</code> of data type <code>I</code>, an arbitrary <a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a> <code>P</code> and a function \( f : I \to P(I, T) \), <code>unfold&lt;S&gt;.left</code> has the following signature: </p><p class="formulaDsp">
\[ \mathrm{unfold}_S.\mathrm{left} : I \times (I \to P(I, T)) \to S(T) \]
</p>
<p>Given a function \( f : I \to P(T, I) \) instead, <code>unfold&lt;S&gt;.right</code> has the following signature: </p><p class="formulaDsp">
\[ \mathrm{unfold}_S.\mathrm{right} : I \times (I \to P(T, I)) \to S(T) \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The data type of the sequence to build up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>An initial value to build the sequence from.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(init)</code>, where <code>init</code> is an initial value, and returning<ol type="1">
<li><code>nothing</code> if it is done producing the sequence.</li>
<li>otherwise, <code>just(make_pair(init, x))</code> for <code>unfold.left</code> and <code>just(make_pair(x, init))</code> for <code>unfold.right</code>, where <code>init</code> is the new initial value used in the next call to <code>f</code> and <code>x</code> is an element to be appended to the resulting sequence. Also note that <code>make_pair</code> may actually be replaced by any <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    unfold&lt;Tuple&gt;.left(int_&lt;10&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;,</div>
<div class="line">            nothing,</div>
<div class="line">            just(make_pair(x - int_&lt;1&gt;, x))</div>
<div class="line">        );</div>
<div class="line">    })</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    unfold&lt;Tuple&gt;.right(int_&lt;10&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;,</div>
<div class="line">            nothing,</div>
<div class="line">            just(make_pair(x, x - int_&lt;1&gt;))</div>
<div class="line">        );</div>
<div class="line">    })</div>
<div class="line">    ==</div>
<div class="line">    tuple_c&lt;int, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&gt;</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe5308d966fbf95d317511a706d6d20a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unzip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Unzip a sequence of sequences. </p>
<p><code>unzip</code> can undo a <code>zip</code> operation. Specifically, it takes a sequence of the form </p><div class="fragment"><div class="line">[s1, s2, ..., sn]</div>
</div><!-- fragment --><p> where each <code>si</code> is a sequence, and returns a sequence equivalent to <code>zip(s1, s2, ..., sn)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A sequence of sequences to unzip.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), make&lt;Tuple&gt;(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;4&#39;</span>), make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 5.5), make&lt;Tuple&gt;(3.3, 6))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), make&lt;Tuple&gt;(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6, <span class="stringliteral">&quot;ignored&quot;</span>)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;4&#39;</span>), make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 5.5), make&lt;Tuple&gt;(3.3, 6))</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23b6ac9e78577d70b9108a80e6b1534c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip one sequence or more, either with a given function or into a <a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>. </p>
<p>In a general setting, zipping several sequences with a function refers to the following operation. Given <code>n</code> sequences <code>s1, ..., sn</code> and a function <code>f</code> that takes <code>n</code> arguments, zipping produces a sequence whose i-th element is <code>f(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the i-th element of the k-th sequence passed as an argument. In other words, it produces a sequence of the form </p><div class="fragment"><div class="line">[</div>
<div class="line">    f(s1[0], ..., sn[0]),</div>
<div class="line">    f(s1[1], ..., sn[1]),</div>
<div class="line">    ...</div>
<div class="line">    f(s1[M], ..., sn[M])</div>
<div class="line">]</div>
</div><!-- fragment --><p> , where <code>M</code> is usually the length of the shortest sequence. As this suggests, there are several different ways of zipping that one might want; zip with a function, zip without a function, zip up to the shortest sequence, zip up to the longest sequence or assume all the sequences are of the same size. In Hana, all these different ways of zipping are provided, except for the "up to the longest sequence" one.</p>
<blockquote class="doxtable">
<h4>Rationale for not providing a <code>zip.longest</code> variant</h4>
<p>It would require either (1) padding the shortest sequences with an arbitrary object, or (2) pad the shortest sequences with an object provided by the user when calling <code>zip.longest</code>. Since there is no requirement that all the zipped sequences have elements of similar types, there is no way to provide a single consistent padding object in all cases. A tuple of padding objects should be provided, but I find it perhaps too complicated to be worth it for now. If you need this functionality, open a GitHub issue. </p>
</blockquote>
<p>The <code>zip</code> method is actually a function object that can be called in several different ways, each of them providing a slightly different kind of zipping. Here are the different ways of calling <code>zip</code>: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(s1, ..., sn)         = <a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest(s1, ..., sn)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.with(f, s1, ..., sn) = <a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest.with(f, s1, ..., sn)</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest(s1, ..., sn)         = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest.with(f, s1, ..., sn) = see below</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe(s1, ..., sn)         = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe.with(f, s1, ..., sn) = see below</div>
</div><!-- fragment --><p>First, one sees that calling <code>zip</code> or <code>zip.with</code> is equivalent to calling <code>zip.shortest</code> or <code>zip.shortest.with</code>, respectively. The <code>shortest</code> variant signifies that the returned sequence should stop when the shortest input sequence is exhausted, which is the usual behavior for <code>zip</code> operations.</p>
<p>Then, there are also the <code>zip.unsafe</code> and <code>zip.unsafe.with</code> variants, which both assume that all the sequences are of the same size. This allows the library to perform some optimizations. If you know that all the sequences you are about to zip are of the same length, you should use these variants.</p>
<p>Finally, the <code>with</code> variants offer the possibility of providing a custom function to do the zipping, as was explained above. The non-<code>with</code> variants, which do not accept a custom function, will zip using a tuple. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.*(s1, ..., sn) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.*.with(make&lt;Tuple&gt;, s1, ..., sn)</div>
<div class="line">                   == [</div>
<div class="line">                        make&lt;Tuple&gt;(s1[0], ..., sn[0]),</div>
<div class="line">                        make&lt;Tuple&gt;(s1[1], ..., sn[1]),</div>
<div class="line">                        ...</div>
<div class="line">                        make&lt;Tuple&gt;(s1[M], ..., sn[M])</div>
<div class="line">                   ]</div>
</div><!-- fragment --><p>All of the different zipping variants are tag-dispatched methods that can be overridden. Here is how each variant is tag-dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest       -&gt;  zip_shortest_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.shortest.with  -&gt;  zip_shortest_with_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe         -&gt;  zip_unsafe_impl</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>.unsafe.with    -&gt;  zip_unsafe_with_impl</div>
</div><!-- fragment --><p> <code>zip</code> and <code>zip.with</code> are not tag dispatched, because they are just aliases to <code>zip.shortest</code> and <code>zip.shortest.with</code>, respectively. Also note that all the sequences must have the same data type, and only the data type of the first one is used for tag-dispatching.</p>
<dl class="section note"><dt>Note</dt><dd>At least one sequence must be provided. Otherwise, it is an error.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;a&#39;</span>), make&lt;Tuple&gt;(2, 3.3))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2), make&lt;Tuple&gt;(<span class="charliteral">&#39;a&#39;</span>, 3.3))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;a&#39;</span>), make&lt;Tuple&gt;(2, 3.3), make&lt;Tuple&gt;(3, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2, 3), make&lt;Tuple&gt;(<span class="charliteral">&#39;a&#39;</span>, 3.3, <span class="charliteral">&#39;c&#39;</span>))</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/sequence/zip_with.ctime.png" alt="zip_with.ctime.png"/>
</div>
 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Sequence.html">Sequence</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
