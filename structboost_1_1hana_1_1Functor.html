<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: boost::hana::Functor&lt; F &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="https://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="https://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="https://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/9029554299b379bd015d102ecdcc5ff455469b6b/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/implementation-defined/g, "implementation-defined".link("index.html#tutorial-glossary-implementation_defined").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('boostorg', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/boostorg/hana/" + sha + "/release/clang-3.6.2/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Functor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1Functor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Functor&lt; F &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename F&gt;<br />
struct boost::hana::Functor&lt; F &gt;</h3>

<p>The <code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> concept represents types that can be mapped over. </p>
<p>Intuitively, a <a href="http://en.wikipedia.org/wiki/Functor">Functor</a> is some kind of box that can hold generic data and map a function over this data to create a new, transformed box. Because we are only interested in mapping a function over the contents of a black box, the only real requirement for being a functor is to provide a function which can do the mapping, along with a couple of guarantees that the mapping is well-behaved. Those requirements are made precise in the laws below. The pattern captured by <code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> is very general, which makes it widely useful. A lot of objects can be made <code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>s in one way or another, the most obvious example being sequences with the usual mapping of the function on each element. While this documentation will not go into much more details about the nature of functors, the <a href="https://wiki.haskell.org/Typeclassopedia#Functor">Typeclassopedia</a> is a nice Haskell-oriented resource for such information.</p>
<p>Functors are parametric data types which are parameterized over the data type of the objects they contain. Like everywhere else in Hana, this parametricity is only at the documentation level and it is not enforced.</p>
<p>In this library, the mapping function is called <code>transform</code> after the <code>std::transform</code> algorithm, but other programming languages have given it different names (usually <code>map</code>).</p>
<dl class="section note"><dt>Note</dt><dd>The word <em>functor</em> comes from functional programming, where the concept has been used for a while, notably in the Haskell programming language. Haskell people borrowed the term from <a href="http://en.wikipedia.org/wiki/Category_theory">category theory</a>, which, broadly speaking, is a field of mathematics dealing with abstract structures and transformations between those structures.</dd></dl>
<h2>Minimal complete definitions </h2>
<ol type="1">
<li><code>transform</code><br />
When <code>transform</code> is specified, <code>adjust_if</code> is defined analogously to <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, pred, f) = <a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, [](x){</div>
<div class="line">    <span class="keywordflow">if</span> pred(x) then f(x) else x</div>
<div class="line">})</div>
</div><!-- fragment --></li>
<li><code>adjust_if</code><br />
When <code>adjust_if</code> is specified, <code>transform</code> is defined analogously to <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, f) = <a class="code" href="structboost_1_1hana_1_1Functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<span class="keyword">true</span>), f)</div>
</div><!-- fragment --></li>
</ol>
<h2>Laws </h2>
<p>Let <code>xs</code> be a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> with tag <code>F(A)</code>, \( f : A \to B \) and \( g : B \to C \). The following laws must be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, <span class="keywordtype">id</span>) == xs</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, f)) == <a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(<a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, f), g)</div>
</div><!-- fragment --><p> The first line says that mapping the identity function should not do anything, which precludes the functor from doing something nasty behind the scenes. The second line states that mapping the composition of two functions is the same as mapping the first function, and then the second on the result. While the usual functor laws are usually restricted to the above, this library includes other convenience methods and they should satisfy the following equations. Let <code>xs</code> be a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> with tag <code>F(A)</code>, \( f : A \to A \), \( \mathrm{pred} : A \to \mathrm{Bool} \) for some <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code>, and <code>oldval</code>, <code>newval</code>, <code>value</code> objects of tag <code>A</code>. Then, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#ac27a1807b60b8fa59e6c618cb8ca749f">adjust</a>(xs, value, f) == <a class="code" href="structboost_1_1hana_1_1Functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, equal.to(value), f)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, pred, f) == <a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, [](x){</div>
<div class="line">    <span class="keywordflow">if</span> pred(x) then f(x) else x</div>
<div class="line">})</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a>(xs, pred, value) == <a class="code" href="structboost_1_1hana_1_1Functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, pred, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(value))</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#a72e73dcc09699c619bcfb006029a8967">replace</a>(xs, oldval, newval) == <a class="code" href="structboost_1_1hana_1_1Functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a>(xs, equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(oldval), newval)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Functor.html#a35025921d0fb75c28c2411d207a0da5e">fill</a>(xs, value)             == <a class="code" href="structboost_1_1hana_1_1Functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(true), value)</div>
</div><!-- fragment --><p> The default definition of the methods will satisfy these equations.</p>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code></p>
<h2>Structure-preserving functions for Functors </h2>
<p>A mapping between two functors which also preserves the functor laws is called a natural transformation (the term comes from category theory). A natural transformation is a function <code>f</code> from a functor <code>F</code> to a functor <code>G</code> such that for every other function <code>g</code> with an appropriate signature and for every object <code>xs</code> of tag <code>F(X)</code>, </p><div class="fragment"><div class="line">f(<a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, g)) == <a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(f(xs), g)</div>
</div><!-- fragment --><p>There are several examples of such transformations, like <code>to&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code> when applied to an optional value. Indeed, for any function <code>g</code> and <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code> <code>opt</code>, </p><div class="fragment"><div class="line">to&lt;tuple_tag&gt;(<a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(opt, g)) == <a class="code" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(to&lt;tuple_tag&gt;(opt), g)</div>
</div><!-- fragment --><p>Of course, natural transformations are not limited to the <code>to&lt;...&gt;</code> functions. However, note that any conversion function between Functors should be natural for the behavior of the conversion to be intuitive. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Functor.html#ac27a1807b60b8fa59e6c618cb8ca749f">adjust</a></td></tr>
<tr class="memdesc:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on all the elements of a structure that compare equal to some value.  <a href="#ac27a1807b60b8fa59e6c618cb8ca749f">More...</a><br /></td></tr>
<tr class="separator:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88457a3be4c40dfe3dbf1a0e3f52480"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a></td></tr>
<tr class="memdesc:af88457a3be4c40dfe3dbf1a0e3f52480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on all the elements of a structure satisfying a predicate.  <a href="#af88457a3be4c40dfe3dbf1a0e3f52480">More...</a><br /></td></tr>
<tr class="separator:af88457a3be4c40dfe3dbf1a0e3f52480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35025921d0fb75c28c2411d207a0da5e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Functor.html#a35025921d0fb75c28c2411d207a0da5e">fill</a></td></tr>
<tr class="memdesc:a35025921d0fb75c28c2411d207a0da5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure with a fixed value.  <a href="#a35025921d0fb75c28c2411d207a0da5e">More...</a><br /></td></tr>
<tr class="separator:a35025921d0fb75c28c2411d207a0da5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e73dcc09699c619bcfb006029a8967"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Functor.html#a72e73dcc09699c619bcfb006029a8967">replace</a></td></tr>
<tr class="memdesc:a72e73dcc09699c619bcfb006029a8967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure that compare equal to some <code>value</code> with some new fixed value.  <a href="#a72e73dcc09699c619bcfb006029a8967">More...</a><br /></td></tr>
<tr class="separator:a72e73dcc09699c619bcfb006029a8967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d42b572f43016f929b5729c2533f5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a></td></tr>
<tr class="memdesc:ab57d42b572f43016f929b5729c2533f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure satisfying a <code>predicate</code> with a fixed value.  <a href="#ab57d42b572f43016f929b5729c2533f5">More...</a><br /></td></tr>
<tr class="separator:ab57d42b572f43016f929b5729c2533f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3140eb3e41d54e2370eb19ee6b043c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a></td></tr>
<tr class="memdesc:a3a3140eb3e41d54e2370eb19ee6b043c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a function over a <code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>.  <a href="#a3a3140eb3e41d54e2370eb19ee6b043c">More...</a><br /></td></tr>
<tr class="separator:a3a3140eb3e41d54e2370eb19ee6b043c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="ac27a1807b60b8fa59e6c618cb8ca749f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto adjust</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; value, <span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Apply a function on all the elements of a structure that compare equal to some value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> and <code>U</code> a type that can be compared with <code>T</code>'s, the signature is \( \mathtt{adjust} : F(T) \times U \times (T \to T) \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to adjust with <code>f</code>.</td></tr>
    <tr><td class="paramname">value</td><td>An object that is compared with each element <code>x</code> of the structure. Elements of the structure that compare equal to <code>value</code> are adjusted with the <code>f</code> function.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on the element(s) of the structure that compare equal to <code>value</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="adjust_8hpp.html">boost/hana/adjust.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negate = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> -x;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::adjust(hana::make_tuple(1, 4, 9, 2, 3, 4), 4, negate)</div>
<div class="line">        ==</div>
<div class="line">        hana::make_tuple(1, -4, 9, 2, 3, -4)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af88457a3be4c40dfe3dbf1a0e3f52480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto adjust_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; pred, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Apply a function on all the elements of a structure satisfying a predicate. </p>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a>, a predicate <code>pred</code> and a function <code>f</code>, <code>adjust_if</code> will <em>adjust</em> the elements of the <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> that satisfy the predicate with the function <code>f</code>. In other words, <code>adjust_if</code> will return a new <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> equal to the original one, except that the elements satisfying the predicate will be transformed with the given function. Elements for which the predicate is not satisfied are left untouched, and they are kept as-is in the resulting <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a>.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> <code>F</code> and a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code>, the signature is \( \mathtt{adjust_if} : F(T) \times (T \to Bool) \times (T \to T) \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to adjust with <code>f</code>.</td></tr>
    <tr><td class="paramname">pred</td><td>A function called as <code>pred(x)</code> for each element of the <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a>, and returning whether <code>f</code> should be applied on that element.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on the element(s) of the <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> that satisfy the predicate.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="adjust__if_8hpp.html">boost/hana/adjust_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negative = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x &lt; 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negate = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> -x;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::adjust_if(hana::make_tuple(-3, -2, -1, 0, 1, 2, 3), negative, negate)</div>
<div class="line">                ==</div>
<div class="line">        hana::make_tuple(3, 2, 1, 0, 1, 2, 3)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a35025921d0fb75c28c2411d207a0da5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fill</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; value) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Replace all the elements of a structure with a fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a>, the signature is \( \mathtt{fill} : F(T) \times U \to F(U) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fill with a <code>value</code>.</td></tr>
    <tr><td class="paramname">value</td><td>A value by which every element <code>x</code> of the structure is replaced, unconditionally.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fill_8hpp.html">boost/hana/fill.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    static_assert(</div>
<div class="line">        hana::fill(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="keyword">nullptr</span>), <span class="charliteral">&#39;x&#39;</span>)</div>
<div class="line">            ==</div>
<div class="line">        hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>)</div>
<div class="line">    , <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::fill(hana::nothing, <span class="charliteral">&#39;x&#39;</span>) == hana::nothing);</div>
<div class="line">    static_assert(hana::fill(hana::just(<span class="charliteral">&#39;y&#39;</span>), <span class="charliteral">&#39;x&#39;</span>) == hana::just(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a72e73dcc09699c619bcfb006029a8967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto replace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; oldval, <span class="keyword">auto</span>&amp;&amp; newval) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Replace all the elements of a structure that compare equal to some <code>value</code> with some new fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> and <code>U</code> a type that can be compared with <code>T</code>, the signature is \( \mathtt{replace} : F(T) \times U \times T \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to replace elements of.</td></tr>
    <tr><td class="paramname">oldval</td><td>An object compared with each element of the structure. Elements of the structure that compare equal to <code>oldval</code> are replaced by <code>newval</code> in the new structure.</td></tr>
    <tr><td class="paramname">newval</td><td>A value by which every element <code>x</code> of the structure that compares equal to <code>oldval</code> is replaced.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="replace_8hpp.html">boost/hana/replace.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::replace(hana::make_tuple(1, 1, 1, 2, 3, 1, 4, 5), 1, 0)</div>
<div class="line">            ==</div>
<div class="line">    hana::make_tuple(0, 0, 0, 2, 3, 0, 4, 5)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab57d42b572f43016f929b5729c2533f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto replace_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; value) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Replace all the elements of a structure satisfying a <code>predicate</code> with a fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> and <code>Bool</code> a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, the signature is \( \mathtt{replace_if} : F(T) \times (T \to Bool) \times T \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to replace elements of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for element(s) <code>x</code> of the structure and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should be replaced by <code>value</code>.</td></tr>
    <tr><td class="paramname">value</td><td>A value by which every element <code>x</code> of the structure for which <code>predicate</code> returns a true-valued <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> is replaced.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="replace__if_8hpp.html">boost/hana/replace_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negative = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x &lt; 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::replace_if(hana::make_tuple(-3, -2, -1, 0, 1, 2, 3), negative, 0)</div>
<div class="line">                ==</div>
<div class="line">        hana::make_tuple(0, 0, 0, 0, 1, 2, 3)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3a3140eb3e41d54e2370eb19ee6b043c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto transform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Map a function over a <code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a>, the signature is \( \mathtt{transform} : F(T) \times (T \to U) \to F(U) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to map <code>f</code> over.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on element(s) <code>x</code> of the structure, and returning a new value to replace <code>x</code> in the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::transform(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>, std::string{<span class="stringliteral">&quot;67&quot;</span>}), to_string)</div>
<div class="line">                ==</div>
<div class="line">        hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;345&quot;</span>, <span class="stringliteral">&quot;67&quot;</span>)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::transform(hana::nothing, to_string) == hana::nothing);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::transform(hana::just(123), to_string) == hana::just(<span class="stringliteral">&quot;123&quot;</span>s));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::transform(hana::tuple_t&lt;<span class="keywordtype">void</span>, <span class="keywordtype">int</span>(), <span class="keywordtype">char</span>[10]&gt;, hana::template_&lt;std::add_pointer_t&gt;)</div>
<div class="line">                ==</div>
<div class="line">        hana::tuple_t&lt;<span class="keywordtype">void</span>*, <span class="keywordtype">int</span>(*)(), <span class="keywordtype">char</span>(*)[10]&gt;</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.transform.compile.json"> </div> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Functor.html">Functor</a></li>
  </ul>
</div>
</body>
</html>
