<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Functor Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_functor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_functor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Functor Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> concept represents types that can be mapped over. </p>
<p>Intuitively, a <a href="http://en.wikipedia.org/wiki/Functor">Functor</a> is some kind of box that can hold generic data and map a function over this data to create a new, transformed box. Because we are only interested in mapping a function over the contents of a black box, the only real requirement for being a functor is to provide a function which can do the mapping, along with a couple of guarantees that the mapping is well-behaved. Those requirements are made precise in the laws below. The pattern captured by <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> is very general, which makes it widely useful. A lot of objects can be made <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>s in one way or another, the most obvious example being sequences with the usual mapping of the function on each element.</p>
<p>Functors are parametric data types which are parameterized over the data type of the objects they contain. Like everywhere else in Hana, this parametricity is only at the documentation level and it is not enforced.</p>
<p>In this library, the mapping function is called <code>transform</code> after the <code>std::transform</code> algorithm, but other programming languages have given it different names (usually <code>map</code>).</p>
<dl class="section note"><dt>Note</dt><dd>The word <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> comes from functional programming, where the concept has been used for a while, notably in the Haskell programming language. Haskell people borrowed the term from <a href="http://en.wikipedia.org/wiki/Category_theory">category theory</a>, which, broadly speaking, is a field of mathematics dealing with abstract structures and transformations between those structures.</dd></dl>
<h2>Laws </h2>
<p>Let <code>xs</code> be a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> of data type <code>F(A)</code>, \( f : A \to B \) and \( g : B \to C \). The following laws must be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, <span class="keywordtype">id</span>) == xs</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, f)) == <a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(<a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, f), g)</div>
</div><!-- fragment --><p> The first line says that mapping the identity function should not do anything, which precludes the functor from doing something nasty behind the scenes. The second line states that mapping the composition of two functions is the same as mapping the first function, and then the second on the result. While the usual functor laws are usually restricted to the above, this library includes other convenience methods and they should satisfy the following equations. Let <code>xs</code> be a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> of data type <code>F(A)</code>, \( f : A \to A \), \( \mathrm{pred} : A \to \mathrm{Bool} \) for some <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code>, and <code>oldval</code>, <code>newval</code>, <code>value</code> objects of data type <code>A</code>. Then, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#ac27a1807b60b8fa59e6c618cb8ca749f">adjust</a>(xs, value, f) == <a class="code" href="structboost_1_1hana_1_1_functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, equal.to(value), f)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, pred, f) == <a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, [](x){</div>
<div class="line">    <span class="keywordflow">if</span> pred(x) then f(x) else x</div>
<div class="line">})</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a>(xs, pred, value) == <a class="code" href="structboost_1_1hana_1_1_functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, pred, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(value))</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#a72e73dcc09699c619bcfb006029a8967">replace</a>(xs, oldval, newval) == <a class="code" href="structboost_1_1hana_1_1_functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a>(xs, equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(oldval), newval)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#a35025921d0fb75c28c2411d207a0da5e">fill</a>(xs, value)             == <a class="code" href="structboost_1_1hana_1_1_functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(true), value)</div>
</div><!-- fragment --><p> The default definition of the methods will satisfy these equations.</p>
<h2>Minimal complete definitions </h2>
<ol type="1">
<li><code>transform</code><br />
When <code>transform</code> is specified, <code>adjust_if</code> is defined analogously to <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, pred, f) = <a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, [](x){</div>
<div class="line">    <span class="keywordflow">if</span> pred(x) then f(x) else x</div>
<div class="line">})</div>
</div><!-- fragment --></li>
<li><code>adjust_if</code><br />
When <code>adjust_if</code> is specified, <code>transform</code> is defined analogously to <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(xs, f) = <a class="code" href="structboost_1_1hana_1_1_functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<span class="keyword">true</span>), f)</div>
</div><!-- fragment --></li>
</ol>
<h2>Structure-preserving functions for Functors </h2>
<p>A mapping between two functors which also preserves the functor laws is called a natural transformation (the term comes from category theory).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Grok and then document natural transformations.</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a3a3140eb3e41d54e2370eb19ee6b043c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a></td></tr>
<tr class="memdesc:a3a3140eb3e41d54e2370eb19ee6b043c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a function over a <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>.  <a href="#a3a3140eb3e41d54e2370eb19ee6b043c">More...</a><br /></td></tr>
<tr class="separator:a3a3140eb3e41d54e2370eb19ee6b043c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88457a3be4c40dfe3dbf1a0e3f52480"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a></td></tr>
<tr class="memdesc:af88457a3be4c40dfe3dbf1a0e3f52480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on all the elements of a structure satisfying a <code>predicate</code>.  <a href="#af88457a3be4c40dfe3dbf1a0e3f52480">More...</a><br /></td></tr>
<tr class="separator:af88457a3be4c40dfe3dbf1a0e3f52480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_functor.html#ac27a1807b60b8fa59e6c618cb8ca749f">adjust</a></td></tr>
<tr class="memdesc:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on all the elements of a structure that compare equal to some value.  <a href="#ac27a1807b60b8fa59e6c618cb8ca749f">More...</a><br /></td></tr>
<tr class="separator:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d42b572f43016f929b5729c2533f5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a></td></tr>
<tr class="memdesc:ab57d42b572f43016f929b5729c2533f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure satisfying a <code>predicate</code> with a fixed value.  <a href="#ab57d42b572f43016f929b5729c2533f5">More...</a><br /></td></tr>
<tr class="separator:ab57d42b572f43016f929b5729c2533f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e73dcc09699c619bcfb006029a8967"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_functor.html#a72e73dcc09699c619bcfb006029a8967">replace</a></td></tr>
<tr class="memdesc:a72e73dcc09699c619bcfb006029a8967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure that compare equal to some <code>value</code> with some new fixed value.  <a href="#a72e73dcc09699c619bcfb006029a8967">More...</a><br /></td></tr>
<tr class="separator:a72e73dcc09699c619bcfb006029a8967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35025921d0fb75c28c2411d207a0da5e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_functor.html#a35025921d0fb75c28c2411d207a0da5e">fill</a></td></tr>
<tr class="memdesc:a35025921d0fb75c28c2411d207a0da5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure with a fixed value.  <a href="#a35025921d0fb75c28c2411d207a0da5e">More...</a><br /></td></tr>
<tr class="separator:a35025921d0fb75c28c2411d207a0da5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a3a3140eb3e41d54e2370eb19ee6b043c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto transform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Map a function over a <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a>, the signature is \( \mathrm{transform} : F(T) \times (T \to U) \to F(U) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to map <code>f</code> over.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on element(s) <code>x</code> of the structure, and returning a new value to replace <code>x</code> in the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::ostringstream const&amp;<span class="keyword">&gt;</span>(std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>, std::string{<span class="stringliteral">&quot;67&quot;</span>}), to_string)</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;345&quot;</span>, <span class="stringliteral">&quot;67&quot;</span>)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(nothing, to_string) == nothing);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(just(123), to_string) == just(<span class="stringliteral">&quot;123&quot;</span>s));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_functor.html#a3a3140eb3e41d54e2370eb19ee6b043c">transform</a>(tuple_t&lt;<span class="keywordtype">void</span>, <span class="keywordtype">int</span>(), <span class="keywordtype">char</span>[10]&gt;, template_&lt;std::add_pointer_t&gt;)</div>
<div class="line">            ==</div>
<div class="line">    tuple_t&lt;<span class="keywordtype">void</span>*, <span class="keywordtype">int</span>(*)(), <span class="keywordtype">char</span>(*)[10]&gt;</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/functor/transform.ctime.png" alt="transform.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="af88457a3be4c40dfe3dbf1a0e3f52480"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto adjust_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Apply a function on all the elements of a structure satisfying a <code>predicate</code>. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> and <code>Bool</code> a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, the signature is \( \mathrm{adjust_if} : F(T) \times (T \to Bool) \times (T \to T) \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to adjust with <code>f</code>.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for element(s) <code>x</code> of the structure and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>f</code> should be applied to <code>x</code>.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on element(s) of the structure for which the <code>predicate</code> returns a true-valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negative = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x &lt; 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negate = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> -x;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_functor.html#af88457a3be4c40dfe3dbf1a0e3f52480">adjust_if</a>(make&lt;Tuple&gt;(-3, -2, -1, 0, 1, 2, 3), negative, negate)</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(3, 2, 1, 0, 1, 2, 3)</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/functor/adjust_if.ctime.png" alt="adjust_if.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="ac27a1807b60b8fa59e6c618cb8ca749f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto adjust</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; value, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Apply a function on all the elements of a structure that compare equal to some value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> and <code>U</code> a type that can be compared with <code>T</code>'s, the signature is \( \mathrm{adjust} : F(T) \times U \times (T \to T) \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to adjust with <code>f</code>.</td></tr>
    <tr><td class="paramname">value</td><td>An object that is compared with each element <code>x</code> of the structure. Elements of the structure that compare equal to <code>value</code> are adjusted with the <code>f</code> function.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on the element(s) of the structure that compare equal to <code>value</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negate = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> -x;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_functor.html#ac27a1807b60b8fa59e6c618cb8ca749f">adjust</a>(make&lt;Tuple&gt;(1, 4, 9, 2, 3, 4), 4, negate)</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(1, -4, 9, 2, 3, -4)</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/functor/adjust.ctime.png" alt="adjust.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="ab57d42b572f43016f929b5729c2533f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto replace_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; value) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Replace all the elements of a structure satisfying a <code>predicate</code> with a fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> and <code>Bool</code> a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, the signature is \( \mathrm{replace_if} : F(T) \times (T \to Bool) \times T \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to replace elements of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for element(s) <code>x</code> of the structure and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should be replaced by <code>value</code>.</td></tr>
    <tr><td class="paramname">value</td><td>A value by which every element <code>x</code> of the structure for which <code>predicate</code> returns a true-valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> is replaced.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negative = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x &lt; 0;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_functor.html#ab57d42b572f43016f929b5729c2533f5">replace_if</a>(make&lt;Tuple&gt;(-3, -2, -1, 0, 1, 2, 3), negative, 0)</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(0, 0, 0, 0, 1, 2, 3)</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/functor/replace_if.ctime.png" alt="replace_if.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a72e73dcc09699c619bcfb006029a8967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto replace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; oldval, <span class="keyword">auto</span>&amp;&amp; newval) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Replace all the elements of a structure that compare equal to some <code>value</code> with some new fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> and <code>U</code> a type that can be compared with <code>T</code>, the signature is \( \mathrm{replace} : F(T) \times U \times T \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to replace elements of.</td></tr>
    <tr><td class="paramname">oldval</td><td>An object compared with each element of the structure. Elements of the structure that compare equal to <code>oldval</code> are replaced by <code>newval</code> in the new structure.</td></tr>
    <tr><td class="paramname">newval</td><td>A value by which every element <code>x</code> of the structure that compares equal to <code>oldval</code> is replaced.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_functor.html#a72e73dcc09699c619bcfb006029a8967">replace</a>(make&lt;Tuple&gt;(1, 1, 1, 2, 3, 1, 4, 5), 1, 0)</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(0, 0, 0, 2, 3, 0, 4, 5)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a35025921d0fb75c28c2411d207a0da5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fill</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; value) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Replace all the elements of a structure with a fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a <a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a>, the signature is \( \mathrm{fill} : F(T) \times U \to F(U) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fill with a <code>value</code>.</td></tr>
    <tr><td class="paramname">value</td><td>A value by which every element <code>x</code> of the structure is replaced, unconditionally.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_functor.html#a35025921d0fb75c28c2411d207a0da5e">fill</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="keyword">nullptr</span>), <span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_functor.html#a35025921d0fb75c28c2411d207a0da5e">fill</a>(nothing, <span class="charliteral">&#39;x&#39;</span>) == nothing);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_functor.html#a35025921d0fb75c28c2411d207a0da5e">fill</a>(just(<span class="charliteral">&#39;y&#39;</span>), <span class="charliteral">&#39;x&#39;</span>) == just(<span class="charliteral">&#39;x&#39;</span>));</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/functor/fill.ctime.png" alt="fill.ctime.png"/>
</div>
 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_functor.html">Functor</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
