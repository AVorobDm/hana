<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-core.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Core utilities of the library. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceboost_1_1hana_1_1operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1hana_1_1operators.html">boost::hana::operators</a></td></tr>
<tr class="memdesc:namespaceboost_1_1hana_1_1operators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing operators provided as an alias to some methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1common.html">boost::hana::common&lt; T, U, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1_metafunction.html" title="A Metafunction is a function that takes Types as inputs and gives a Type as output. ">Metafunction</a> returning the common data type between two data types.  <a href="structboost_1_1hana_1_1common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1has__common.html">boost::hana::has_common&lt; T, U, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1_metafunction.html" title="A Metafunction is a function that takes Types as inputs and gives a Type as output. ">Metafunction</a> returning whether two data types share a common data type.  <a href="structboost_1_1hana_1_1has__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__convertible.html">boost::hana::is_convertible&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there is a Hana-conversion from a data type to another.  <a href="structboost_1_1hana_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1embedding.html">boost::hana::embedding&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a conversion between data types as being an embedding.  <a href="structboost_1_1hana_1_1embedding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__embedded.html">boost::hana::is_embedded&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a data type can be embedded into another data type.  <a href="structboost_1_1hana_1_1is__embedded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning the generalized type associated to <code>T</code>.  <a href="structboost_1_1hana_1_1datatype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1default__.html">boost::hana::default_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a tag-dispatched method implementation as a default implementation.  <a href="structboost_1_1hana_1_1default__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__default.html">boost::hana::is_default&lt; Method, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a tag-dispatched method implementation is a default implementation.  <a href="structboost_1_1hana_1_1is__default.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1models.html">boost::hana::models&lt; Concept, DataType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning whether a data type is a model of the given concept.  <a href="structboost_1_1hana_1_1models.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1operators_1_1adl.html">boost::hana::operators::adl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the operators from <code><a class="el" href="namespaceboost_1_1hana_1_1operators.html" title="Namespace containing operators provided as an alias to some methods. ">boost::hana::operators</a></code> visible to ADL.  <a href="structboost_1_1hana_1_1operators_1_1adl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1operators_1_1of.html">boost::hana::operators::of&lt; documentation &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the operator aliases that are enabled for a data type.  <a href="structboost_1_1hana_1_1operators_1_1of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1has__operator.html">boost::hana::has_operator&lt; Datatype, Method, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the operator associated to a given method is enabled for the given data type.  <a href="structboost_1_1hana_1_1has__operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1when.html">boost::hana::when&lt; condition &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a partial specialization only if a boolean condition is true.  <a href="structboost_1_1hana_1_1when.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1wrong.html">boost::hana::wrong&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to a type-dependent <code>std::false_type</code>.  <a href="structboost_1_1hana_1_1wrong.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4da46c97755c0f430b063711b66ca05b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4da46c97755c0f430b063711b66ca05b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga4da46c97755c0f430b063711b66ca05b">boost::hana::common_t</a> = typename common&lt; T, U &gt;::<a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0">type</a></td></tr>
<tr class="memdesc:ga4da46c97755c0f430b063711b66ca05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>common&lt;T, U&gt;::type</code>, provided for convenience.  <a href="#ga4da46c97755c0f430b063711b66ca05b">More...</a><br /></td></tr>
<tr class="separator:ga4da46c97755c0f430b063711b66ca05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typename datatype&lt; T &gt;::<a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0">type</a></td></tr>
<tr class="memdesc:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>datatype&lt;T&gt;::type</code>, provided for convenience.  <a href="#gae3cedd3772d00ac7c4de9dc3d719f321">More...</a><br /></td></tr>
<tr class="separator:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = when&lt; true &gt;</td></tr>
<tr class="memdesc:ga0f5d717bbf6646619bb6219b104384dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>when</code> allowing specializations to be enabled only if an expression is well-formed.  <a href="#ga0f5d717bbf6646619bb6219b104384dc">More...</a><br /></td></tr>
<tr class="separator:ga0f5d717bbf6646619bb6219b104384dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplParams" colspan="2">template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">boost::hana::is_a</a> = unspecified</td></tr>
<tr class="memdesc:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated for now, but kept around because some ideas are good.  <a href="#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">More...</a><br /></td></tr>
<tr class="separator:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7fdbde52f5fe384a816c6f39ff272df9"></a>
template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga7fdbde52f5fe384a816c6f39ff272df9">boost::hana::is_an</a> = decltype(is_a&lt;Typeclass, Datatypes...&gt;){}</td></tr>
<tr class="memdesc:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language. <br /></td></tr>
<tr class="separator:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga91ddd2ea55eca559a681c8e3e1003ba6"></a>
template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga91ddd2ea55eca559a681c8e3e1003ba6">boost::hana::are</a> = decltype(is_a&lt;Typeclass, Datatypes...&gt;){}</td></tr>
<tr class="memdesc:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language when several data types are provided. <br /></td></tr>
<tr class="separator:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">boost::hana::to</a></td></tr>
<tr class="memdesc:gadc70755c1d059139297814fb3bfeb91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an object from one data type to another.  <a href="#gadc70755c1d059139297814fb3bfeb91e">More...</a><br /></td></tr>
<tr class="separator:gadc70755c1d059139297814fb3bfeb91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d92480f0af1029878e773dafa3e2f60"><td class="memTemplParams" colspan="2">template&lt;typename Datatype &gt; </td></tr>
<tr class="memitem:ga1d92480f0af1029878e773dafa3e2f60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">boost::hana::make</a></td></tr>
<tr class="memdesc:ga1d92480f0af1029878e773dafa3e2f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of the given data type with the given arguments.  <a href="#ga1d92480f0af1029878e773dafa3e2f60">More...</a><br /></td></tr>
<tr class="separator:ga1d92480f0af1029878e773dafa3e2f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga4da46c97755c0f430b063711b66ca05b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#ga4da46c97755c0f430b063711b66ca05b">boost::hana::common_t</a> = typedef typename common&lt;T, U&gt;::<a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2common_8hpp.html">boost/hana/fwd/core/common.hpp</a>&gt;</code></p>

<p>Alias to <code>common&lt;T, U&gt;::type</code>, provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;common_t&lt;int, float&gt;, common&lt;int, float&gt;::type&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gae3cedd3772d00ac7c4de9dc3d719f321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typedef typename datatype&lt;T&gt;::<a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2datatype_8hpp.html">boost/hana/fwd/core/datatype.hpp</a>&gt;</code></p>

<p>Alias to <code>datatype&lt;T&gt;::type</code>, provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Datatype;</div>
<div class="line"><span class="keyword">struct </span>Person { <span class="keyword">struct </span>hana { <span class="keyword">using</span> datatype = Datatype; }; };</div>
<div class="line">static_assert(std::is_same&lt;datatype_t&lt;Person&gt;, Datatype&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga0f5d717bbf6646619bb6219b104384dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = typedef when&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2when_8hpp.html">boost/hana/fwd/core/when.hpp</a>&gt;</code></p>

<p>Variant of <code>when</code> allowing specializations to be enabled only if an expression is well-formed. </p>
<p><code>when_valid&lt;...&gt;</code> is always equivalent to <code>when&lt;true&gt;</code>. However, when used inside a partial specialization, SFINAE will cause the partial specialization to be ignored when the expression is ill-formed.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = when&lt;true&gt;&gt;</div>
<div class="line"><span class="keyword">struct </span>base_template;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>base_template&lt;T, <a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;typename T::value_type&gt;&gt; {</div>
<div class="line">    <span class="comment">// something useful...</span></div>
<div class="line">};</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga38cf78e1e3e262f7f1c71ddd9ca70cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Typeclass , typename... Datatypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::is_a = unspecified</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__a_8hpp.html">boost/hana/core/is_a.hpp</a>&gt;</code></p>

<p>Deprecated for now, but kept around because some ideas are good. </p>
<p>Specifically, <code>is_a&lt;Typeclass, Datatypes...&gt;</code> is a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>Typeclass::instance&lt;Datatypes...&gt;</code> represents an instance of <code>Typeclass</code>. This does not check whether the instance is valid: it does not check whether laws are satisfied or even if the minimal complete definition is syntactically correct. It only tells whether an instance is there and was not disabled explicitly with <code>disable</code>. Note that exactly one or two data types must be provided because the library currently supports only unary and binary type classes; failure to provide a correct number of arguments will trigger a static assertion.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>( is_a&lt;Foldable, Maybe&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!is_a&lt;Logical, Maybe&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!is_a&lt;Foldable, int&gt;);</div>
</div><!-- fragment --><p> An alternate syntax is provided for convenience. <code>is_a</code> can also be used as a function returning whether the data types of its arguments together define an instance of the given type class. In other words, </p><div class="fragment"><div class="line">is_a&lt;Typeclass&gt;(x1, ..., xn) == is_a&lt;Typeclass, D1, ..., Dn&gt;</div>
</div><!-- fragment --><p> where <code>xi</code> is an arbitrary object and <code>Di</code> is the data type of the corresponding <code>xi</code>.</p>
<p>With this alternate syntax, if a data type <code>D</code> is provided instead of a type class, and if a single object is passed, it returns whether the passed object has <code>D</code> as a data type. In other words, </p><div class="fragment"><div class="line">is_a&lt;Datatype&gt;(x)</div>
</div><!-- fragment --><p> is true if <code>x</code> has a data type of <code>Datatype</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This relies on the fact that data types do not coincide with type classes. Otherwise, it would be impossible to differentiate between <code>is_a&lt;Datatype&gt;</code> and <code>is_a&lt;Typeclass&gt;</code> without introducing additional machinery.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>The extension of <code>is_a</code> to data types is inconsistent, because one would expect <code>is_a&lt;D, decltype(some object of data type D)&gt;</code> to be true, while it gives an error.</dd></dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    constexpr <span class="keyword">auto</span> row = make&lt;Tuple&gt;;</div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> check_table = [](<span class="keyword">auto</span> ...headers) {</div>
<div class="line">        <span class="keywordflow">return</span> [=](<span class="keyword">auto</span> ...rows) {</div>
<div class="line">            <span class="keyword">auto</span> is_correct = [=](<span class="keyword">auto</span> row) {</div>
<div class="line">                <span class="keywordflow">return</span> make&lt;Tuple&gt;(headers(head(row))...) == tail(row);</div>
<div class="line">            };</div>
<div class="line">            <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(all_of(make&lt;Tuple&gt;(rows...), is_correct));</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    check_table(                      is_a&lt;Logical&gt;, is_an&lt;Iterable&gt;, is_a&lt;Monad&gt;   )(</div>
<div class="line">    row(just(1),                         false_,         false_,         true_      ),</div>
<div class="line">    row(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3),        false_,         true_,          true_      ),</div>
<div class="line">    row(std::make_tuple(<span class="stringliteral">&quot;abc&quot;</span>, <span class="charliteral">&#39;d&#39;</span>),     false_,         true_,          true_      ),</div>
<div class="line">    row(long_&lt;12&gt;,                       true_,          false_,         false_     ),</div>
<div class="line">    row(range(int_&lt;-4&gt;, int_&lt;15&gt;),       false_,         true_,          false_     )</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gadc70755c1d059139297814fb3bfeb91e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::to</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2convert_8hpp.html">boost/hana/fwd/core/convert.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Converts an object from one data type to another. </p>
<p><code>to</code> is a natural extension of the <code>static_cast</code> language construct to data types. Given a destination data type <code>To</code> and an object <code>x</code>, <code>to</code> creates a new object of data type <code>To</code> from <code>x</code>. Note, however, that <code>to</code> is not required to actually create a new object, and may return a reference to the original object (for example when trying to convert an object to its own data type).</p>
<p>As a natural extension to <code>static_cast</code>, <code>to</code> provides a default behavior. For the purpose of what follows, let <code>To</code> be the destination data type and <code>From</code> be the data type of <code>x</code>, i.e. the source data type. Then, <code>to</code> has the following default behavior:</p><ol type="1">
<li>If the <code>To</code> and <code>From</code> data types are the same, then the object is forwarded as-is.</li>
<li>Otherwise, if <code>From</code> is convertible to <code>To</code> using <code>static_cast</code>, <code>x</code> is converted to <code>From</code> using <code>static_cast</code>.</li>
<li>Otherwise, calling <code>to&lt;From&gt;(x)</code> triggers a static assertion.</li>
</ol>
<p>However, <code>to</code> is a tag-dispatched function, which means that <code>to_impl</code> may be specialized in the <code>boost::hana</code> namespace to customize its behavior for arbitrary data types. Also note that <code>to</code> is tag-dispatched using both the <code>To</code> and the <code>From</code> data types, which means that <code>to_impl</code> is called as <code>to_impl&lt;To, From&gt;::apply(x)</code>.</p>
<h2>Hana-convertibility </h2>
<p>When an object <code>x</code> of data type <code>From</code> can be converted to a data type <code>To</code> using <code>to</code>, we say that <code>x</code> is Hana-convertible to the data type <code>To</code>. We also say that there is a Hana-conversion from <code>From</code> to <code>To</code>. This bit of terminology is useful to avoid mistaking the various kinds of conversions C++ offers.</p>
<h2>Embeddings </h2>
<p>As you might have seen by now, Hana uses algebraic and category- theoretical structures all around the place to help specify concepts in a rigorous way. These structures always have operations associated to them, which is why they are useful. The notion of embedding captures the idea of injecting a smaller structure into a larger one while preserving the operations of the structure. In other words, an embedding is an injective mapping that is also structure-preserving. Exactly what it means for a structure's operations to be preserved is left to explain by the documentation of each structure. For example, when we talk of a Monoid-embedding from a <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> <code>A</code> to a <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> <code>B</code>, we simply mean an injective transformation that preserves the identity and the associative operation, as documented in <code><a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a></code>.</p>
<p>But what does this have to do with the <code>to</code> function? Quite simply, the <code>to</code> function is a mapping between two data types, which will sometimes be some kind of structure, and it is sometimes useful to know whether such a mapping is well-behaved, i.e. lossless and structure preserving. The criterion for this conversion to be well- behaved is exactly that of being an embedding. To specify that a conversion is an embedding, simply use the <code>embedding</code> type as a base class of the corresponding <code>to_impl</code> specialization. Obviously, you should make sure the conversion is really an embedding, unless you want to shoot yourself in the foot.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The data type to which <code>x</code> should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to convert to the given data type.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y, <span class="keyword">typename</span> Z&gt;</div>
<div class="line"><span class="keyword">struct </span>Triple {</div>
<div class="line">    X first;</div>
<div class="line">    Y second;</div>
<div class="line">    Z third;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> triple = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div>
<div class="line">    <span class="keywordflow">return</span> Triple&lt;decltype(x), decltype(y), decltype(z)&gt;{x, y, z};</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y, <span class="keyword">typename</span> Z&gt;</div>
<div class="line">    <span class="keyword">struct </span>to_impl&lt;Tuple, Triple&lt;X, Y, Z&gt;&gt; {</div>
<div class="line">        <span class="keyword">static</span> constexpr <span class="keyword">auto</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(Triple&lt;X, Y, Z&gt; xs) {</div>
<div class="line">            <span class="keywordflow">return</span> make&lt;Tuple&gt;(xs.first, xs.second, xs.third);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        to&lt;Tuple&gt;(triple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga1d92480f0af1029878e773dafa3e2f60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Datatype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::make</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2make_8hpp.html">boost/hana/fwd/core/make.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create an object of the given data type with the given arguments. </p>
<p>This function serves the same purpose as constructors in usual C++. However, instead of creating an object of a specific C++ type, it creates an object of a specific data type, with a C++ type that is left unspecified in the general case.</p>
<p>This function is actually a variable template, so <code>make&lt;T&gt;</code> can be passed around as a function object creating an object of data type <code>T</code>. Also, it uses tag-dispatching so this is how it should be customized for user-defined data types.</p>
<p>Finally, the default implementation of <code>make</code> is equivalent to calling the constructor of the given data type with the corresponding arguments. In other words, by default, </p><div class="fragment"><div class="line">make&lt;T&gt;(args...) == T(args...)</div>
</div><!-- fragment --><p>Note that the arguments are perfectly forwarded and the form of construction which is used is exactly as documented, i.e. <code>T(args...)</code>. However, if <code>T(args...)</code> is not a valid expression, a compilation error is triggered. This default behavior is useful because it makes foreign C++ types that have no notion of <em>data type</em> constructible with <code>make</code> out-of-the-box, since their data type is exactly themselves.</p>
<h2>Example </h2>
<div class="fragment"><div class="line">_tuple&lt;int, char, double, std::string&gt; ts{1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abcd&quot;</span>};</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ts == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, std::string{<span class="stringliteral">&quot;abcd&quot;</span>}));</div>
<div class="line"></div>
<div class="line">std::string foo{<span class="stringliteral">&quot;foo&quot;</span>}; <span class="comment">// std::string has no notion of data type</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(make&lt;std::string&gt;(<span class="stringliteral">&quot;foo&quot;</span>) == foo);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
