<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Boost.Hana: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-core.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Core utilities of the library. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Update the documentation about the organization of the Core module. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceboost_1_1hana_1_1operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1hana_1_1operators.html">boost::hana::operators</a></td></tr>
<tr class="memdesc:namespaceboost_1_1hana_1_1operators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing custom operators provided by some type classes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1convert.html">boost::hana::convert&lt; To, From, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements conversions between data types.  <a href="structboost_1_1hana_1_1convert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning the data type associated to <code>T</code>.  <a href="structboost_1_1hana_1_1datatype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1disable.html">boost::hana::disable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly disable a type class instance.  <a href="structboost_1_1hana_1_1disable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1operators_1_1enable__adl.html">boost::hana::operators::enable_adl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows custom Hana operators to be used with objects of a type.  <a href="structboost_1_1hana_1_1operators_1_1enable__adl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1enabled__operators.html">boost::hana::enabled_operators&lt; Datatype, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait describing the custom operators enabled for a data type.  <a href="structboost_1_1hana_1_1enabled__operators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1enable__operators.html">boost::hana::enable_operators&lt; Typeclass, Datatype &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the custom operators of a type class are enabled for the given data type.  <a href="structboost_1_1hana_1_1enable__operators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1when.html">boost::hana::when&lt; condition &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a type class instance or a data type specialization only if a boolean condition is true.  <a href="structboost_1_1hana_1_1when.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac072d4434777cd5ee841a7766d41f1d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(NAME)</td></tr>
<tr class="memdesc:gac072d4434777cd5ee841a7766d41f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a unary type class.  <a href="#gac072d4434777cd5ee841a7766d41f1d8">More...</a><br /></td></tr>
<tr class="separator:gac072d4434777cd5ee841a7766d41f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-core.html#gabc68f88756ee6bb3b727d8f0abea8ee5">BOOST_HANA_BINARY_TYPECLASS</a>(NAME)</td></tr>
<tr class="memdesc:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a binary type class.  <a href="#gabc68f88756ee6bb3b727d8f0abea8ee5">More...</a><br /></td></tr>
<tr class="separator:gabc68f88756ee6bb3b727d8f0abea8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae3cedd3772d00ac7c4de9dc3d719f321"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typename datatype&lt; T &gt;::<a class="el" href="structboost_1_1hana_1_1_type.html#a38a0f9e2d8df802d1a0a0d835d39b709">type</a></td></tr>
<tr class="memdesc:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>datatype&lt;T&gt;::type</code>. <br /></td></tr>
<tr class="separator:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">boost::hana::to</a></td></tr>
<tr class="memdesc:gadc70755c1d059139297814fb3bfeb91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of a data type from an object of another data type.  <a href="#gadc70755c1d059139297814fb3bfeb91e">More...</a><br /></td></tr>
<tr class="separator:gadc70755c1d059139297814fb3bfeb91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplParams" colspan="2">template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">boost::hana::is_a</a> = unspecified</td></tr>
<tr class="separator:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7fdbde52f5fe384a816c6f39ff272df9"></a>
template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga7fdbde52f5fe384a816c6f39ff272df9">boost::hana::is_an</a> = is_a&lt;Typeclass, Datatypes...&gt;</td></tr>
<tr class="memdesc:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language. <br /></td></tr>
<tr class="separator:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga91ddd2ea55eca559a681c8e3e1003ba6"></a>
template&lt;typename Typeclass , typename... Datatypes&gt; </td></tr>
<tr class="memitem:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga91ddd2ea55eca559a681c8e3e1003ba6">boost::hana::are</a> = is_a&lt;Typeclass, Datatypes...&gt;</td></tr>
<tr class="memdesc:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language when several data types are provided. <br /></td></tr>
<tr class="separator:ga91ddd2ea55eca559a681c8e3e1003ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60eae11766d96f803ec954f9f521936"><td class="memTemplParams" colspan="2">template&lt;typename Datatype , typename  = optional when-based enabler&gt; </td></tr>
<tr class="memitem:gae60eae11766d96f803ec954f9f521936"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gae60eae11766d96f803ec954f9f521936">boost::hana::make</a></td></tr>
<tr class="memdesc:gae60eae11766d96f803ec954f9f521936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of the given data type with the given arguments.  <a href="#gae60eae11766d96f803ec954f9f521936">More...</a><br /></td></tr>
<tr class="separator:gae60eae11766d96f803ec954f9f521936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ffb2ad0341b5ec4e6fd83431e2a81ae"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga2ffb2ad0341b5ec4e6fd83431e2a81ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga2ffb2ad0341b5ec4e6fd83431e2a81ae">boost::hana::is_valid</a> = true</td></tr>
<tr class="memdesc:ga2ffb2ad0341b5ec4e6fd83431e2a81ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in conjunction with <code>when</code> to enable a type class instance or a data type specialization only if an expression is well-formed.  <a href="#ga2ffb2ad0341b5ec4e6fd83431e2a81ae">More...</a><br /></td></tr>
<tr class="separator:ga2ffb2ad0341b5ec4e6fd83431e2a81ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac072d4434777cd5ee841a7766d41f1d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_TYPECLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="typeclass_8hpp.html">boost/hana/core/typeclass.hpp</a>&gt;</code></p>

<p>Defines a unary type class. </p>
<p>Use this macro at public scope when defining a type class to create the boilerplate necessary for a unary type class.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="typeclass_8hpp.html">boost/hana/core/typeclass.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/detail/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="constexpr_8hpp.html">boost/hana/detail/constexpr.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Incrementable);</div>
<div class="line">    <span class="keyword">struct </span>next_mcd;</div>
<div class="line">    <span class="keyword">struct </span>next_n_mcd;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;</div>
<div class="line">        hana::datatype_t&lt;decltype(x)&gt;</div>
<div class="line">    &gt;::next_impl(x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> next_n = [](<span class="keyword">auto</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">    <span class="keywordflow">return</span> Incrementable::instance&lt;</div>
<div class="line">        hana::datatype_t&lt;decltype(x)&gt;</div>
<div class="line">    &gt;::next_n_impl(x, n);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(X x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n) {</div>
<div class="line">        <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> x;</div>
<div class="line">        <span class="keywordflow">else</span>        <span class="keywordflow">return</span> next_n_impl(next(x), n - 1);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> next_n(x, 1); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;int&gt; : Incrementable::next_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(<span class="keywordtype">int</span> x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;long&gt; : Incrementable::next_n_mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_n_impl(<span class="keywordtype">long</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)</div>
<div class="line">    { <span class="keywordflow">return</span> x + n; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Incrementable::instance&lt;T, hana::when&lt;std::is_floating_point&lt;T&gt;{}&gt;&gt;</div>
<div class="line">    : Incrementable::next_mcd</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> next_impl(X x)</div>
<div class="line">    { <span class="keywordflow">return</span> x + 1; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(next(1) == 2);</div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(next_n(1, 3) == 4);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(next(1l) == 2l);</div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(next_n(1l, 3) == 4l);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(next(1.0) == 2.0);</div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(next_n(1.0, 3) == 4.0);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gabc68f88756ee6bb3b727d8f0abea8ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_BINARY_TYPECLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">NAME</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="typeclass_8hpp.html">boost/hana/core/typeclass.hpp</a>&gt;</code></p>

<p>Defines a binary type class. </p>
<p>This is equivalent to <code>BOOST_HANA_TYPECLASS</code>, except it creates a type class accepting two data types. This is useful for type classes like <code>Comparable</code>, whose methods are binary and should be dispatched using the data types of both arguments.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="typeclass_8hpp.html">boost/hana/core/typeclass.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/detail/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="constexpr_8hpp.html">boost/hana/detail/constexpr.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Similar represents a relaxed equality.</span></div>
<div class="line"><span class="keyword">struct </span>Similar {</div>
<div class="line">    <a class="code" href="group__group-core.html#gabc68f88756ee6bb3b727d8f0abea8ee5">BOOST_HANA_BINARY_TYPECLASS</a>(Similar);</div>
<div class="line">    <span class="keyword">struct </span>mcd { };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// By default, two (seemingly) unrelated things are not similar.</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div>
<div class="line">    <span class="keyword">struct </span>default_instance : mcd {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt;</div>
<div class="line">        <span class="keyword">static</span> constexpr <span class="keyword">auto</span> similar_impl(X x, Y y)</div>
<div class="line">        { <span class="keywordflow">return</span> hana::false_; }</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Return whether `x` and `y` are similar.</span></div>
<div class="line"><span class="comment">// Notice that we dispatch on both data types.</span></div>
<div class="line"><a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> similar = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> Similar::instance&lt;</div>
<div class="line">        hana::datatype_t&lt;decltype(x)&gt;,</div>
<div class="line">        hana::datatype_t&lt;decltype(y)&gt;</div>
<div class="line">    &gt;::similar_impl(x, y);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Two STL containers are similar if they are std::equal</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt;</div>
<div class="line"><span class="keyword">struct </span>Similar::instance&lt;X, Y, hana::when&lt;hana::is_valid&lt;</div>
<div class="line">    decltype((void)std::declval&lt;X&gt;().begin()),</div>
<div class="line">    decltype((void)std::declval&lt;Y&gt;().begin())</div>
<div class="line">&gt;&gt;&gt; : Similar::mcd {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> similar_impl(X x, Y y)</div>
<div class="line">    { <span class="keywordflow">return</span> std::equal(x.begin(), x.end(), y.begin(), y.end()); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::vector&lt;char&gt; foo_vec{<span class="charliteral">&#39;f&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;o&#39;</span>};</div>
<div class="line">    std::string foo_str = <span class="stringliteral">&quot;foo&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We can now compare arbitrary containers</span></div>
<div class="line">    <span class="comment">// (not that it&#39;s brilliant to do so)</span></div>
<div class="line">    <a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(similar(foo_vec, foo_str));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// And arbitrary stuff now compare unequal.</span></div>
<div class="line">    <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!similar(1, foo_str));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gadc70755c1d059139297814fb3bfeb91e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::to</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="core_2convert_8hpp.html">boost/hana/core/convert.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> convert&lt;To, datatype_t&lt;decltype(x)&gt;&gt;<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">::apply</a>(</div>
<div class="line">            std::forward&lt;<a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(x)&gt;(x)</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="ttc" id="group__group-functional_html_ga30027c383676084be151ef3c6cf2829f"><div class="ttname"><a href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">boost::hana::apply</a></div><div class="ttdeci">constexpr auto apply</div><div class="ttdoc">Invoke f with x... as arguments. </div><div class="ttdef"><b>Definition:</b> apply.hpp:33</div></div>
<div class="ttc" id="structboost_1_1hana_1_1_comparable_html_a94e26804d5b410086b0230b5aa0c11a5"><div class="ttname"><a href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">boost::hana::Comparable::decltype</a></div><div class="ttdeci">decltype(auto) constexpr boost::hana::operators::operator==(X &amp;&amp;x, Y &amp;&amp;y)</div><div class="ttdoc">Equivalent to equal. </div><div class="ttdef"><b>Definition:</b> operators.hpp:28</div></div>
</div><!-- fragment -->
<p>Create an object of a data type from an object of another data type. </p>
<p>See <code>convert</code> to specify <em>how</em> to convert from a data type to another.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The data type to which <code>x</code> should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to convert to the given data type.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">        to&lt;Tuple&gt;(std::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">        to&lt;Tuple&gt;(range(int_&lt;1&gt;, int_&lt;4&gt;)) == tuple(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(</div>
<div class="line">        to&lt;Tuple&gt;(std::array&lt;int, 3&gt;{{1, 2, 3}}) == tuple(1, 2, 3)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga38cf78e1e3e262f7f1c71ddd9ca70cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Typeclass , typename... Datatypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::is_a = unspecified</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__a_8hpp.html">boost/hana/core/is_a.hpp</a>&gt;</code></p>
<p><a class="anchor" id="group-core-is_a"></a> Return whether a type class is instantiated with the given data types.</p>
<p>Specifically, <code>is_a&lt;Typeclass, Datatypes...&gt;</code> is a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>Typeclass::instance&lt;Datatypes...&gt;</code> represents an instance of <code>Typeclass</code>. This does not check whether the instance is valid: it does not check whether laws are satisfied or even if the minimal complete definition is syntactically correct. It only tells whether an instance is there and was not disabled explicitly with <code>disable</code>. Note that exactly one or two data types must be provided because the library currently supports only unary and binary type classes; failure to provide a correct number of arguments will trigger a static assertion.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>( is_a&lt;Foldable, Maybe&gt;);</div>
<div class="line">    <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!is_a&lt;Logical, Maybe&gt;);</div>
<div class="line">    <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!is_a&lt;Foldable, int&gt;);</div>
<div class="line">    <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>( are&lt;Comparable, int, long&gt;);</div>
</div><!-- fragment --><p> An alternate syntax is provided for convenience. <code>is_a</code> can also be used as a function returning whether the data types of its arguments together define an instance of the given type class. In other words, </p><div class="fragment"><div class="line">is_a&lt;Typeclass&gt;(x1, ..., xn) == is_a&lt;Typeclass, D1, ..., Dn&gt;</div>
</div><!-- fragment --><p> where <code>xi</code> is an arbitrary object and <code>Di</code> is the data type of the corresponding <code>xi</code>.</p>
<p>With this alternate syntax, if a data type <code>D</code> is provided instead of a type class, and if a single object is passed, it returns whether the passed object has <code>D</code> as a data type. In other words, </p><div class="fragment"><div class="line">is_a&lt;Datatype&gt;(x)</div>
</div><!-- fragment --><p> is true if <code>x</code> has a data type of <code>Datatype</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This relies on the fact that data types do not coincide with type classes. Otherwise, it would be impossible to differentiate between <code>is_a&lt;Datatype&gt;</code> and <code>is_a&lt;Typeclass&gt;</code> without introducing additional machinery.</dd></dl>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> row = tuple;</div>
<div class="line">    <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> check_table = [](<span class="keyword">auto</span> ...headers) {</div>
<div class="line">        <span class="keywordflow">return</span> [=](<span class="keyword">auto</span> ...rows) {</div>
<div class="line">            <span class="keyword">auto</span> row_is_correct = [=](<span class="keyword">auto</span> row) {</div>
<div class="line">                <span class="keywordflow">return</span> tuple(headers(head(row))...) == tail(row);</div>
<div class="line">            };</div>
<div class="line">            <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(all(tuple(rows...), row_is_correct));</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    check_table(                      is_a&lt;Logical&gt;, is_an&lt;Iterable&gt;, is_a&lt;Monad&gt;   )(</div>
<div class="line">    row(just(1),                         false_,         false_,         true_      ),</div>
<div class="line">    row(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3),              false_,         true_,          true_      ),</div>
<div class="line">    row(std::make_tuple(<span class="stringliteral">&quot;abc&quot;</span>, <span class="charliteral">&#39;d&#39;</span>),     false_,         true_,          true_      ),</div>
<div class="line">    row(long_&lt;12&gt;,                       true_,          false_,         false_     ),</div>
<div class="line">    row(range(int_&lt;-4&gt;, int_&lt;15&gt;),       false_,         true_,          false_     )</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gae60eae11766d96f803ec954f9f521936"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Datatype , typename  = optional when-based enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::make</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="make_8hpp.html">boost/hana/core/make.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; <a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">make_impl&lt;Datatype&gt;::apply</a>(</div>
<div class="line">            std::forward&lt;<a class="code" href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">decltype</a>(x)&gt;(x)...</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="ttc" id="group__group-functional_html_ga30027c383676084be151ef3c6cf2829f"><div class="ttname"><a href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">boost::hana::apply</a></div><div class="ttdeci">constexpr auto apply</div><div class="ttdoc">Invoke f with x... as arguments. </div><div class="ttdef"><b>Definition:</b> apply.hpp:33</div></div>
<div class="ttc" id="structboost_1_1hana_1_1_comparable_html_a94e26804d5b410086b0230b5aa0c11a5"><div class="ttname"><a href="structboost_1_1hana_1_1_comparable.html#a94e26804d5b410086b0230b5aa0c11a5">boost::hana::Comparable::decltype</a></div><div class="ttdeci">decltype(auto) constexpr boost::hana::operators::operator==(X &amp;&amp;x, Y &amp;&amp;y)</div><div class="ttdoc">Equivalent to equal. </div><div class="ttdef"><b>Definition:</b> operators.hpp:28</div></div>
</div><!-- fragment -->
<p>Create an object of the given data type with the given arguments. </p>
<p>This function serves the same purpose as constructors in usual C++. However, instead of creating an object of a specific C++ type, it creates an object of a specific data type, with a C++ type that is left unspecified in the general case.</p>
<p>This variable template may be customized by specializing it for a specific data type. When left unspecialized, <code>make&lt;Datatype&gt;(args...)</code> defaults to <code>Datatype(args...)</code> if that expression is valid, which is useful because it makes foreign C++ types constructible with <code>make</code> out-of-the-box. When the <code>Datatype(args...)</code> is invalid and no specialization is provided, a static assertion is triggered.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> foo = make&lt;std::string&gt;(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(foo == <span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> ts = make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, std::string{<span class="stringliteral">&quot;abcd&quot;</span>});</div>
<div class="line">    <a class="code" href="group__group-details.html#ga7ad5b8e5cb988d185dffa511b50cebd2">BOOST_HANA_RUNTIME_ASSERT</a>(ts == tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, std::string{<span class="stringliteral">&quot;abcd&quot;</span>}));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga2ffb2ad0341b5ec4e6fd83431e2a81ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool boost::hana::is_valid = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="when_8hpp.html">boost/hana/core/when.hpp</a>&gt;</code></p>

<p>Used in conjunction with <code>when</code> to enable a type class instance or a data type specialization only if an expression is well-formed. </p>
<p>Specifically, <code>is_valid&lt;...&gt;</code> is always equivalent to the constant expression <code>true</code>. When used as <code>when&lt;is_valid&lt;...&gt;&gt;</code> inside a type class or data type specialization, SFINAE will cause the partial specialization to fail when the expression is ill-formed.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="typeclass_8hpp.html">boost/hana/core/typeclass.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Printable {</div>
<div class="line">    <a class="code" href="group__group-core.html#gac072d4434777cd5ee841a7766d41f1d8">BOOST_HANA_TYPECLASS</a>(Printable);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> print = [](std::ostream&amp; os, <span class="keyword">auto</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> Printable::instance&lt;datatype_t&lt;decltype(x)&gt;&gt;::print_impl(os, x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>Printable::instance&lt;T, <a class="code" href="structboost_1_1hana_1_1when.html">when</a>&lt;<a class="code" href="group__group-core.html#ga2ffb2ad0341b5ec4e6fd83431e2a81ae">is_valid</a>&lt;</div>
<div class="line">    decltype(<a class="code" href="namespacestd.html">std</a>::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())</div>
<div class="line">&gt;&gt;&gt; {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> print_impl(std::ostream&amp; os, T x) {</div>
<div class="line">        os &lt;&lt; x;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    print(std::cout, 2);</div>
<div class="line">    print(std::cout, std::string{<span class="stringliteral">&quot;foo&quot;</span>});</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
