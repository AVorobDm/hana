<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Hana: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/fb54ae3856341ef4bd3acf877ccf24836fc079d9/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/unspecified-type/g, "unspecified-type".link("index.html#tutorial-glossary-unspecified_type").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.5.0/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-core.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Core utilities of the library. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceboost_1_1hana_1_1operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1hana_1_1operators.html">boost::hana::operators</a></td></tr>
<tr class="memdesc:namespaceboost_1_1hana_1_1operators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing operators provided as an alias to some methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1common.html">boost::hana::common&lt; T, U, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1Metafunction.html" title="A Metafunction is a function that takes Types as inputs and gives a Type as output. ">Metafunction</a> returning the common data type between two data types.  <a href="structboost_1_1hana_1_1common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1has__common.html">boost::hana::has_common&lt; T, U, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1Metafunction.html" title="A Metafunction is a function that takes Types as inputs and gives a Type as output. ">Metafunction</a> returning whether two data types share a common data type.  <a href="structboost_1_1hana_1_1has__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__convertible.html">boost::hana::is_convertible&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there is a Hana-conversion from a data type to another.  <a href="structboost_1_1hana_1_1is__convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1embedding.html">boost::hana::embedding&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a conversion between data types as being an embedding.  <a href="structboost_1_1hana_1_1embedding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__embedded.html">boost::hana::is_embedded&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a data type can be embedded into another data type.  <a href="structboost_1_1hana_1_1is__embedded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction returning the generalized type associated to <code>T</code>.  <a href="structboost_1_1hana_1_1datatype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1default__.html">boost::hana::default_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a tag-dispatched method implementation as a default implementation.  <a href="structboost_1_1hana_1_1default__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1is__default.html">boost::hana::is_default&lt; Method, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a tag-dispatched method implementation is a default implementation.  <a href="structboost_1_1hana_1_1is__default.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1operators_1_1adl.html">boost::hana::operators::adl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the operators from <code><a class="el" href="namespaceboost_1_1hana_1_1operators.html" title="Namespace containing operators provided as an alias to some methods. ">boost::hana::operators</a></code> visible to ADL.  <a href="structboost_1_1hana_1_1operators_1_1adl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1operators_1_1of.html">boost::hana::operators::of&lt; documentation &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the operator aliases that are enabled for a data type.  <a href="structboost_1_1hana_1_1operators_1_1of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1when.html">boost::hana::when&lt; condition &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a partial specialization only if a boolean condition is true.  <a href="structboost_1_1hana_1_1when.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4da46c97755c0f430b063711b66ca05b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga4da46c97755c0f430b063711b66ca05b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga4da46c97755c0f430b063711b66ca05b">boost::hana::common_t</a> = typename common&lt; T, U &gt;::<a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a></td></tr>
<tr class="memdesc:ga4da46c97755c0f430b063711b66ca05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>common&lt;T, U&gt;::type</code>, provided for convenience.  <a href="#ga4da46c97755c0f430b063711b66ca05b">More...</a><br /></td></tr>
<tr class="separator:ga4da46c97755c0f430b063711b66ca05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typename datatype&lt; T &gt;::<a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a></td></tr>
<tr class="memdesc:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>datatype&lt;T&gt;::type</code>, provided for convenience.  <a href="#gae3cedd3772d00ac7c4de9dc3d719f321">More...</a><br /></td></tr>
<tr class="separator:gae3cedd3772d00ac7c4de9dc3d719f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga0f5d717bbf6646619bb6219b104384dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = when&lt; true &gt;</td></tr>
<tr class="memdesc:ga0f5d717bbf6646619bb6219b104384dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>when</code> allowing specializations to be enabled only if an expression is well-formed.  <a href="#ga0f5d717bbf6646619bb6219b104384dc">More...</a><br /></td></tr>
<tr class="separator:ga0f5d717bbf6646619bb6219b104384dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:gadc70755c1d059139297814fb3bfeb91e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">boost::hana::to</a></td></tr>
<tr class="memdesc:gadc70755c1d059139297814fb3bfeb91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an object from one data type to another.  <a href="#gadc70755c1d059139297814fb3bfeb91e">More...</a><br /></td></tr>
<tr class="separator:gadc70755c1d059139297814fb3bfeb91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename optional_T &gt; </td></tr>
<tr class="memitem:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">boost::hana::is_a</a> = see-documentation</td></tr>
<tr class="memdesc:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the data type of an object matches a given data type.  <a href="#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">More...</a><br /></td></tr>
<tr class="separator:ga38cf78e1e3e262f7f1c71ddd9ca70cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7fdbde52f5fe384a816c6f39ff272df9"></a>
template&lt;typename DataType , typename... T&gt; </td></tr>
<tr class="memitem:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga7fdbde52f5fe384a816c6f39ff272df9">boost::hana::is_an</a> = is_a&lt;DataType, T...&gt;</td></tr>
<tr class="memdesc:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>is_a</code>; provided for consistency with the rules of the English language. <br /></td></tr>
<tr class="separator:ga7fdbde52f5fe384a816c6f39ff272df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d92480f0af1029878e773dafa3e2f60"><td class="memTemplParams" colspan="2">template&lt;typename Datatype &gt; </td></tr>
<tr class="memitem:ga1d92480f0af1029878e773dafa3e2f60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">boost::hana::make</a></td></tr>
<tr class="memdesc:ga1d92480f0af1029878e773dafa3e2f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object of the given data type with the given arguments.  <a href="#ga1d92480f0af1029878e773dafa3e2f60">More...</a><br /></td></tr>
<tr class="separator:ga1d92480f0af1029878e773dafa3e2f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ecb6ee4fe2f7d156e5026e37df8946"><td class="memTemplParams" colspan="2">template&lt;typename Concept , typename optional_T &gt; </td></tr>
<tr class="memitem:ga91ecb6ee4fe2f7d156e5026e37df8946"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#ga91ecb6ee4fe2f7d156e5026e37df8946">boost::hana::models</a> = see-documentation</td></tr>
<tr class="memdesc:ga91ecb6ee4fe2f7d156e5026e37df8946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the data type of an object is a model of the given concept.  <a href="#ga91ecb6ee4fe2f7d156e5026e37df8946">More...</a><br /></td></tr>
<tr class="separator:ga91ecb6ee4fe2f7d156e5026e37df8946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d2efbdd45154b3a1547fce93cf19a4"><td class="memTemplParams" colspan="2">template&lt;typename Datatype , typename Method &gt; </td></tr>
<tr class="memitem:gaa7d2efbdd45154b3a1547fce93cf19a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-core.html#gaa7d2efbdd45154b3a1547fce93cf19a4">boost::hana::has_operator</a> = see-documentation</td></tr>
<tr class="memdesc:gaa7d2efbdd45154b3a1547fce93cf19a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the operator associated to a given method is enabled for the given data type.  <a href="#gaa7d2efbdd45154b3a1547fce93cf19a4">More...</a><br /></td></tr>
<tr class="separator:gaa7d2efbdd45154b3a1547fce93cf19a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga4da46c97755c0f430b063711b66ca05b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#ga4da46c97755c0f430b063711b66ca05b">boost::hana::common_t</a> = typedef typename common&lt;T, U&gt;::<a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2common_8hpp.html">boost/hana/fwd/core/common.hpp</a>&gt;</code></p>

<p>Alias to <code>common&lt;T, U&gt;::type</code>, provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;common_t&lt;int, float&gt;, common&lt;int, float&gt;::type&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gae3cedd3772d00ac7c4de9dc3d719f321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#gae3cedd3772d00ac7c4de9dc3d719f321">boost::hana::datatype_t</a> = typedef typename datatype&lt;T&gt;::<a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2datatype_8hpp.html">boost/hana/fwd/core/datatype.hpp</a>&gt;</code></p>

<p>Alias to <code>datatype&lt;T&gt;::type</code>, provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Datatype;</div>
<div class="line"><span class="keyword">struct </span>Person { <span class="keyword">struct </span>hana { <span class="keyword">using</span> datatype = Datatype; }; };</div>
<div class="line">static_assert(std::is_same&lt;datatype_t&lt;Person&gt;, Datatype&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga0f5d717bbf6646619bb6219b104384dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">boost::hana::when_valid</a> = typedef when&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2when_8hpp.html">boost/hana/fwd/core/when.hpp</a>&gt;</code></p>

<p>Variant of <code>when</code> allowing specializations to be enabled only if an expression is well-formed. </p>
<p><code>when_valid&lt;...&gt;</code> is always equivalent to <code>when&lt;true&gt;</code>. However, when used inside a partial specialization, SFINAE will cause the partial specialization to be ignored when the expression is ill-formed.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = when&lt;true&gt;&gt;</div>
<div class="line"><span class="keyword">struct </span>base_template;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>base_template&lt;T, <a class="code" href="group__group-core.html#ga0f5d717bbf6646619bb6219b104384dc">when_valid</a>&lt;typename T::value_type&gt;&gt; {</div>
<div class="line">    <span class="comment">// something useful...</span></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>Using <code>when_valid</code> seems to trigger ambiguous partial specializations on GCC. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gadc70755c1d059139297814fb3bfeb91e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::to</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2convert_8hpp.html">boost/hana/fwd/core/convert.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Converts an object from one data type to another. </p>
<p><code>to</code> is a natural extension of the <code>static_cast</code> language construct to data types. Given a destination data type <code>To</code> and an object <code>x</code>, <code>to</code> creates a new object of data type <code>To</code> from <code>x</code>. Note, however, that <code>to</code> is not required to actually create a new object, and may return a reference to the original object (for example when trying to convert an object to its own data type).</p>
<p>As a natural extension to <code>static_cast</code>, <code>to</code> provides a default behavior. For the purpose of what follows, let <code>To</code> be the destination data type and <code>From</code> be the data type of <code>x</code>, i.e. the source data type. Then, <code>to</code> has the following default behavior:</p><ol type="1">
<li>If the <code>To</code> and <code>From</code> data types are the same, then the object is forwarded as-is.</li>
<li>Otherwise, if <code>From</code> is convertible to <code>To</code> using <code>static_cast</code>, <code>x</code> is converted to <code>From</code> using <code>static_cast</code>.</li>
<li>Otherwise, calling <code>to&lt;From&gt;(x)</code> triggers a static assertion.</li>
</ol>
<p>However, <code>to</code> is a tag-dispatched function, which means that <code>to_impl</code> may be specialized in the <code>boost::hana</code> namespace to customize its behavior for arbitrary data types. Also note that <code>to</code> is tag-dispatched using both the <code>To</code> and the <code>From</code> data types, which means that <code>to_impl</code> is called as <code>to_impl&lt;To, From&gt;::apply(x)</code>.</p>
<h2>Hana-convertibility </h2>
<p>When an object <code>x</code> of data type <code>From</code> can be converted to a data type <code>To</code> using <code>to</code>, we say that <code>x</code> is Hana-convertible to the data type <code>To</code>. We also say that there is a Hana-conversion from <code>From</code> to <code>To</code>. This bit of terminology is useful to avoid mistaking the various kinds of conversions C++ offers.</p>
<h2>Embeddings </h2>
<p>As you might have seen by now, Hana uses algebraic and category- theoretical structures all around the place to help specify concepts in a rigorous way. These structures always have operations associated to them, which is why they are useful. The notion of embedding captures the idea of injecting a smaller structure into a larger one while preserving the operations of the structure. In other words, an embedding is an injective mapping that is also structure-preserving. Exactly what it means for a structure's operations to be preserved is left to explain by the documentation of each structure. For example, when we talk of a Monoid-embedding from a <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> <code>A</code> to a <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> <code>B</code>, we simply mean an injective transformation that preserves the identity and the associative operation, as documented in <code><a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a></code>.</p>
<p>But what does this have to do with the <code>to</code> function? Quite simply, the <code>to</code> function is a mapping between two data types, which will sometimes be some kind of structure, and it is sometimes useful to know whether such a mapping is well-behaved, i.e. lossless and structure preserving. The criterion for this conversion to be well- behaved is exactly that of being an embedding. To specify that a conversion is an embedding, simply use the <code>embedding</code> type as a base class of the corresponding <code>to_impl</code> specialization. Obviously, you should make sure the conversion is really an embedding, unless you want to shoot yourself in the foot.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The data type to which <code>x</code> should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to convert to the given data type.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y, <span class="keyword">typename</span> Z&gt;</div>
<div class="line"><span class="keyword">struct </span>Triple {</div>
<div class="line">    X first;</div>
<div class="line">    Y second;</div>
<div class="line">    Z third;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> triple = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div>
<div class="line">    <span class="keywordflow">return</span> Triple&lt;decltype(x), decltype(y), decltype(z)&gt;{x, y, z};</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y, <span class="keyword">typename</span> Z&gt;</div>
<div class="line">    <span class="keyword">struct </span>to_impl&lt;Tuple, Triple&lt;X, Y, Z&gt;&gt; {</div>
<div class="line">        <span class="keyword">static</span> constexpr <span class="keyword">auto</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(Triple&lt;X, Y, Z&gt; xs) {</div>
<div class="line">            <span class="keywordflow">return</span> make&lt;Tuple&gt;(xs.first, xs.second, xs.third);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        to&lt;Tuple&gt;(triple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga38cf78e1e3e262f7f1c71ddd9ca70cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename optional_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::is_a = see-documentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2is__a_8hpp.html">boost/hana/fwd/core/is_a.hpp</a>&gt;</code></p>

<p>Returns whether the data type of an object matches a given data type. </p>
<p>Given a data type <code>D</code> and a C++ type <code>T</code>, <code>is_a&lt;D, T&gt;</code> is a compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> representing whether the data type of <code>T</code> is exactly <code>D</code>. In other words, it is equivalent to </p><div class="fragment"><div class="line">std::is_same&lt;D, datatype_t&lt;T&gt;&gt;</div>
</div><!-- fragment --><p>For convenience, an alternate syntax is provided for using <code>is_a</code>. Specifically, <code>is_a&lt;D&gt;</code> is a function object returning whether the argument it is passed is of data type <code>D</code>. In other words, </p><div class="fragment"><div class="line">is_a&lt;D&gt;(x) == <a class="code" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">is_a</a>&lt;D, decltype(x)&gt;</div>
</div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line">static_assert(<a class="code" href="group__group-core.html#ga38cf78e1e3e262f7f1c71ddd9ca70cd9">is_a</a>&lt;Tuple, decltype(make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3))&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!is_a&lt;Tuple, void&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-core.html#ga7fdbde52f5fe384a816c6f39ff272df9">is_an</a>&lt;IntegralConstant&lt;int&gt;&gt;(int_&lt;10&gt;), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga1d92480f0af1029878e773dafa3e2f60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Datatype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::make</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2make_8hpp.html">boost/hana/fwd/core/make.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create an object of the given data type with the given arguments. </p>
<p>This function serves the same purpose as constructors in usual C++. However, instead of creating an object of a specific C++ type, it creates an object of a specific data type, with a C++ type that is left unspecified in the general case.</p>
<p>This function is actually a variable template, so <code>make&lt;T&gt;</code> can be passed around as a function object creating an object of data type <code>T</code>. Also, it uses tag-dispatching so this is how it should be customized for user-defined data types.</p>
<p>Finally, the default implementation of <code>make</code> is equivalent to calling the constructor of the given data type with the corresponding arguments. In other words, by default, </p><div class="fragment"><div class="line">make&lt;T&gt;(args...) == T(args...)</div>
</div><!-- fragment --><p>Note that the arguments are perfectly forwarded and the form of construction which is used is exactly as documented, i.e. <code>T(args...)</code>. However, if <code>T(args...)</code> is not a valid expression, a compilation error is triggered. This default behavior is useful because it makes foreign C++ types that have no notion of <em>data type</em> constructible with <code>make</code> out-of-the-box, since their data type is exactly themselves.</p>
<h2>Example </h2>
<div class="fragment"><div class="line">_tuple&lt;int, char, double, std::string&gt; ts{1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abcd&quot;</span>};</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ts == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, std::string{<span class="stringliteral">&quot;abcd&quot;</span>}));</div>
<div class="line"></div>
<div class="line">std::string foo{<span class="stringliteral">&quot;foo&quot;</span>}; <span class="comment">// std::string has no notion of data type</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(make&lt;std::string&gt;(<span class="stringliteral">&quot;foo&quot;</span>) == foo);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga91ecb6ee4fe2f7d156e5026e37df8946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Concept , typename optional_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::models = see-documentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2models_8hpp.html">boost/hana/fwd/core/models.hpp</a>&gt;</code></p>

<p>Returns whether the data type of an object is a model of the given concept. </p>
<p>Given a C++ type <code>T</code> and a concept <code>Concept</code>, <code>models&lt;Concept, T&gt;</code> is a compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> representing whether <code>T</code>'s data type is a model of <code>Concept</code>. Usually, concepts provide methods, some of which <b>must</b> be implemented in order to model the concept, and the others are given a default definition in terms of the mandatory ones. More specifically, <code>models</code> returns whether a minimal complete definition of a concept is provided by the data type. However, concepts also usually provide semantic requirements (called laws) that must be satisfied by their models; <code>models</code> does not attempt to check whether those laws are satisfied. In fact, <code>models</code> does not even check whether the provided minimal complete definition is syntactically correct, but only if it is there.</p>
<p>A few concepts (like <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a>) do not introduce methods that suffice to provide a minimal complete definition. They provide semantic guarantees through laws and superclasses, and they usually also provide methods that do useful things with existing methods and those additional guarantees. In this case, it is usually necessary to explicitly specialize <code>models_impl</code> in the <code>boost::hana</code> namespace. When this is the case, the concept should document it.</p>
<dl class="section note"><dt>Note</dt><dd><code>models</code> is a tag-dispatched method. More specifically, <code>models&lt;Concept, T&gt;</code> dispatches to <code>models_impl&lt;Concept, datatype_t&lt;T&gt;&gt;</code>, which should be a metafunction with a nested boolean <code><a class="el" href="structboost_1_1hana_1_1Constant.html#adea9453327ac4d6834a555ae9887d3f5" title="Return the compile-time value associated to a constant. ">value</a></code> representing whether <code>datatype_t&lt;T&gt;</code> models the concept <code>Concept</code>.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(models&lt;Iterable, Tuple&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!<a class="code" href="group__group-core.html#ga91ecb6ee4fe2f7d156e5026e37df8946">models</a>&lt;Iterable, IntegralConstant&lt;int&gt;&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><h2>How does it work </h2>
<p>When a concept writer provides minimal complete definitions in terms of other methods introduced by the concept, they specialize the <code>models_impl</code> metafunction so that whenever a proper minimal complete definition is provided by the user, <code>models</code> returns true. Here's an example of how a simple concept could support <code>models</code>:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2models_8hpp.html">boost/hana/core/models.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2default_8hpp.html">boost/hana/core/default.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterable_8hpp.html">boost/hana/iterable.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Printable { };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl : <a class="code" href="structboost_1_1hana_1_1default__.html">default_</a> {</div>
<div class="line">    <span class="comment">/* no definition; `print(x)` fails at compile-time by default */</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> print = [](std::ostream&amp; os, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> print_impl&lt;datatype_t&lt;decltype(x)&gt;&gt;<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">::apply</a>(os, x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">struct </span>models_impl&lt;Printable, T&gt;</div>
<div class="line">        : std::integral_constant&lt;bool, !is_default&lt;print_impl&lt;T&gt;&gt;{}&gt;</div>
<div class="line">    { };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person { std::string name; };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl&lt;Person&gt; {</div>
<div class="line">    <span class="keyword">static</span> std::ostream&amp; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::ostream&amp; os, Person <span class="keyword">const</span>&amp; p) {</div>
<div class="line">        os &lt;&lt; p.name;</div>
<div class="line">        <span class="keywordflow">return</span> os;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">static_assert(_models&lt;Printable, Person&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    print(std::cout, Person{<span class="stringliteral">&quot;Louis&quot;</span>});</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa7d2efbdd45154b3a1547fce93cf19a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Datatype , typename Method &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::has_operator = see-documentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2core_2operators_8hpp.html">boost/hana/fwd/core/operators.hpp</a>&gt;</code></p>

<p>Returns whether the operator associated to a given method is enabled for the given data type. </p>
<p>Given a data type <code>T</code> and the type <code>decltype(m)</code> of a method <code>m</code>, <code>has_operator</code> returns whether <code>m</code> has an operator associated to it and whether that operator is enabled for objects of data type <code>T</code>, as documented by <code><a class="el" href="structboost_1_1hana_1_1operators_1_1of.html" title="Controls the operator aliases that are enabled for a data type. ">operators::of</a></code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="comparable_8hpp.html">boost/hana/comparable.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2operators_8hpp.html">boost/hana/core/operators.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The operators are made findable to ADL by making `operators::adl` a</span></div>
<div class="line"><span class="comment">// template parameter.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> = operators::adl&gt;</div>
<div class="line"><span class="keyword">struct </span>Person_ { std::string name; };</div>
<div class="line"><span class="keyword">using</span> Person = Person_&lt;&gt;;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Once the operators can be found by name lookup, we still need to</span></div>
<div class="line"><span class="comment">// specialize the `operators::of` trait to enable them, or we could</span></div>
<div class="line"><span class="comment">// have used a nested `hana::operators` type too.</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana { <span class="keyword">namespace </span>operators {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>of&lt;Person&gt;</div>
<div class="line">        : <a class="code" href="structboost_1_1hana_1_1operators_1_1of.html">operators::of</a>&lt;Comparable&gt;</div>
<div class="line">    { };</div>
<div class="line">}}}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Here, the operators are made findable by ADL by using `operators::adl` as</span></div>
<div class="line"><span class="comment">// a base class. Unfortunately, we lose PODness even though `operators::adl`</span></div>
<div class="line"><span class="comment">// is empty, which is why it might sometimes be useful to use `operators::adl`</span></div>
<div class="line"><span class="comment">// as a template parameter instead.</span></div>
<div class="line"><span class="keyword">struct </span>Employee : <a class="code" href="structboost_1_1hana_1_1operators_1_1adl.html">operators::adl</a> {</div>
<div class="line">    <span class="keyword">explicit</span> Employee(std::string n) : name{n} { }</div>
<div class="line">    std::string name;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This time, we use the nested `hana::operators` type to enable the</span></div>
<div class="line">    <span class="comment">// operators for Comparable.</span></div>
<div class="line">    <span class="keyword">struct </span>hana {</div>
<div class="line">        <span class="keyword">struct </span>operators</div>
<div class="line">            : <a class="code" href="structboost_1_1hana_1_1operators_1_1of.html">boost::hana::operators::of</a>&lt;Comparable&gt;</div>
<div class="line">        { };</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>equal_impl&lt;Person, Person&gt; {</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(Person x, Person y)</div>
<div class="line">        { <span class="keywordflow">return</span> x.name == y.name; }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>equal_impl&lt;Employee, Employee&gt; {</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(Employee x, Employee y)</div>
<div class="line">        { <span class="keywordflow">return</span> x.name == y.name; }</div>
<div class="line">    };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    static_assert(<a class="code" href="group__group-core.html#gaa7d2efbdd45154b3a1547fce93cf19a4">has_operator</a>&lt;Person, decltype(equal)&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(<a class="code" href="group__group-core.html#gaa7d2efbdd45154b3a1547fce93cf19a4">has_operator</a>&lt;Person, decltype(not_equal)&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    static_assert(<a class="code" href="group__group-core.html#gaa7d2efbdd45154b3a1547fce93cf19a4">has_operator</a>&lt;Employee, decltype(equal)&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(<a class="code" href="group__group-core.html#gaa7d2efbdd45154b3a1547fce93cf19a4">has_operator</a>&lt;Employee, decltype(not_equal)&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>}, bill{<span class="stringliteral">&quot;Bill&quot;</span>};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(john == john &amp;&amp; john != bill);</div>
<div class="line"></div>
<div class="line">    Employee bob{<span class="stringliteral">&quot;Bob&quot;</span>}, alice{<span class="stringliteral">&quot;Alice&quot;</span>};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(bob != alice);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
