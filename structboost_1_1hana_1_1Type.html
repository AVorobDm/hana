<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Type Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/fb54ae3856341ef4bd3acf877ccf24836fc079d9/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/decayed/g, "decayed".link("index.html#tutorial-glossary-decayed").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/unspecified-type/g, "unspecified-type".link("index.html#tutorial-glossary-unspecified_type").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.5.0/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Type.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1Type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Type Struct Reference<div class="ingroups"><a class="el" href="group__group-datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Represents a C++ type. </p>
<dl class="section note"><dt>Note</dt><dd>This page explains how Types work at a low level. To gain intuition about type-level metaprogramming in Hana, you should read the <a class="el" href="index.html#tutorial-type">tutorial section</a> on type-level computations.</dd></dl>
<p>A <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code> is a special kind of object representing a C++ type like <code>int</code>, <code>void</code>, <code>std::vector&lt;float&gt;</code> or anything else you can imagine. Basically, the trick to implement such an object is to create the following dummy type: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>_type { };</div>
</div><!-- fragment --><p>Now, if we want to represent the type <code>int</code> by an object, we just create the following object </p><div class="fragment"><div class="line">_type&lt;int&gt; foo;</div>
</div><!-- fragment --><p> and pretend that <code>foo</code> represents the type <code>int</code>. Note that since <code>_type&lt;int&gt;</code> can only be default constructed and hence has only one value, we could even not bother giving this object a name and we could simply use the <code>_type&lt;int&gt;{}</code> expression. The point here is that there is nothing special about the <code>foo</code> variable; it is just an alias for <code>_type&lt;int&gt;{}</code>.</p>
<blockquote class="doxtable">
<p><b>Note</b> This is not exactly how <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>s are implemented in Hana because of some subtleties; things were dumbed down here for the sake of clarity. Please check below to know exactly what you can expect from a <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>. </p>
</blockquote>
<p>Now, let's say we wanted to transform our type <code>int</code> (represented by <code>foo</code>) into a type <code>int*</code> (represented by some other variable); how could we do that? More generally, how could we transform a type <code>T</code> into a type <code>T*</code>? Let's write a function! </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">_type&lt;T*&gt; add_pointer(_type&lt;T&gt; foo) {</div>
<div class="line">    _type&lt;T*&gt; bar;</div>
<div class="line">    <span class="keywordflow">return</span> bar;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We just let the compiler deduce the <code>T</code>, and from that we are able to generate the proper return type. That's it for the signature. For the implementation, we provide the simplest one that will make the code compile; we create a dummy object of the proper type and we return it. We can now use our function like: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> bar = add_pointer(foo);</div>
<div class="line"><span class="keyword">auto</span> baz = add_pointer(bar);</div>
</div><!-- fragment --><p> and we now have objects that represent the types <code>int*</code> and <code>int**</code>, respectively.</p>
<p>As a side note, since we're lazy and we want to save as many keystrokes as possible, we'll use a variable template (new in C++14) to create our dummy variables: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">_type&lt;T&gt; <a class="code" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a>;</div>
</div><!-- fragment --><p> Instead of typing <code>foo</code> or <code>_type&lt;int&gt;{}</code>, we can now simply write <code>type&lt;int&gt;</code>, which is effectively the same but looks better.</p>
<p>However, the current definition of <code>_type</code> does not make it very useful. Indeed, we are only able to copy those objects around and perform pattern matching in template functions, which is still a bit limited. To make them more widely useful, we add the requirement that a <code>_type&lt;T&gt;</code> provides a nested alias to the type it wraps. In Boost.MPL parlance, we make <code>_type&lt;T&gt;</code> a nullary metafunction: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>_type {</div>
<div class="line">    <span class="keyword">using</span> type = T;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now, we can get the type represented by one of our objects without having to perform pattern matching inside a template function: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> bar = type&lt;int*&gt;;</div>
<div class="line"><span class="keyword">using</span> Bar = decltype(bar)::type;</div>
<div class="line">static_assert(std::is_same&lt;int*, Bar&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>Also, this makes any function returning a <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code> easily usable as a classic metafunction, by simply using decltype. For example, let's consider the following function, which finds the largest type in a sequence of types:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Types&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> largest(Types ...types) {</div>
<div class="line">    <span class="keywordflow">return</span> maximum.by(ordering(<a class="code" href="structboost_1_1hana_1_1Type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>), make&lt;Tuple&gt;(types...));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> size&gt;</div>
<div class="line"><span class="keyword">struct </span>storage { <span class="keywordtype">char</span> s[size]; };</div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    largest(type&lt;storage&lt;1&gt;&gt;, type&lt;storage&lt;2&gt;&gt;, type&lt;storage&lt;3&gt;&gt;) == type&lt;storage&lt;3&gt;&gt;</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To make it a classic metafunction instead, we only need to modify it slightly using <code>decltype</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Note: tuple_t&lt;T...&gt; is equivalent to make&lt;Tuple&gt;(type&lt;T&gt;...)</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keyword">struct </span>largest</div>
<div class="line">    : decltype(maximum.by(ordering(sizeof_), tuple_t&lt;T...&gt;))</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> size&gt;</div>
<div class="line"><span class="keyword">struct </span>storage { <span class="keywordtype">char</span> s[size]; };</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    largest&lt;storage&lt;1&gt;, storage&lt;2&gt;, storage&lt;3&gt;&gt;::type,</div>
<div class="line">    storage&lt;3&gt;</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> While this new paradigm for type level programming might be difficult to grok at first, it will make more sense as you use it more and more. You will also come to appreciate how it blurs the line between types and values, opening new exciting possibilities.</p>
<h2>Lvalues and rvalues </h2>
<p>When storing <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>s in heterogeneous containers, some algorithms will return references to those objects. Since we are primarily interested in accessing their nested <code><a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0" title="Creates an object representing the C++ type T. ">type</a></code>, receiving a reference is undesirable; we would end up trying to fetch the nested <code><a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0" title="Creates an object representing the C++ type T. ">type</a></code> inside a reference type, which is a compilation error: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ts = std::make_tuple(type&lt;int&gt;, type&lt;char&gt;);</div>
<div class="line"><span class="comment">// Error; decltype(...) is a reference!</span></div>
<div class="line"><span class="keyword">using</span> T = decltype(std::get&lt;1&gt;(ts))::type;</div>
</div><!-- fragment --><p>For this reason, <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>s provide an overload of the unary <code>+</code> operator that can be used to turn a lvalue into a rvalue. So when using a result which might be a reference to a <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code> object, one can use <code>+</code> to make sure a rvalue is obtained before fetching its nested <code><a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0" title="Creates an object representing the C++ type T. ">type</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ts = std::make_tuple(type&lt;int&gt;, type&lt;char&gt;);</div>
<div class="line"><span class="comment">// Good; decltype(+...) is an rvalue.</span></div>
<div class="line"><span class="keyword">using</span> T = decltype(+std::get&lt;1&gt;(ts))::type;</div>
</div><!-- fragment --><h2>The actual representation of a <a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a> </h2>
<p>For subtle reasons having to do with ADL, the actual type of the <code>type&lt;T&gt;</code> expression is not <code>_type&lt;T&gt;</code>. It is a dependent type which inherits <code>_type&lt;T&gt;</code>. Hence, you should never rely on the fact that <code>type&lt;T&gt;</code> is of type <code>_type&lt;T&gt;</code>, but you can rely on the fact that it inherits it, which is different in some contexts, e.g. for template specialization.</p>
<h2>Modeled concepts </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> (operators provided)<br />
Two <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>s are equal if and only if they represent the same C++ type. Hence, equality is equivalent to the <code>std::is_same</code> type trait. <div class="fragment"><div class="line"><span class="keyword">struct </span>T;</div>
<div class="line"><span class="keyword">struct </span>U;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(type&lt;T&gt; == type&lt;T&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(type&lt;T&gt; != type&lt;U&gt;);</div>
</div><!-- fragment --></li>
</ol>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a4b171ee57f23017113921071f72639d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b171ee57f23017113921071f72639d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr unspecified type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a> {}</td></tr>
<tr class="memdesc:a4b171ee57f23017113921071f72639d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object representing the C++ type <code>T</code>.  <a href="#a4b171ee57f23017113921071f72639d0">More...</a><br /></td></tr>
<tr class="separator:a4b171ee57f23017113921071f72639d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68ff2275cbb295556d83598f04e39a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a> = see documentation</td></tr>
<tr class="memdesc:a7d68ff2275cbb295556d83598f04e39a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>decltype</code> keyword, lifted to Hana.  <a href="#a7d68ff2275cbb295556d83598f04e39a">More...</a><br /></td></tr>
<tr class="separator:a7d68ff2275cbb295556d83598f04e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8833c714e03f37d7e593915a407e6a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3c8833c714e03f37d7e593915a407e6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Type.html#a3c8833c714e03f37d7e593915a407e6a">make&lt; Type &gt;</a> = <a class="el" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a></td></tr>
<tr class="memdesc:a3c8833c714e03f37d7e593915a407e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>decltype_</code>, provided for convenience.  <a href="#a3c8833c714e03f37d7e593915a407e6a">More...</a><br /></td></tr>
<tr class="separator:a3c8833c714e03f37d7e593915a407e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b702b280ca02f118affaaca9112a8c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a></td></tr>
<tr class="memdesc:a26b702b280ca02f118affaaca9112a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>sizeof</code> keyword, lifted to Hana.  <a href="#a26b702b280ca02f118affaaca9112a8c">More...</a><br /></td></tr>
<tr class="separator:a26b702b280ca02f118affaaca9112a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd9ac456f4b5574dcb16384dbb85736"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Type.html#a6fd9ac456f4b5574dcb16384dbb85736">alignof_</a></td></tr>
<tr class="memdesc:a6fd9ac456f4b5574dcb16384dbb85736"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>alignof</code> keyword, lifted to Hana.  <a href="#a6fd9ac456f4b5574dcb16384dbb85736">More...</a><br /></td></tr>
<tr class="separator:a6fd9ac456f4b5574dcb16384dbb85736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Type.html#a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b">is_valid</a></td></tr>
<tr class="memdesc:a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a SFINAE-friendly expression is valid.  <a href="#a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b">More...</a><br /></td></tr>
<tr class="separator:a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a4b171ee57f23017113921071f72639d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unspecified type type {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object representing the C++ type <code>T</code>. </p>

</div>
</div>
<a class="anchor" id="a7d68ff2275cbb295556d83598f04e39a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto decltype_ = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>decltype</code> keyword, lifted to Hana. </p>
<p><code>decltype_</code> is somewhat equivalent to <code>decltype</code> in that it returns the type of an object, except it returns it as a <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code> object which is a first-class citizen of Hana instead of a raw C++ type. Specifically, given an object <code>x</code>, <code>decltype_</code> satisfies </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(x) == type&lt;decltype(x) with references stripped&gt;</div>
</div><!-- fragment --><p>As you can see, <code>decltype_</code> will strip any reference from the object's actual type. The reason for doing so is explained below. However, any <code>cv</code>-qualifiers will be retained. Also, when given a <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code> object, <code>decltype_</code> is just the identity function. Hence, for any C++ type <code>T</code>, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(type&lt;T&gt;) == type&lt;T&gt;</div>
</div><!-- fragment --><p>In conjunction with the way <code>metafunction</code> &amp; al. are specified, this behavior makes it easier to interact with both types and values at the same time. However, it does make it impossible to create a <a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a> containing a <a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a> with <code>decltype_</code>. In other words, it is not possible to create a <code>type&lt;decltype(type&lt;T&gt;)&gt;</code> with this utility, because <code>decltype_(type&lt;T&gt;)</code> would be just <code>type&lt;T&gt;</code> instead of <code>type&lt;decltype(type&lt;T&gt;)&gt;</code>. This use case is assumed to be rare and a hand-coded function can be used if this is needed.</p>
<h3>Rationale for stripping the references</h3>
<p>The rules for template argument deduction are such that a perfect solution that always matches <code>decltype</code> is impossible. Hence, we have to settle on a solution that's good and and consistent enough for our needs. One case where matching <code>decltype</code>'s behavior is impossible is when the argument is a plain, unparenthesized variable or function parameter. In that case, <code>decltype_</code>'s argument will be deduced as a reference to that variable, but <code>decltype</code> would have given us the actual type of that variable, without references. Also, given the current definition of <code>metafunction</code> &amp; al., it would be mostly useless if <code>decltype_</code> could return a reference, because it is unlikely that <code>F</code> expects a reference in its simplest use case: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="keyword">auto</span> result = metafunction&lt;F&gt;(i);</div>
</div><!-- fragment --><p>Hence, always discarding references seems to be the least painful solution.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X { };</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(X{}) == type&lt;X&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(type&lt;X&gt;) == type&lt;X&gt;);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(1) == type&lt;int&gt;);</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> <span class="keyword">const</span>&amp; i = 1;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(i) == type&lt;int const&gt;);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3c8833c714e03f37d7e593915a407e6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto make&lt; <a class="el" href="structboost_1_1hana_1_1Type.html">Type</a> &gt; = <a class="el" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>decltype_</code>, provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X { };</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Type.html#a3c8833c714e03f37d7e593915a407e6a">make&lt;Type&gt;</a>(X{}) == <a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(X{}));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Type.html#a3c8833c714e03f37d7e593915a407e6a">make&lt;Type&gt;</a>(type&lt;X&gt;) == <a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(type&lt;X&gt;));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a26b702b280ca02f118affaaca9112a8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sizeof_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keyword">using</span> T = <span class="keyword">typename</span> decltype(<a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(x))::<a class="code" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a>;</div>
<div class="line">        <span class="keywordflow">return</span> size_t&lt;sizeof(T)&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><code>sizeof</code> keyword, lifted to Hana. </p>
<p><code>sizeof_</code> is somewhat equivalent to <code>sizeof</code> in that it returns the size of an expression or type, but it takes an arbitrary expression or a <a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a> object and returns its size as an <a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. Specifically, given an expression <code>expr</code>, <code>sizeof_</code> satisfies </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>(expr) == size_t&lt;sizeof(decltype(expr) with references stripped)&gt;</div>
</div><!-- fragment --><p>However, given a <a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a> object, <code>sizeof_</code> will simply fetch the size of the C++ type represented by that object. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>(type&lt;T&gt;) == size_t&lt;sizeof(T)&gt;</div>
</div><!-- fragment --><p>The behavior of <code>sizeof_</code> is consistent with that of <code>decltype_</code>. In particular, see <code>decltype_</code>'s documentation to understand why references are always stripped by <code>sizeof_</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X { };</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1Type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>(type&lt;X&gt;) == <span class="keyword">sizeof</span>(X), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1Type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>(1) == <span class="keyword">sizeof</span>(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1Type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>(type&lt;int&gt;) == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6fd9ac456f4b5574dcb16384dbb85736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto alignof_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keyword">using</span> T = <span class="keyword">typename</span> decltype(<a class="code" href="structboost_1_1hana_1_1Type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(x))::<a class="code" href="structboost_1_1hana_1_1Type.html#a4b171ee57f23017113921071f72639d0">type</a>;</div>
<div class="line">        <span class="keywordflow">return</span> size_t&lt;alignof(T)&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><code>alignof</code> keyword, lifted to Hana. </p>
<p><code>alignof_</code> is somewhat equivalent to <code>alignof</code> in that it returns the alignment required by any instance of a type, but it takes a <a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a> object and returns its alignment as an <a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. Like <code>sizeof</code> which works for expressions and type-ids, <code>alignof_</code> can also be called on an arbitrary expression. Specifically, given an expression <code>expr</code> and a C++ type <code>T</code>, <code>alignof_</code> satisfies </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a6fd9ac456f4b5574dcb16384dbb85736">alignof_</a>(expr) == size_t&lt;alignof(decltype(expr) with references stripped)&gt;</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a6fd9ac456f4b5574dcb16384dbb85736">alignof_</a>(type&lt;T&gt;) == size_t&lt;alignof(T)&gt;</div>
</div><!-- fragment --><p>The behavior of <code>alignof_</code> is consistent with that of <code>decltype_</code>. In particular, see <code>decltype_</code>'s documentation to understand why references are always stripped by <code>alignof_</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X { };</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1Type.html#a6fd9ac456f4b5574dcb16384dbb85736">alignof_</a>(type&lt;X&gt;) == <span class="keyword">alignof</span>(X), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1Type.html#a6fd9ac456f4b5574dcb16384dbb85736">alignof_</a>(1) == <span class="keyword">alignof</span>(decltype(1)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1Type.html#a6fd9ac456f4b5574dcb16384dbb85736">alignof_</a>(type&lt;int&gt;) == <span class="keyword">alignof</span>(<span class="keywordtype">int</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto is_valid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> [](<span class="keyword">auto</span>&amp;&amp; ...args) {</div>
<div class="line">            <span class="keywordflow">return</span> whether f(args...) is a valid expression;</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Checks whether a SFINAE-friendly expression is valid. </p>
<p>Given a SFINAE-friendly function, <code>is_valid</code> returns whether the function call is valid with the given arguments. Specifically, given a function <code>f</code> and arguments <code>args...</code>, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b">is_valid</a>(f, args...) == whether f(args...) is valid</div>
</div><!-- fragment --><p>The result is returned as a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. Furthermore, <code>is_valid</code> can be used in curried form as follows: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Type.html#a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b">is_valid</a>(f)(args...)</div>
</div><!-- fragment --><p>This syntax makes it easy to create functions that check the validity of a generic expression on any given argument(s).</p>
<p>Also note that the arguments to <code>is_valid</code> may be either <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>s or non-<code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>s. The behavior of <code>is_valid</code> on non-<code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code>s is consistent with that of <code>sizeof_</code> and other <code><a class="el" href="structboost_1_1hana_1_1Type.html" title="Represents a C++ type. ">Type</a></code> utilities.</p>
<dl class="section warning"><dt>Warning</dt><dd>To check whether calling a nullary function <code>f</code> is valid, one should use the <code>is_valid(f)()</code> syntax. Indeed, <code>is_valid(f /* no args */)</code> will be interpreted as the currying of <code>is_valid</code> to <code>f</code> rather than the application of <code>is_valid</code> to <code>f</code> and no arguments.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person { std::string name; };</div>
<div class="line"><span class="keyword">auto</span> has_name = <a class="code" href="structboost_1_1hana_1_1Type.html#a2d2e7e08e284f7e0bd1bd9c3ad0e0a2b">is_valid</a>([](<span class="keyword">auto</span> p) -&gt; decltype(p.name) { });</div>
<div class="line"></div>
<div class="line">Person joe{<span class="stringliteral">&quot;Joe&quot;</span>};</div>
<div class="line">static_assert(has_name(joe), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!has_name(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(has_name(type&lt;Person&gt;), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!has_name(type&lt;int&gt;), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Type.html">Type</a></li>
  </ul>
</div>
</body>
</html>
