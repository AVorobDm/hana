<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Record Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Record.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1Record-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Record Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> concept represents record-like user-defined types. </p>
<p>A record-like type is any type which is fundamentally a <code>struct</code>, regardless of the implementation of its accessors and other similar details. In some sence, Records can be seen as maps to which keys can't be added.</p>
<p>Models of <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> are created by specifying an ordered mapping from keys to accessors, where keys are objects playing the role of member names, and accessors allow individual members to be retrieved from an object. Specifically, an accessor <code>A</code> for a subobject <code>sub</code> of type <code>T</code> inside an object of type <code>Obj</code> is a function such that </p><div class="fragment"><div class="line">A(Obj&amp;)       -&gt; T&amp;</div>
<div class="line">A(Obj <span class="keyword">const</span>&amp;) -&gt; T <span class="keyword">const</span>&amp;</div>
<div class="line">A(Obj&amp;&amp;)      -&gt; T</div>
</div><!-- fragment --><p>where <code>F(X) -&gt; Y</code> means that the return type of <code>F</code> when called with an object of type <code>X</code> is exactly <code>Y</code>. Moreover, <code>A</code> may only access and/or modify the subobject <code>sub</code>. This restriction exists so that </p><div class="fragment"><div class="line">Obj obj = {...};</div>
<div class="line"><span class="keyword">auto</span> subobject_1 = accessor_1(std::move(obj));</div>
<div class="line"><span class="keyword">auto</span> subobject_2 = accessor_2(std::move(obj));</div>
</div><!-- fragment --><p>is valid code which extracts two subobjects of <code>obj</code> while (perhaps) moving from them. If <code>accessor_1</code> was allowed to modify arbitrary subobjects of <code>obj</code>, we could end up accessing a moved-from object with <code>accessor_2</code> (if <code>accessor_1</code> had moved from it). Similarly, if <code>accessor_2</code> was allowed to access arbitrary subobjects of <code>obj</code>, it could end up accessing the moved-from subobject that was moved-from with <code>accessor_1</code>.</p>
<h2>Minimal complete definition </h2>
<p><code>members</code></p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structboost_1_1hana_1_1Record.html#a8b4b7796bad58bc18683d99ca90a0034">BOOST_HANA_DEFINE_RECORD</a> and <a class="el" href="structboost_1_1hana_1_1Record.html#ac0c49e26841cde4895d867e2e479e085">BOOST_HANA_DEFINE_RECORD_INTRUSIVE</a> macros can also be used to define models of <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code>.</dd></dl>
<h2>Provided superclass models </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code><br />
Two <code>Records</code> of the same data type <code>R</code> are equal if and only if all their members are equal. The members are compared in the same order as they appear in <code>members&lt;R&gt;()</code>.</li>
<li><code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code><br />
Folding a <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> <code>R</code> is equivalent to folding a list of its members, in the same order as they appear in <code>members&lt;R&gt;()</code>.</li>
<li><code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code><br />
Searching a <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> <code>r</code> is equivalent to searching <code>to&lt;<a class="el" href="structboost_1_1hana_1_1Map.html" title="A basic associative array requiring unique and Comparable keys. ">Map</a>&gt;(r)</code>.</li>
</ol>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>The restrictions on what constitutes an accessor are pretty fierce, and using <code>std::move</code> on the same object twice feels completely wrong. Is there a better way to allow an object to be decomposed optimally into its subobjects without resorting to such hacks?</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="id_8hpp.html">boost/hana/functional/id.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="record_8hpp.html">boost/hana/record.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The keys can be anything as long as they are compile-time comparable.</span></div>
<div class="line">constexpr <span class="keyword">auto</span> name = decltype_(&amp;Person::name);</div>
<div class="line">constexpr <span class="keyword">auto</span> age = decltype_(&amp;Person::age);</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>members_impl&lt;Person&gt; {</div>
<div class="line">        <span class="keyword">static</span> BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>() {</div>
<div class="line">            <span class="keywordflow">return</span> make&lt;Tuple&gt;(</div>
<div class="line">                make&lt;Pair&gt;(name, [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(std::forward&lt;decltype(p)&gt;(p).name);</div>
<div class="line">                }),</div>
<div class="line">                make&lt;Pair&gt;(age, [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(std::forward&lt;decltype(p)&gt;(p).age);</div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30}, bob{<span class="stringliteral">&quot;Bob&quot;</span>, 40};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(equal(john, john));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(not_equal(john, bob));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(find(john, name) == just(<span class="stringliteral">&quot;John&quot;</span>));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(find(john, age) == just(30));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(find(john, <span class="stringliteral">&quot;clearly not a member&quot;</span>) == nothing);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(to&lt;Tuple&gt;(john) == make&lt;Tuple&gt;(<span class="stringliteral">&quot;John&quot;</span>, 30));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(to&lt;Map&gt;(john) == make&lt;Map&gt;(</div>
<div class="line">        make&lt;Pair&gt;(name, <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        make&lt;Pair&gt;(age, 30)</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a5ae5ec12bb6524e05cc4750b203c194e"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a5ae5ec12bb6524e05cc4750b203c194e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Record.html#a5ae5ec12bb6524e05cc4750b203c194e">members</a></td></tr>
<tr class="memdesc:a5ae5ec12bb6524e05cc4750b203c194e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of pairs representing the data structure.  <a href="#a5ae5ec12bb6524e05cc4750b203c194e">More...</a><br /></td></tr>
<tr class="separator:a5ae5ec12bb6524e05cc4750b203c194e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c49e26841cde4895d867e2e479e085"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Record.html#ac0c49e26841cde4895d867e2e479e085">BOOST_HANA_DEFINE_RECORD_INTRUSIVE</a>(...)</td></tr>
<tr class="memdesc:ac0c49e26841cde4895d867e2e479e085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a model of <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> with the given members.  <a href="#ac0c49e26841cde4895d867e2e479e085">More...</a><br /></td></tr>
<tr class="separator:ac0c49e26841cde4895d867e2e479e085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4b7796bad58bc18683d99ca90a0034"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Record.html#a8b4b7796bad58bc18683d99ca90a0034">BOOST_HANA_DEFINE_RECORD</a>(...)</td></tr>
<tr class="memdesc:a8b4b7796bad58bc18683d99ca90a0034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a model of <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> with the given members.  <a href="#a8b4b7796bad58bc18683d99ca90a0034">More...</a><br /></td></tr>
<tr class="separator:a8b4b7796bad58bc18683d99ca90a0034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a5ae5ec12bb6524e05cc4750b203c194e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto members</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a list of pairs representing the data structure. </p>
<p>Specifically, <code>members&lt;R&gt;()</code> is a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> of <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>s associating keys to functions, where a pair <code>(k, f)</code> means that the member represented by the key <code>k</code> can be accessed by calling the function <code>f</code> on an object of data type <code>R</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="id_8hpp.html">boost/hana/functional/id.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="record_8hpp.html">boost/hana/record.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The keys can be anything as long as they are compile-time comparable.</span></div>
<div class="line">constexpr <span class="keyword">auto</span> name = decltype_(&amp;Person::name);</div>
<div class="line">constexpr <span class="keyword">auto</span> age = decltype_(&amp;Person::age);</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>members_impl&lt;Person&gt; {</div>
<div class="line">        <span class="keyword">static</span> BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>() {</div>
<div class="line">            <span class="keywordflow">return</span> make&lt;Tuple&gt;(</div>
<div class="line">                make&lt;Pair&gt;(name, [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(std::forward&lt;decltype(p)&gt;(p).name);</div>
<div class="line">                }),</div>
<div class="line">                make&lt;Pair&gt;(age, [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(std::forward&lt;decltype(p)&gt;(p).age);</div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30}, bob{<span class="stringliteral">&quot;Bob&quot;</span>, 40};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(equal(john, john));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(not_equal(john, bob));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(find(john, name) == just(<span class="stringliteral">&quot;John&quot;</span>));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(find(john, age) == just(30));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(find(john, <span class="stringliteral">&quot;clearly not a member&quot;</span>) == nothing);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(to&lt;Tuple&gt;(john) == make&lt;Tuple&gt;(<span class="stringliteral">&quot;John&quot;</span>, 30));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(to&lt;Map&gt;(john) == make&lt;Map&gt;(</div>
<div class="line">        make&lt;Pair&gt;(name, <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        make&lt;Pair&gt;(age, 30)</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac0c49e26841cde4895d867e2e479e085"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_DEFINE_RECORD_INTRUSIVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">BOOST_HANA_PP_DEFINE_RECORD_INTRUSIVE_IMPL(                             \</div>
<div class="line">        BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__),                             \</div>
<div class="line">        BOOST_PP_SEQ_TAIL(BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))            \</div>
<div class="line">    )                                                                       \</div>
</div><!-- fragment -->
<p>Defines a model of <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> with the given members. </p>
<p>Specifically, use this macro in the public section of a user-defined type <code>T</code> to define a model of the <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> concept for <code>T</code>. Note that this only works if the data type of <code>T</code> is <code>T</code> itself.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Record.html#ac0c49e26841cde4895d867e2e479e085">BOOST_HANA_DEFINE_RECORD_INTRUSIVE</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">int</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8b4b7796bad58bc18683d99ca90a0034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_DEFINE_RECORD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">BOOST_HANA_PP_DEFINE_RECORD_IMPL(                                       \</div>
<div class="line">        BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__),                             \</div>
<div class="line">        BOOST_PP_SEQ_TAIL(BOOST_PP_VARIADIC_TO_SEQ(__VA_ARGS__))            \</div>
<div class="line">    )                                                                       \</div>
</div><!-- fragment -->
<p>Defines a model of <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> with the given members. </p>
<p>Specifically, use this macro at <b>global scope</b> to define a model of the <code><a class="el" href="structboost_1_1hana_1_1Record.html" title="The Record concept represents record-like user-defined types. ">Record</a></code> concept for a given data type.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>ns {</div>
<div class="line">    <span class="keyword">struct </span>Person {</div>
<div class="line">        std::string name;</div>
<div class="line">        <span class="keywordtype">int</span> age;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Record.html#a8b4b7796bad58bc18683d99ca90a0034">BOOST_HANA_DEFINE_RECORD</a>(ns::Person,</div>
<div class="line">    (std::string, name),</div>
<div class="line">    (<span class="keywordtype">int</span>, age)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Record.html">Record</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
