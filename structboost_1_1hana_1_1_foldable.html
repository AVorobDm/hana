<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Foldable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_foldable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_foldable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Foldable Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> concept represents data structures that can be folded, i.e. summarized into a single value. </p>
<p>Another way of seeing <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code>s is as data structures supporting internal iteration with the ability to accumulate a result. Also note that since C++ only supports eager evaluation, all models of <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> must represent finite data structures.</p>
<p>Additionally, only structures whose total size is known at compile-time can be models of <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code>. This is because of the <code>unpack</code> method, whose return <em>type</em> depends on the number and types of the objects in the structure.</p>
<dl class="section note"><dt>Note</dt><dd>While the fact that <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> only works for finite structures may seem overly restrictive in comparison to the Haskell definition of <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code>, a finer grained separation of the concepts (see <code><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code> and <code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>) should mitigate the issue.</dd></dl>
<h2>Laws </h2>
<p>For any <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> <code>xs</code>, the following laws must be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.left(xs, s, f) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.left(to&lt;Tuple&gt;(xs), s, f)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.right(xs, s, f) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.right(to&lt;Tuple&gt;(xs), s, f)</div>
</div><!-- fragment --><p>where <code>s</code> and <code>f</code> are an arbitrary state and function that can be used for folding, respectively. Intuitively, these laws say that <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> respects the left-to-right order of elements within a structure.</p>
<h2>Minimal complete definition </h2>
<p>(<code>fold.left</code> and <code>fold.right</code>) or <code>unpack</code></p>
<h2>Provided models </h2>
<ol type="1">
<li>For builtin arrays<br />
Builtin arrays whose size is known can be folded as-if they were homogeneous tuples. However, note that builtin arrays can't be made more than <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> (e.g. <code><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>) because they can't be empty and they also can't be returned from functions. </li>
</ol>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a4e8e653553829fc2bf88f13ab907def1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a> = see documentation</td></tr>
<tr class="memdesc:a4e8e653553829fc2bf88f13ab907def1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold a structure using a binary operation and (optionally) an initial reduction state.  <a href="#a4e8e653553829fc2bf88f13ab907def1">More...</a><br /></td></tr>
<tr class="separator:a4e8e653553829fc2bf88f13ab907def1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d423c33a801e7cf2058faa19423d991"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a9d423c33a801e7cf2058faa19423d991"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a9d423c33a801e7cf2058faa19423d991">monadic_fold</a> = see documentation</td></tr>
<tr class="memdesc:a9d423c33a801e7cf2058faa19423d991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monadic fold of a structure with a binary operation and an optional initial reduction state.  <a href="#a9d423c33a801e7cf2058faa19423d991">More...</a><br /></td></tr>
<tr class="separator:a9d423c33a801e7cf2058faa19423d991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9240a51cd23ef65186e32d643e82f52e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a></td></tr>
<tr class="memdesc:a9240a51cd23ef65186e32d643e82f52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>reverse_fold</code> in Boost.Fusion and Boost.MPL.  <a href="#a9240a51cd23ef65186e32d643e82f52e">More...</a><br /></td></tr>
<tr class="separator:a9240a51cd23ef65186e32d643e82f52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80176fbdfbccc09e902263557eb0984d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a></td></tr>
<tr class="memdesc:a80176fbdfbccc09e902263557eb0984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an action on each element of a foldable, discarding the result each time.  <a href="#a80176fbdfbccc09e902263557eb0984d">More...</a><br /></td></tr>
<tr class="separator:a80176fbdfbccc09e902263557eb0984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb377e43aa7753bb77aa346c67fae0d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a></td></tr>
<tr class="memdesc:a5fb377e43aa7753bb77aa346c67fae0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in a finite structure.  <a href="#a5fb377e43aa7753bb77aa346c67fae0d">More...</a><br /></td></tr>
<tr class="separator:a5fb377e43aa7753bb77aa346c67fae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d3fe103aa2ab8634a824562dd8390c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a95d3fe103aa2ab8634a824562dd8390c">size</a> = <a class="el" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a></td></tr>
<tr class="memdesc:a95d3fe103aa2ab8634a824562dd8390c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>length</code>; provided for consistency with the standard library.  <a href="#a95d3fe103aa2ab8634a824562dd8390c">More...</a><br /></td></tr>
<tr class="separator:a95d3fe103aa2ab8634a824562dd8390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead74d4a75dd467873fcc9124d06b5f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a> = see documentation</td></tr>
<tr class="memdesc:aead74d4a75dd467873fcc9124d06b5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.  <a href="#aead74d4a75dd467873fcc9124d06b5f4">More...</a><br /></td></tr>
<tr class="separator:aead74d4a75dd467873fcc9124d06b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a8fde2d3de61959c99e755a81c0a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a> = see documentation</td></tr>
<tr class="memdesc:ac49a8fde2d3de61959c99e755a81c0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.  <a href="#ac49a8fde2d3de61959c99e755a81c0a1">More...</a><br /></td></tr>
<tr class="separator:ac49a8fde2d3de61959c99e755a81c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99a05a203907d1381a00d9e05425ab7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#ae99a05a203907d1381a00d9e05425ab7">sum</a> = see documentation</td></tr>
<tr class="memdesc:ae99a05a203907d1381a00d9e05425ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the numbers of a structure.  <a href="#ae99a05a203907d1381a00d9e05425ab7">More...</a><br /></td></tr>
<tr class="separator:ae99a05a203907d1381a00d9e05425ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37fd8d56461f749d49423c711e4c67a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#aa37fd8d56461f749d49423c711e4c67a">product</a></td></tr>
<tr class="memdesc:aa37fd8d56461f749d49423c711e4c67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the numbers of a structure.  <a href="#aa37fd8d56461f749d49423c711e4c67a">More...</a><br /></td></tr>
<tr class="separator:aa37fd8d56461f749d49423c711e4c67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca48cce90274a5f54354f9d4622930"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a21ca48cce90274a5f54354f9d4622930">count_if</a></td></tr>
<tr class="memdesc:a21ca48cce90274a5f54354f9d4622930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure for which the <code>predicate</code> is satisfied.  <a href="#a21ca48cce90274a5f54354f9d4622930">More...</a><br /></td></tr>
<tr class="separator:a21ca48cce90274a5f54354f9d4622930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a></td></tr>
<tr class="memdesc:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure that compare equal to a given value.  <a href="#ae0a55dd7eb4bd4f587f51ffd8c923e53">More...</a><br /></td></tr>
<tr class="separator:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3e724580e826eaa39a934eefa2b328"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a></td></tr>
<tr class="memdesc:a0e3e724580e826eaa39a934eefa2b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the elements of a structure as arguments.  <a href="#a0e3e724580e826eaa39a934eefa2b328">More...</a><br /></td></tr>
<tr class="separator:a0e3e724580e826eaa39a934eefa2b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0840e48f29a87467e23d801ca0ca122a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_foldable.html#a0840e48f29a87467e23d801ca0ca122a">fuse</a></td></tr>
<tr class="memdesc:a0840e48f29a87467e23d801ca0ca122a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a function taking multiple arguments into a function that can be called with a <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code>.  <a href="#a0840e48f29a87467e23d801ca0ca122a">More...</a><br /></td></tr>
<tr class="separator:a0840e48f29a87467e23d801ca0ca122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a4e8e653553829fc2bf88f13ab907def1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fold = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold a structure using a binary operation and (optionally) an initial reduction state. </p>
<p>Generally speaking, folding refers to the concept of summarizing a complex structure as a single value, by successively applying a binary operation which reduces two elements of the structure to a single value. Folds come in many flavors; left folds, right folds, folds with and without an initial reduction state, and their monadic variants. This method can be used to access all of the non-monadic fold variants, by using the different syntaxes documented below. Here's a summary of the different folds: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.left(xs, state, f) = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.left(xs, f) = see below</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a> = fold.left</div>
<div class="line"></div>
<div class="line">fold.right(xs, state, f) = see below</div>
<div class="line">fold.right(xs, f) = see below</div>
</div><!-- fragment --><p>In the above, <code>xs</code> is always the structure to be folded. Similarly, <code>state</code> is an initial value to use as the accumulation state.</p>
<p>When the structure is empty, two things may arise. If an initial state was provided, it is returned as-is. Otherwise, if the no-state version of the method was used, an error is triggered. When the stucture contains a single element and the no-state version of the method was used, that single element is returned as is. This behavior is consistent with what happens for empty structures with a provided initial state.</p>
<h2>Left folds (<code>fold.left</code>)</h2>
<p><code>fold.left</code> is a left-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and optionnally an initial state, <code>fold.left</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">f(... f(f(f(x1, x2), x3), x4) ..., xn) <span class="comment">// without state</span></div>
<div class="line">f(... f(f(f(f(state, x1), x2), x3), x4) ..., xn) <span class="comment">// with state</span></div>
</div><!-- fragment --><h3>Signature</h3>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> <code>xs</code> of data type <code>F(T)</code>, a function \( f : S \times T \to S \) and an initial state <code>s</code> of data type <code>S</code>, the signatures for <code>fold.left</code> are </p><p class="formulaDsp">
\[ \mathrm{fold.left} : F(T) \times S \times (S \times T \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathrm{fold.left} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For left folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>fold</code> is equivalent to <code>fold.left</code>, so <code>fold(xs, f)</code> and <code>fold(xs, state, f)</code> are equivalent to <code>fold.left(xs, f)</code> and <code>fold.left(xs, state, f)</code> respectively. This is provided solely for convenience.</dd></dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// with an initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    fold.left(make&lt;Tuple&gt;(2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), <span class="stringliteral">&quot;1&quot;</span>, f)</div>
<div class="line">        ==</div>
<div class="line">    <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// without initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    fold.left(make&lt;Tuple&gt;(<span class="stringliteral">&quot;1&quot;</span>, 2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), f)</div>
<div class="line">        ==</div>
<div class="line">    <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">);</div>
</div><!-- fragment --><h2>Right folds (<code>fold.right</code>)</h2>
<p><code>fold.right</code> is a right-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and optionnally an initial state, <code>fold.right</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn-1, xn) ... )))) <span class="comment">// without state</span></div>
<div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn, state) ... )))) <span class="comment">// with state</span></div>
</div><!-- fragment --><p>It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>fold.left</code>.</p>
<h3>Signature</h3>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code> <code>xs</code> of data type <code>F(T)</code>, a function \( f : T \times S \to S \) and an initial state <code>s</code> of data type <code>S</code>, the signatures for <code>fold.right</code> are </p><p class="formulaDsp">
\[ \mathrm{fold.right} : F(T) \times S \times (T \times S \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathrm{fold.right} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For right folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> f = [=](<span class="keyword">auto</span> element, std::string s) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + to_string(element) + <span class="stringliteral">&quot;, &quot;</span> + s + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// with an initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    fold.right(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4), <span class="stringliteral">&quot;5&quot;</span>, f)</div>
<div class="line">        ==</div>
<div class="line">    <span class="stringliteral">&quot;f(1, f(2, f(3, f(4, 5))))&quot;</span></div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// without initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    fold.right(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4, <span class="stringliteral">&quot;5&quot;</span>), f)</div>
<div class="line">        ==</div>
<div class="line">    <span class="stringliteral">&quot;f(1, f(2, f(3, f(4, 5))))&quot;</span></div>
<div class="line">);</div>
</div><!-- fragment --><h2>Tag-dispatching</h2>
<p>All of the different fold variants are tag-dispatched methods and can be overridden individually. Here is how each variant is tag-dispatched (where <code>Xs</code> is the data type of <code>xs</code>): </p><div class="fragment"><div class="line">fold.left(xs, state, f) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">fold_left_impl&lt;Xs&gt;::apply</a>(xs, state, f)</div>
<div class="line">fold.left(xs, f)        -&gt; fold_left_nostate_impl&lt;Xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, f)</div>
<div class="line"></div>
<div class="line">fold.right(xs, state, f) -&gt; fold_right_impl&lt;Xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, state, f)</div>
<div class="line">fold.right(xs, f)        -&gt; fold_right_nostate_impl&lt;Xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, f)</div>
</div><!-- fragment --><p> <code>fold</code> is not tag-dispatched because it is just an alias to <code>fold.left</code>. </p>

</div>
</div>
<a class="anchor" id="a9d423c33a801e7cf2058faa19423d991"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto monadic_fold = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Monadic fold of a structure with a binary operation and an optional initial reduction state. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes the reader to be accustomed to non-monadic folds as explained by <code>hana::fold</code>.</dd></dl>
<p>The <code>monadic_fold</code> method is used for left or right folding a structure with a monadic binary operation and an optional initial state. Basically, a monadic fold is a fold in which subsequent calls to the binary function are chained with the monadic <code>bind</code> operator of the corresponding <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>. This allows a structure to be folded in a custom monadic context. For example, performing a monadic fold with the <a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a> monad would require the binary function to return the result as a <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code>, and the fold would abort and return nothing whenever one of the accumulation step would fail (i.e. return <code>nothing</code>). If, however, all the reduction steps succeed, then <code>just</code> the result would be returned. Different monads will of course result in different effects.</p>
<p>This method can be used to access all of the monadic fold variants, by using the different syntaxes documented below. Here's a summary: </p><div class="fragment"><div class="line">monadic_fold&lt;M&gt;.left(xs, state, f) = see below</div>
<div class="line">monadic_fold&lt;M&gt;.left(xs, f) = see below</div>
<div class="line">monadic_fold&lt;M&gt; = monadic_fold&lt;M&gt;.left</div>
<div class="line"></div>
<div class="line">monadic_fold&lt;M&gt;.right(xs, state, f) = see below</div>
<div class="line">monadic_fold&lt;M&gt;.right(xs, f) = see below</div>
</div><!-- fragment --><p>In the above, <code>xs</code> is always the structure to be folded. Similarly, <code>state</code> is an initial value to use as the accumulation state.</p>
<p>When the structure is empty, two things may arise. If an initial state was provided, it is lifted to the given <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and returned as-is. Otherwise, if the no-state version of the method was used, an error is triggered. When the stucture contains a single element and the no-state version of the method was used, that single element is lifted into the given <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and returned as is. This behavior is consistent with what happens for empty structures with a provided initial state.</p>
<h2>Monadic left folds (<code>monadic_fold&lt;M&gt;.left</code>)</h2>
<p><code>monadic_fold&lt;M&gt;.left</code> is a left-associative monadic fold. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold&lt;M&gt;.left</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">((((f(state, x1) | f(-, x2)) | f(-, x3)) | ...) | f(-, xn)) <span class="comment">// with state</span></div>
<div class="line">((((f(x1, x2) | f(-, x3)) | f(-, x4)) | ...) | f(-, xn)) <span class="comment">// without state</span></div>
</div><!-- fragment --><p>where <code>f(-, xk)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>bind</code>.</p>
<h3>Signature</h3>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> of data type <code>M</code>, a <a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> of data type <code>F(T)</code>, an initial state of data type <code>S</code> and a function \( f : S \times T \to M(S) \), the signatures of <code>monadic_fold&lt;M&gt;.left</code> are </p><p class="formulaDsp">
\[ \mathrm{monadic\_fold}_M.\mathrm{left} : F(T) \times S \times (S \times T \to M(S)) \to M(S) \]
</p>
<p>for the version with an initial state, and </p><p class="formulaDsp">
\[ \mathrm{monadic\_fold}_M.\mathrm{left} : F(T) \times (T \times T \to M(T)) \to M(T) \]
</p>
<p>for the version without an initial state.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> representing the monadic context in which the fold happens. The return type of <code>f</code> must be in that <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. If the structure is empty, this value is lifted in to the <code>M</code> <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and then returned as-is.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. The function must return its result inside the <code>M</code> <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> builtin_common_t = sfinae([](<span class="keyword">auto</span> t, <span class="keyword">auto</span> u) -&gt; decltype(type&lt;</div>
<div class="line">    std::decay_t&lt;decltype(<span class="keyword">true</span> ? traits::declval(t) : traits::declval(u))&gt;</div>
<div class="line">&gt;) { <span class="keywordflow">return</span> {}; });</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keyword">struct </span>common_type { };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div>
<div class="line"><span class="keyword">struct </span>common_type&lt;T, U&gt;</div>
<div class="line">    : std::conditional_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, T&gt;{} &amp;&amp;</div>
<div class="line">                         std::is_same&lt;std::decay_t&lt;U&gt;, U&gt;{},</div>
<div class="line">        decltype(builtin_common_t(type&lt;T&gt;, type&lt;U&gt;)),</div>
<div class="line">        common_type&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> ...Tn&gt;</div>
<div class="line"><span class="keyword">struct </span>common_type&lt;T1, Tn...&gt;</div>
<div class="line">    : decltype(monadic_fold&lt;Maybe&gt;.left(</div>
<div class="line">        tuple_t&lt;Tn...&gt;,</div>
<div class="line">        type&lt;std::decay_t&lt;T1&gt;&gt;,</div>
<div class="line">        sfinae(metafunction&lt;common_type&gt;)</div>
<div class="line">    ))</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Ts&gt;</div>
<div class="line"><span class="keyword">using</span> common_type_t = <span class="keyword">typename</span> common_type&lt;Ts...&gt;::type;</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    common_type_t&lt;char, short, char, short&gt;, <span class="keywordtype">int</span>&gt;{}</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    common_type_t&lt;char, double, short, char, short, double&gt;, <span class="keywordtype">double</span>&gt;{}</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    common_type_t&lt;char, short, float, short&gt;, <span class="keywordtype">float</span></div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    sfinae(metafunction&lt;common_type&gt;)(type&lt;int&gt;, type&lt;int&gt;, type&lt;int*&gt;) == nothing</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><h2>Monadic right folds (<code>monadic_fold&lt;M&gt;.right</code>)</h2>
<p><code>monadic_fold&lt;M&gt;.right</code> is a right-associative monadic fold. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold&lt;M&gt;.right</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn, state))))) <span class="comment">// with state</span></div>
<div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn-1, xn))))) <span class="comment">// without state</span></div>
</div><!-- fragment --><p>where <code>f(xk, -)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>bind</code>. It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>monadic_fold&lt;M&gt;.left</code>.</p>
<h3>Signature</h3>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> of data type <code>M</code>, a <a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> of data type <code>F(T)</code>, an initial state of data type <code>S</code> and a function \( f : T \times S \to M(S) \), the signatures of <code>monadic_fold&lt;M&gt;.right</code> are </p><p class="formulaDsp">
\[ \mathrm{monadic\_fold}_M.\mathrm{right} : F(T) \times S \times (T \times S \to M(S)) \to M(S) \]
</p>
<p>for the version with an initial state, and </p><p class="formulaDsp">
\[ \mathrm{monadic\_fold}_M.\mathrm{right} : F(T) \times (T \times T \to M(T)) \to M(T) \]
</p>
<p>for the version without an initial state.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> representing the monadic context in which the fold happens. The return type of <code>f</code> must be in that <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. If the structure is empty, this value is lifted in to the <code>M</code> <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and then returned as-is.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. The function must return its result inside the <code>M</code> <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> safediv = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> eval_if(y == int_&lt;0&gt;,</div>
<div class="line">        <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(nothing),</div>
<div class="line">        [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) { <span class="keywordflow">return</span> just(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(x) / y); }</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// with an initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    monadic_fold&lt;Maybe&gt;.right(tuple_c&lt;int, 1000, 8, 4&gt;, int_&lt;2&gt;, safediv)</div>
<div class="line">        ==</div>
<div class="line">    just(int_&lt;1000&gt; / (int_&lt;8&gt; / (int_&lt;4&gt; / int_&lt;2&gt;)))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    monadic_fold&lt;Maybe&gt;.right(tuple_c&lt;int, 1000, 8, 4&gt;, int_&lt;0&gt;, safediv)</div>
<div class="line">        ==</div>
<div class="line">    nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// without an initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    monadic_fold&lt;Maybe&gt;.right(tuple_c&lt;int, 1000, 8, 4, 2&gt;, safediv)</div>
<div class="line">        ==</div>
<div class="line">    just(int_&lt;1000&gt; / (int_&lt;8&gt; / (int_&lt;4&gt; / int_&lt;2&gt;)))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    monadic_fold&lt;Maybe&gt;.right(tuple_c&lt;int, 1000, 8, 4, 0&gt;, safediv)</div>
<div class="line">        ==</div>
<div class="line">    nothing</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Tag-dispatching</h2>
<p>All of the different monadic fold variants are tag-dispatched methods and can be overridden individually. Here is how each variant is tag-dispatched (where <code>Xs</code> is the data type of <code>xs</code>): </p><div class="fragment"><div class="line">monadic_fold&lt;M&gt;.left(xs, state, f) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">monadic_fold_left_impl&lt;Xs&gt;::apply</a>&lt;M&gt;(xs, state, f)</div>
<div class="line">monadic_fold&lt;M&gt;.left(xs, f)        -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">monadic_fold_left_nostate_impl&lt;Xs&gt;::apply</a>&lt;M&gt;(xs, f)</div>
<div class="line"></div>
<div class="line">monadic_fold&lt;M&gt;.right(xs, state, f) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">monadic_fold_right_impl&lt;Xs&gt;::apply</a>&lt;M&gt;(xs, state, f)</div>
<div class="line">monadic_fold&lt;M&gt;.right(xs, f)        -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">monadic_fold_right_nostate_impl&lt;Xs&gt;::apply</a>&lt;M&gt;(xs, f)</div>
</div><!-- fragment --><p> <code>monadic_fold&lt;M&gt;</code> is not tag-dispatched, because it is just an alias to <code>monadic_fold&lt;M&gt;.left</code>. </p>

</div>
</div>
<a class="anchor" id="a9240a51cd23ef65186e32d643e82f52e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse_fold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; foldable[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> see-documentation;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>reverse_fold</code> in Boost.Fusion and Boost.MPL. </p>
<p>This method has the same semantics as <code>reverse_fold</code> in Boost.Fusion and Boost.MPL, with the extension that an initial state is not required. This method is equivalent to <code>fold.right</code>, except that the accumulating function must take its arguments in reverse order, to match the order used in Fusion. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a>(sequence, state, f) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.right(sequence, state, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a>(sequence, f) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.right(sequence, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This method is a convenience alias to <code>fold.right</code>. As an alias, <code>reverse_fold</code> is not tag-dispatched on its own and <code>fold.right</code> should be customized instead.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// With an initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4), <span class="stringliteral">&quot;5&quot;</span>, f)</div>
<div class="line">        ==</div>
<div class="line">    <span class="stringliteral">&quot;f(f(f(f(5, 4), 3), 2), 1)&quot;</span></div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Without an initial state</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4, <span class="stringliteral">&quot;5&quot;</span>), f)</div>
<div class="line">        ==</div>
<div class="line">    <span class="stringliteral">&quot;f(f(f(f(5, 4), 3), 2), 1)&quot;</span></div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a80176fbdfbccc09e902263557eb0984d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto for_each</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; foldable, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Perform an action on each element of a foldable, discarding the result each time. </p>
<p>Iteration is done from left to right, i.e. in the same order as when using <code>fold.left</code>. If the structure is not finite, this method will not terminate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foldable</td><td>The structure to iterate over.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> for each element <code>x</code> of the structure. The result of <code>f(x)</code>, whatever it is, is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>The presence of implicit side effects in this function might be a smell that it should be moved to a different concept and handled through <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>s.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line">std::stringstream ss;</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(make&lt;Tuple&gt;(0, <span class="charliteral">&#39;1&#39;</span>, <span class="stringliteral">&quot;234&quot;</span>, 5.5), [&amp;](<span class="keyword">auto</span> x) {</div>
<div class="line">    ss &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ss.str() == <span class="stringliteral">&quot;0 1 234 5.5 &quot;</span>);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/foldable/for_each.ctime.png" alt="for_each.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a5fb377e43aa7753bb77aa346c67fae0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; foldable) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in a finite structure. </p>
<p>Specifically, returns an object of an unsigned integral type, or a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding such an object, which represents the number of elements in the structure. The structure has to be finite for this method to return.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>(make&lt;Tuple&gt;()) == size_t&lt;0&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == size_t&lt;3&gt;);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>(nothing) == size_t&lt;0&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>(just(<span class="charliteral">&#39;x&#39;</span>)) == size_t&lt;1&gt;);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/foldable/length.ctime.png" alt="length.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a95d3fe103aa2ab8634a824562dd8390c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto size = <a class="el" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>length</code>; provided for consistency with the standard library. </p>
<p>This method is an alias to <code>length</code> provided for convenience and consistency with the standard library. As an alias, <code>size</code> is not tag-dispatched on its own and <code>length</code> should be customized instead.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a95d3fe103aa2ab8634a824562dd8390c">size</a>(make&lt;Tuple&gt;()) == size_t&lt;0&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a95d3fe103aa2ab8634a824562dd8390c">size</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == size_t&lt;3&gt;);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a95d3fe103aa2ab8634a824562dd8390c">size</a>(nothing) == size_t&lt;0&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a95d3fe103aa2ab8634a824562dd8390c">size</a>(just(<span class="charliteral">&#39;x&#39;</span>)) == size_t&lt;1&gt;);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aead74d4a75dd467873fcc9124d06b5f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto minimum = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the least element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>. </p>
<p>Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>minimum</code> returns the least element of the structure, i.e. an element which is less than or equal to every other element in the structure, according to the predicate.</p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. If no predicate is provided, the elements in the structure must be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>, or compile-time <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a> if the structure is heterogeneous.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> <code>xs</code> of data type <code>F(T)</code>, a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a predicate \( pred : T \times T \to Bool \), <code>minimum</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathrm{minimum} : S(T) \times (T \times T \to Bool) \to T \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>. The signature is then </p><p class="formulaDsp">
\[ \mathrm{minimum} : S(T) \to T \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to find the least element of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are elements of the structure. <code>predicate</code> should be a strict weak ordering on the elements of the structure and its return value should be a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, or a compile-time <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> if the structure is heterogeneous.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>minimum.by</code>) </h2>
<p><code>minimum</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>.by(predicate) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>minimum(-, predicate)</code> denotes the partial application of <code>minimum</code> to <code>predicate</code>.</p>
<h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>minimum</code> are tag-dispatched methods, and hence they can be customized independently. One reason for this is that some structures are able to provide a much more efficient implementation of <code>minimum</code> when the <code>less</code> predicate is used. Here is how the different versions of <code>minimum</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">minimum_impl&lt;data type of xs&gt;::apply</a>(xs)</div>
<div class="line">minimum(xs, pred) -&gt; minimum_pred_impl&lt;data type of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div>
</div><!-- fragment --><p>Also note that <code>minimum.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>minimum</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// without a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;) == int_&lt;-4&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// with a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;, [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> x &gt; y;</div>
<div class="line">    }) == int_&lt;9&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    minimum.by(ordering(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>), make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(),</div>
<div class="line">        make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>),</div>
<div class="line">        make&lt;Tuple&gt;(3.3, <span class="keyword">nullptr</span>, 4)</div>
<div class="line">    ))</div>
<div class="line">    == make&lt;Tuple&gt;()</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac49a8fde2d3de61959c99e755a81c0a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto maximum = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>. </p>
<p>Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>maximum</code> returns the greatest element of the structure, i.e. an element which is greater than or equal to every other element in the structure, according to the predicate.</p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. If no predicate is provided, the elements in the structure must be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>, or compile-time <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a> if the structure is heterogeneous.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> <code>xs</code> of data type <code>F(T)</code>, a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a predicate \( pred : T \times T \to Bool \), <code>maximum</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathrm{maximum} : S(T) \times (T \times T \to Bool) \to T \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>. The signature is then </p><p class="formulaDsp">
\[ \mathrm{maximum} : S(T) \to T \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to find the greatest element of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are elements of the structure. <code>predicate</code> should be a strict weak ordering on the elements of the structure and its return value should be a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, or a compile-time <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> if the structure is heterogeneous.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>maximum.by</code>) </h2>
<p><code>maximum</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>.by(predicate) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>maximum(-, predicate)</code> denotes the partial application of <code>maximum</code> to <code>predicate</code>.</p>
<h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>maximum</code> are tag-dispatched methods, and hence they can be customized independently. One reason for this is that some structures are able to provide a much more efficient implementation of <code>maximum</code> when the <code>less</code> predicate is used. Here is how the different versions of <code>maximum</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">maximum_impl&lt;data type of xs&gt;::apply</a>(xs)</div>
<div class="line">maximum(xs, pred) -&gt; maximum_pred_impl&lt;data type of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div>
</div><!-- fragment --><p>Also note that <code>maximum.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>maximum</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// without a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;) == int_&lt;9&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// with a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;, [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> x &gt; y;</div>
<div class="line">    }) == int_&lt;-4&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    maximum.by(ordering(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>), make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(),</div>
<div class="line">        make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>),</div>
<div class="line">        make&lt;Tuple&gt;(3.3, <span class="keyword">nullptr</span>, 4)</div>
<div class="line">    ))</div>
<div class="line">    == make&lt;Tuple&gt;(3.3, <span class="keyword">nullptr</span>, 4)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae99a05a203907d1381a00d9e05425ab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sum = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of the numbers of a structure. </p>
<p>More generally, <code>sum</code> will take any foldable structure containing objects forming a <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> and reduce them using the <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>'s binary operation. The initial state for folding is the identity of the <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>. It is sometimes necessary to specify the <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> to use; this is possible by using <code>sum&lt;M&gt;</code>. If no <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> is specified, the structure will use the <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;int&gt;</code> otherwise. Hence, </p><div class="fragment"><div class="line">sum&lt;M&gt;(xs) = <a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.left(xs, zero&lt;M or inferred Monoid&gt;(), plus)</div>
<div class="line">sum&lt;&gt; = sum&lt;IntegralConstant&lt;int&gt;&gt;</div>
</div><!-- fragment --><p>For numbers, this will just compute the sum of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>, but it must be possible to perform <code>plus</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the <a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> concept.</dd></dl>
<h2>Why must the <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> be specified sometimes? </h2>
<p>This is because sequences like <a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a> are not parameterized data types (by design). Hence, we do not know what kind of objects are in the sequence, and so that must be specified explicitly. Other foldable structures like Ranges will ignore the suggested <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> because they know the data type of the objects they contain. This inconsistent behavior is a limitation of the current design of data types, and work is being done to resolve it.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    sum&lt;&gt;(range(int_&lt;1&gt;, int_&lt;6&gt;)) == int_&lt;1 + 2 + 3 + 4 + 5&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    sum&lt;&gt;(make&lt;Tuple&gt;(1, int_&lt;3&gt;, long_&lt;-5&gt;, 9)) == 1 + 3 - 5 + 9</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    sum&lt;unsigned long&gt;(make&lt;Tuple&gt;(1ul, 3ul)) == 4ul</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/foldable/sum.ctime.png" alt="sum.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="aa37fd8d56461f749d49423c711e4c67a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto product</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; foldable) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Compute the product of the numbers of a structure. </p>
<p>More generally, <code>product</code> will take any foldable structure containing objects forming a <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> and reduce them using the <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a>'s binary operation. The initial state for folding is the identity of the <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a>'s operation. It is sometimes necessary to specify the <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> to use; this is possible by using <code>product&lt;R&gt;</code>. If no <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> is specified, the structure will use the <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;int&gt;</code> otherwise. Hence, </p><div class="fragment"><div class="line">product&lt;R&gt;(xs) = <a class="code" href="structboost_1_1hana_1_1_foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>.left(xs, one&lt;R or inferred Ring&gt;(), mult)</div>
<div class="line">product&lt;&gt; = product&lt;IntegralConstant&lt;int&gt;&gt;</div>
</div><!-- fragment --><p>For numbers, this will just compute the product of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a>, but it must be possible to perform <code>mult</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the <a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> concept.</dd>
<dd>
See the documentation for <code>sum</code> to understand why the <a class="el" href="structboost_1_1hana_1_1_ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> must sometimes be specified explicitly.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    product&lt;&gt;(range(int_&lt;1&gt;, int_&lt;6&gt;)) == int_&lt;1 * 2 * 3 * 4 * 5&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    product&lt;&gt;(make&lt;Tuple&gt;(1, int_&lt;3&gt;, long_&lt;-5&gt;, 9)) == 1 * 3 * -5 * 9</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    product&lt;unsigned long&gt;(make&lt;Tuple&gt;(2ul, 3ul)) == 6ul</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/foldable/product.ctime.png" alt="product.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a21ca48cce90274a5f54354f9d4622930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto count_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; foldable, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in the structure for which the <code>predicate</code> is satisfied. </p>
<p>Specifically, returns an object of an unsigned integral type, or a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding such an object, which represents the number of elements in the structure satisfying the given <code>predicate</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foldable</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should be counted.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> types = tuple_t&lt;int, char, long, short, char, double&gt;;</div>
<div class="line">constexpr <span class="keyword">auto</span> ints = tuple_c&lt;int, 1, 2, 3&gt;;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a21ca48cce90274a5f54354f9d4622930">count_if</a>(ints, odd) == size_t&lt;2&gt;);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a21ca48cce90274a5f54354f9d4622930">count_if</a>(types, trait&lt;std::is_floating_point&gt;) == size_t&lt;1&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a21ca48cce90274a5f54354f9d4622930">count_if</a>(types, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == type&lt;char&gt;) == size_t&lt;2&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a21ca48cce90274a5f54354f9d4622930">count_if</a>(types, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == type&lt;void&gt;) == size_t&lt;0&gt;);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/foldable/count_if.ctime.png" alt="count_if.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="ae0a55dd7eb4bd4f587f51ffd8c923e53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; foldable, <span class="keyword">auto</span>&amp;&amp; value) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in the structure that compare equal to a given value. </p>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> structure <code>foldable</code> and a value <code>value</code>, <code>count</code> returns an unsigned integral, or a <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> thereof, representing the number of elements of <code>foldable</code> that compare equal to <code>value</code>. For this method to be well-defined, all the elements of the structure must be <a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a> with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foldable</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">value</td><td>A value compared with each element in the structure. Elements that compare equal to this value are counted, others are not.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> types = tuple_t&lt;int, char, long, short, char, double&gt;;</div>
<div class="line">constexpr <span class="keyword">auto</span> ints = tuple_c&lt;int, 1, 2, 3, 2, 2, 4, 2&gt;;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(ints, int_&lt;2&gt;) == size_t&lt;4&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(ints, 2) == 4);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(types, type&lt;char&gt;) == size_t&lt;2&gt;);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e3e724580e826eaa39a934eefa2b328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unpack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; foldable, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invoke a function with the elements of a structure as arguments. </p>
<p>Given a function and a foldable structure whose length can be known at compile-time, <code>unpack</code> invokes the function with the contents of that structure. In other words, <code>unpack(foldable, f)</code> is equivalent to <code>f(x...)</code>, where <code>x...</code> are the elements of the structure. The length of the structure must be known at compile-time, because the version of <code>f</code>'s <code>operator()</code> that will be compiled depends on the number of arguments it is called with, which has to be known at compile-time.</p>
<p>To create a function that accepts a foldable instead of variadic arguments, see <code>fuse</code>, which is roughly equivalent to <code>boost::fusion::make_fused</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foldable</td><td>The structure to expand into the function.</td></tr>
    <tr><td class="paramname">f</td><td>A function to be invoked as <code>f(x...)</code>, where <code>x...</code> are the elements of the structure as-if they had been linearized with <code>to&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cheap_tie = [](<span class="keyword">auto</span>&amp; ...vars) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">partial</a>(<a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(<a class="code" href="structboost_1_1hana_1_1_foldable.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a>), [&amp;vars...](auto ...values) {</div>
<div class="line">        <span class="comment">// Using an initializer list sequences the assignments.</span></div>
<div class="line">        int dummy[] = {((vars = values), 0)...};</div>
<div class="line">        (<span class="keywordtype">void</span>)dummy;</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">char</span> b = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"><span class="keywordtype">double</span> c = 0;</div>
<div class="line"></div>
<div class="line">cheap_tie(a, b, c)(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(a == 1 &amp;&amp; b == <span class="charliteral">&#39;2&#39;</span> &amp;&amp; c == 3.3);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/foldable/unpack.ctime.png" alt="unpack.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a0840e48f29a87467e23d801ca0ca122a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fuse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_foldable.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a>(forwarded(xs), forwarded(f));</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Transform a function taking multiple arguments into a function that can be called with a <code><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a></code>. </p>
<p>This function is provided for convenience as a different way of calling <code>unpack</code>. Specifically, <code>fuse(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#a0840e48f29a87467e23d801ca0ca122a">fuse</a>(f)(foldable) == <a class="code" href="structboost_1_1hana_1_1_foldable.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a>(foldable, f)</div>
<div class="line">                  == f(x...)</div>
</div><!-- fragment --><p> where <code>x...</code> are the elements in the foldable. This function is useful when one wants to create a function that accepts a foldable which is not known yet.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not tag-dispatched and so it can not be customized.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> x + y;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Would be `boost::fusion::make_fused(add)` in Boost.Fusion.</span></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> add_seq = <a class="code" href="structboost_1_1hana_1_1_foldable.html#a0840e48f29a87467e23d801ca0ca122a">fuse</a>(add);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(add_seq(make&lt;Tuple&gt;(1, 2)) == add(1, 2));</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_foldable.html">Foldable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
