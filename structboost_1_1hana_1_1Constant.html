<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Constant Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/9029554299b379bd015d102ecdcc5ff455469b6b/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/unspecified-type/g, "unspecified-type".link("index.html#tutorial-glossary-unspecified_type").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.6.2/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Constant.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1Constant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Constant Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> concept represents data that can be manipulated at compile-time. </p>
<p>At its core, <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> is simply a generalization of the principle behind <code>std::integral_constant</code> to all types that can be constructed at compile-time, i.e. to all types with a <code>constexpr</code> constructor (also called <a href="http://en.cppreference.com/w/cpp/concept/LiteralType">Literal types</a>). More specifically, a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> is an object from which a <code>constexpr</code> value may be obtained (through the <code>value</code> method) regardless of the <code>constexpr</code>ness of the object itself.</p>
<p>All <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s must be somewhat equivalent, in the following sense. Let <code>C(T)</code> and <code>D(U)</code> denote the data types of <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s holding objects of type <code>T</code> and <code>U</code>, respectively. Then, an object of data type <code>D(U)</code> must be convertible to an object of type <code>C(T)</code> whenever <code>U</code> is convertible to <code>T</code>, has determined by <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">is_convertible</a></code>. The interpretation here is that a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> is just a box holding an object of some type, and it should be possible to swap between boxes whenever the objects inside the boxes can be swapped.</p>
<p>Because of this last requirement, one could be tempted to think that specialized "boxes" like <code>std::integral_constant</code> are prevented from being <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s because they are not able to hold objects of any type <code>T</code> (<code>std::integral_constant</code> may only hold integral types). This is false; the requirement should be interpreted as saying that whenever <code>C(T)</code> is <em>meaningful</em> (e.g. only when <code>T</code> is integral for <code>std::integral_constant</code>) <em>and</em> there exists a conversion from <code>U</code> to <code>T</code>, then a conversion from <code>D(U)</code> to <code>C(T)</code> should also exist. The precise requirements for being a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> are embodied in the following laws.</p>
<h2>Minimal complete definition </h2>
<p><code>value</code>, satisfying the laws below.</p>
<h2>Laws </h2>
<p>Let <code>c</code> be an object of a data type <code>C</code>, which represents a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding an object of data type <code>T</code>. The first law ensures that the value of the wrapped object is always a constant expression by requiring the following to be well-formed: </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> x = hana::value&lt;decltype(x)&gt;();</div>
</div><!-- fragment --><p>This means that the <code>value</code> function must return an object that can be constructed at compile-time. It is important to note how <code>value</code> only receives the type of the object and not the object itself. This is the core of the <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> concept; it means that the only information required to implement <code>value</code> must be stored in the <em>type</em> of its argument, and hence be available statically.</p>
<p>The second law that must be satisfied ensures that <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s are basically dumb boxes, which makes it possible to provide models for many concepts without much work from the user. The law simply asks for the following expression to be valid: </p><div class="fragment"><div class="line">to&lt;C&gt;(i)</div>
</div><!-- fragment --><p> where, <code>i</code> is an <em>arbitrary</em> <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding an internal value of a data type which can be converted to <code>T</code>, as determined by the <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">is_convertible</a></code> metafunction. In other words, whenever <code>U</code> is convertible to <code>T</code>, a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding a <code>U</code> is convertible to a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding a <code>T</code>, if such a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> can be created.</p>
<p>Finally, the data type <code>C</code> must provide a nested <code>value_type</code> alias to <code>T</code>, which allows us to query the data type of the inner value held by objects of data type <code>C</code>. In other words, the following must be true for any object <code>c</code> of data type <code>C</code>: </p><div class="fragment"><div class="line">std::is_same&lt;</div>
<div class="line">    C::value_type,</div>
<div class="line">    datatype_t&lt;decltype(hana::value(c))&gt;</div>
<div class="line">&gt;<a class="code" href="structboost_1_1hana_1_1Constant.html#adea9453327ac4d6834a555ae9887d3f5">::value</a></div>
</div><!-- fragment --><h2>Refined concepts </h2>
<p>In certain cases, a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> can automatically be made a model of another concept. In particular, if a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>C</code> is holding an object of type <code>T</code>, and if <code>T</code> models a concept <code>X</code>, then <code>C</code> may in most cases model <code>X</code> by simply performing whatever operation is required on its underlying value, and then wrapping the result back in a <code>C</code>.</p>
<p>More specifically, if a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>C</code> has an underlying value (<code>C::value_type</code>) which is a model of <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Enumerable.html" title="Represents data types whose values can be enumerated. ">Enumerable</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>, or <code><a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a></code> up to <code><a class="el" href="structboost_1_1hana_1_1IntegralDomain.html" title="The IntegralDomain concept represents a commutative Ring whose multiplication has some &quot;nice&quot; propert...">IntegralDomain</a></code>, then <code>C</code> must also be a model of those concepts. In other words, when <code>C::value_type</code> models one of the listed concepts, <code>C</code> itself must also model that concept. However, note that free models are provided for all of those concepts, so no additional work must be done.</p>
<p>While it would be possible in theory to provide models for concepts like <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> too, only a couple of concepts are useful to have as <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> in practice. Providing free models for the concepts listed above is useful because it allows various types of integral constants (<code>std::integral_constant</code>, <code>mpl::integral_c</code>, etc...) to easily have models for them just by defining the <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> concept.</p>
<dl class="section remark"><dt>Remarks</dt><dd>An interesting observation is that <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> is actually the canonical embedding of the subcategory of <code>constexpr</code> things into the Hana category, which contains everything in this library. Hence, whatever is true in that subcategory is also true here, via this functor. This is why we can provide models of any concept that works on <code>constexpr</code> things for Constants, by simply passing them through that embedding.</dd></dl>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Tag representing a compile-time value of an integral type. ">IntegralConstant</a></code></p>
<h2>Provided conversion to the data type of the underlying value </h2>
<p>Any <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>c</code> holding an underlying value of data type <code>T</code> is convertible to any data type <code>U</code> such that <code>T</code> is convertible to <code>U</code>. Specifically, the conversion is equivalent to </p><div class="fragment"><div class="line">to&lt;U&gt;(c) == to&lt;U&gt;(<a class="code" href="structboost_1_1hana_1_1Constant.html#adea9453327ac4d6834a555ae9887d3f5">value</a>&lt;decltype(c)&gt;())</div>
</div><!-- fragment --><p>Also, those conversions are marked as an embedding whenever the conversion of underlying types is an embedding. This is to allow Constants to inter-operate with <code>constexpr</code> objects easily: </p><div class="fragment"><div class="line">plus(int_&lt;1&gt;, 1) == 2</div>
</div><!-- fragment --><p>Strictly speaking, <b>this is sometimes a violation</b> of what it means to be an embedding. Indeed, while there exists an embedding from any <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> to a <code>constexpr</code> object (since <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> is just the canonical inclusion), there is no embedding from a <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> to a runtime object since we would lose the ability to define the <code>value</code> method (the <code>constexpr</code>ness of the object would have been lost). Since there is no way to distinguish <code>constexpr</code> and non-<code>constexpr</code> objects based on their type, Hana has no way to know whether the conversion is to a <code>constexpr</code> object of not. In other words, the <code>to</code> method has no way to differentiate between </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> i = hana::to&lt;int&gt;(int_&lt;1&gt;);</div>
</div><!-- fragment --><p> which is an embedding, and </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = hana::to&lt;int&gt;(int_&lt;1&gt;);</div>
</div><!-- fragment --><p>which isn't. To be on the safer side, we could mark the conversion as not-an-embedding. However, if e.g. the conversion from <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Tag representing a compile-time value of an integral type. ">IntegralConstant</a>&lt;int&gt;</code> to <code>int</code> was not marked as an embedding, we would have to write <code>plus(to&lt;int&gt;(int_&lt;1&gt;), 1)</code> instead of just <code>plus(int_&lt;1&gt;, 1)</code>, which is cumbersome. Hence, the conversion is marked as an embedding, but this also means that code like </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 1;</div>
<div class="line">plus(int_&lt;1&gt;, i);</div>
</div><!-- fragment --><p> will be considered valid, which implicitly loses the fact that <code>int_&lt;1&gt;</code> is a <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a>, and hence does not follow the usual rules for cross-type operations in Hana.</p>
<h2>Provided common data type </h2>
<p>Because of the requirement that <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s be interchangeable when their contents are compatible, two <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s <code>A</code> and <code>B</code> will have a common data type whenever <code>A::value_type</code> and <code>B::value_type</code> have one. Their common data type is an unspecified <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>C</code> such that <code>C::value_type</code> is exactly <code>common_t&lt;A::value_type, B::value_type&gt;</code>. A specialization of the <code>common</code> metafunction is provided for <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s to reflect this.</p>
<p>In the same vein, a common data type is also provided from any constant <code>A</code> to a type <code>T</code> such that <code>A::value_type</code> and <code>T</code> share a common type. The common type between <code>A</code> and <code>T</code> is obviously the common type between <code>A::value_type</code> and <code>T</code>. As explained above in the section on conversions, this is sometimes a violation of the definition of a common type, because there must be an embedding to the common type, which is not always the case. For the same reasons as explained above, this common type is still provided. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:adea9453327ac4d6834a555ae9887d3f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adea9453327ac4d6834a555ae9887d3f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Constant.html#adea9453327ac4d6834a555ae9887d3f5">value</a></td></tr>
<tr class="memdesc:adea9453327ac4d6834a555ae9887d3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the compile-time value associated to a constant.  <a href="#adea9453327ac4d6834a555ae9887d3f5">More...</a><br /></td></tr>
<tr class="separator:adea9453327ac4d6834a555ae9887d3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06a1ad6dece8a0337c3a9e754067051"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Constant.html#ad06a1ad6dece8a0337c3a9e754067051">value_of</a></td></tr>
<tr class="memdesc:ad06a1ad6dece8a0337c3a9e754067051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>value</code>, but can be passed to higher-order algorithms.  <a href="#ad06a1ad6dece8a0337c3a9e754067051">More...</a><br /></td></tr>
<tr class="separator:ad06a1ad6dece8a0337c3a9e754067051"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="adea9453327ac4d6834a555ae9887d3f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the compile-time value associated to a constant. </p>
<p>This function returns the value associated to a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>. That value is always a constant expression. The normal way of using <code>value</code> on an object <code>c</code> is </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> result = hana::value&lt;decltype(c)&gt;();</div>
</div><!-- fragment --><p>However, for convenience, an overload of <code>value</code> is provided so that it can be called as: </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> result = hana::value(c);</div>
</div><!-- fragment --><p>This overload works by taking a <code>const&amp;</code> to its argument, and then forwarding to the first version of <code>value</code>. Since it does not use its argument, the result can still be a constant expression, even if the argument is not a constant expression.</p>
<dl class="section note"><dt>Note</dt><dd><code>value&lt;T&gt;()</code> is tag-dispatched as <code>value_impl&lt;C&gt;::apply&lt;T&gt;()</code>, where <code>C</code> is the data type of <code>T</code>.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="value_8hpp.html">boost/hana/value.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> i = hana::integral_constant&lt;int, 3&gt;; <span class="comment">// notice no constexpr</span></div>
<div class="line">    static_assert(hana::value&lt;decltype(i)&gt;() == 3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(hana::value(i) == 3, <span class="stringliteral">&quot;value(i) is always a constant expression!&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad06a1ad6dece8a0337c3a9e754067051"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto value_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; c) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::value(c);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>value</code>, but can be passed to higher-order algorithms. </p>
<p>This function object is equivalent to <code>value</code>, except it can be passed to higher order algorithms because it is a function object. <code>value</code> can't be passed to higher-order algorithms because it is implemented as an overloaded function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a simple alias to <code>value</code>, and hence it is not tag-dispatched and can't be customized.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="value_8hpp.html">boost/hana/value.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keyword">auto</span> xs = hana::tuple_c&lt;int, 1, 2, 3, 4, 5&gt;;</div>
<div class="line">    constexpr <span class="keyword">auto</span> vs = hana::transform(xs, hana::value_of);</div>
<div class="line">    static_assert(vs == hana::make_tuple(1, 2, 3, 4, 5), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Constant.html">Constant</a></li>
  </ul>
</div>
</body>
</html>
