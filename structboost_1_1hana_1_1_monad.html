<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Monad Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_monad.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_monad-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Monad Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> concept represents <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>s with the ability to flatten nested levels of structure. </p>
<p>Intuitively, using the Functor-as-a-box analogy, a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> is able to flatten a box containing a box into just a single box. In other words, it is able to remove one level of monadic structure. This allows Monads to combine not only structures, but also functions returning structures, which turns out to be pretty useful.</p>
<p>Historically, Monads are a construction coming from category theory, an abstract branch of mathematics. The functional programming community eventually discovered how Monads could be used to formalize several useful things like side effects, which led to the wide adoption of Monads in that community. However, even in a multi-paradigm language like C++, there are several constructs which turn out to be Monads, like <code>std::optional</code>, <code>std::vector</code> and others.</p>
<p>Everybody tries to introduce Monads with a different analogy, and almost everybody fails. This is called the <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">Monad tutorial fallacy</a>. We won't fall into this trap here and will let readers who are new to this concept read one of the many excellent tutorials available online. Understanding Monads might take time at first, but once you get it, a lot of patterns will become obvious Monads; this enlightening will be your reward for the hard work. That being said, there are different ways of defining a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>; some will use the <code>bind</code> function (<code>&gt;&gt;=</code> in Haskell), others will use <code>join</code> (called <code>flatten</code> in this library), and there are probably other ways. In Hana, the <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> laws are written in term of the monadic composition operator, called <code>mcompose</code>, which we think gives the best intuition on the relation between a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and a <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>.</p>
<h2>Laws </h2>
<p>In what follows, we use equality between functions as meaning </p><div class="fragment"><div class="line">f == g  <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>  f(x) == g(x) for all x</div>
</div><!-- fragment --><p> This is to simplify writing the laws, which would be tedious otherwise. For a data type <code>M</code> to be a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>, the following must be satisfied for all functions <code>f, g, h</code> with a suitable signature for the composition to make sense: </p><div class="fragment"><div class="line">mcompose&lt;M&gt;(lift&lt;M&gt;, f)           == f                                 <span class="comment">// left identity</span></div>
<div class="line">mcompose&lt;M&gt;(f, lift&lt;M&gt;)           == f                                 <span class="comment">// right identity</span></div>
<div class="line">mcompose&lt;M&gt;(mcompose&lt;M&gt;(f, g), h) == mcompose&lt;M&gt;(f, mcompose&lt;M&gt;(g, h)) <span class="comment">// associativity</span></div>
</div><!-- fragment --><p> By comparing with the <code><a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a></code> laws, one can clearly see how these two structures have something in common.</p>
<h2>Superclasses </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> and <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code></p>
<h2>Provided superclass methods </h2>
<ol type="1">
<li><code>ap</code><br />
When the minimal complete definition for <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> and <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> are both satisfied, it is possible to automatically implement <code>ap</code> by setting <div class="fragment"><div class="line">ap(fs, x) = <a class="code" href="structboost_1_1hana_1_1_monad.html#a4df7d83b8aeb3bcf99e5675f69af4090">bind</a>(fs, [](<span class="keyword">auto</span> f) {</div>
<div class="line">    <span class="keywordflow">return</span> transform(x, f);</div>
<div class="line">})</div>
</div><!-- fragment --></li>
</ol>
<p>This implementation is provided through the <code>Monad::ap_impl</code> type, which you can use as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>ap_impl&lt;YourDatatype&gt;</div>
<div class="line">    : Monad::ap_impl&lt;YourDatatype&gt;</div>
<div class="line">{ };</div>
</div><!-- fragment --><h2>Minimal complete definition </h2>
<ol type="1">
<li><code>flatten</code><br />
When <code>flatten</code> is defined, <code>bind</code> is defined by setting: <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a4df7d83b8aeb3bcf99e5675f69af4090">bind</a>(xs, f) = <a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(transform(xs, f))</div>
</div><!-- fragment --></li>
<li><code>bind</code><br />
When <code>bind</code> is defined, <code>flatten</code> is defined by setting: <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(xs) = <a class="code" href="structboost_1_1hana_1_1_monad.html#a4df7d83b8aeb3bcf99e5675f69af4090">bind</a>(xs, <span class="keywordtype">id</span>)</div>
</div><!-- fragment --></li>
</ol>
<h2>Operators </h2>
<p>For convenience, the following operator is provided as an equivalent way of calling the corresponding method: </p><div class="fragment"><div class="line">xs | f  -&gt;  <a class="code" href="structboost_1_1hana_1_1_monad.html#a4df7d83b8aeb3bcf99e5675f69af4090">bind</a>(xs, f)</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Note: <code>xs | f</code> was preferred over <code>xs &gt;&gt;= f</code> (as in Haskell), because <code>&gt;&gt;=</code> is right associative in C++, which would make it impossible to chain computations. </p>
</blockquote>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a4df7d83b8aeb3bcf99e5675f69af4090"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#a4df7d83b8aeb3bcf99e5675f69af4090">bind</a></td></tr>
<tr class="memdesc:a4df7d83b8aeb3bcf99e5675f69af4090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function returning a monadic value to the value(s) inside a monad.  <a href="#a4df7d83b8aeb3bcf99e5675f69af4090">More...</a><br /></td></tr>
<tr class="separator:a4df7d83b8aeb3bcf99e5675f69af4090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45985423d0658e88f0403773146af110"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a></td></tr>
<tr class="memdesc:a45985423d0658e88f0403773146af110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse two levels of monadic structure into a single level.  <a href="#a45985423d0658e88f0403773146af110">More...</a><br /></td></tr>
<tr class="separator:a45985423d0658e88f0403773146af110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab745f6bdedf122ce589f336ff1ff3323"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#ab745f6bdedf122ce589f336ff1ff3323">mcompose</a></td></tr>
<tr class="memdesc:ab745f6bdedf122ce589f336ff1ff3323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of monadic functions.  <a href="#ab745f6bdedf122ce589f336ff1ff3323">More...</a><br /></td></tr>
<tr class="separator:ab745f6bdedf122ce589f336ff1ff3323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc7efb0044a87a21f663b1a151dac56"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#abfc7efb0044a87a21f663b1a151dac56">then</a></td></tr>
<tr class="memdesc:abfc7efb0044a87a21f663b1a151dac56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially compose two monadic actions, discarding any value produced by the first but not its effects.  <a href="#abfc7efb0044a87a21f663b1a151dac56">More...</a><br /></td></tr>
<tr class="separator:abfc7efb0044a87a21f663b1a151dac56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#a17ea859a2702ea45ea4999a8a0d2cc63">tap</a></td></tr>
<tr class="memdesc:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tap inside a monadic chain.  <a href="#a17ea859a2702ea45ea4999a8a0d2cc63">More...</a><br /></td></tr>
<tr class="separator:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a4df7d83b8aeb3bcf99e5675f69af4090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Apply a function returning a monadic value to the value(s) inside a monad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A structure containing value(s) to transform with <code>f</code>.</td></tr>
    <tr><td class="paramname">f</td><td>A function taking a value inside the <code>xs</code> structure and returning a monadic value. It will be called as <code>f(x)</code> for an element <code>x</code> of the structure <code>xs</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> deref = [](<span class="keyword">auto</span> x) -&gt; decltype(*x) {</div>
<div class="line">    <span class="keywordflow">return</span> *x;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> age = [](<span class="keyword">auto</span> x) -&gt; decltype(x.age) {</div>
<div class="line">    <span class="keywordflow">return</span> x.age;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_monad.html#a4df7d83b8aeb3bcf99e5675f69af4090">bind</a>(sfinae(deref)(x), sfinae(age));</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> age;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{30};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Can&#39;t dereference a non-pointer.</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(f(john) == nothing);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// `int` has no member named `age`.</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(f(1) == nothing);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// All is good.</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(f(&amp;john) == just(30u));</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45985423d0658e88f0403773146af110"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto flatten</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Collapse two levels of monadic structure into a single level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>An object with two levels of monadic structure, which should be collapsed into a single level of structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2, 3), make&lt;Tuple&gt;(4, 5), make&lt;Tuple&gt;(6, 7, 8, 9)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(nothing) == nothing);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(just(just(1))) == just(1));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(just(nothing)) == nothing);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab745f6bdedf122ce589f336ff1ff3323"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto mcompose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; g) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Composition of monadic functions. </p>
<p>Specifically, this is equivalent to the <code>compose</code> function for functions that return <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function with pseudo-signature <code>f :: A -&gt; M&lt;B&gt;</code>.</td></tr>
    <tr><td class="paramname">g</td><td>A function with pseudo-signature <code>g :: B -&gt; M&lt;C&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> block = [](<span class="keyword">auto</span> ...types) {</div>
<div class="line">    <span class="keywordflow">return</span> [=](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(elem(make&lt;Tuple&gt;(types...), decltype_(x)),</div>
<div class="line">            nothing,</div>
<div class="line">            just(x)</div>
<div class="line">        );</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> f = block(type&lt;double&gt;);</div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> g = block(type&lt;int&gt;);</div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> h = mcompose&lt;Maybe&gt;(f, g);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(h(1)    == nothing);   <span class="comment">// fails inside g; 1 has type int</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(h(1.2)  == nothing); <span class="comment">// fails inside f; 1.2 has type double</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(h(<span class="charliteral">&#39;x&#39;</span>) == just(<span class="charliteral">&#39;x&#39;</span>)); <span class="comment">// ok; &#39;x&#39; has type char</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abfc7efb0044a87a21f663b1a151dac56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto then</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; before, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sequentially compose two monadic actions, discarding any value produced by the first but not its effects. </p>
<dl class="section note"><dt>Note</dt><dd>This is equivalent to Haskell's <code>&gt;&gt;</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">before</td><td>The first <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> in the monadic composition chain. The result of this monad is ignored, but its effects are combined with that of the second monad.</td></tr>
    <tr><td class="paramname">xs</td><td>The second <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> in the monadic composition chain.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>undefined { };</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad.html#abfc7efb0044a87a21f663b1a151dac56">then</a>(make&lt;Tuple&gt;(undefined{}, undefined{}), make&lt;Tuple&gt;(1, 2, 3)) == make&lt;Tuple&gt;(</div>
<div class="line">        1, 2, 3,</div>
<div class="line">        1, 2, 3</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a17ea859a2702ea45ea4999a8a0d2cc63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Tap inside a monadic chain. </p>
<p>Specifically, <code>tap&lt;M&gt;(f)(x)</code> performs <code>f(x)</code> and returns <code>lift&lt;M&gt;(x)</code>. Combined with the law saying that <code>bind(m, lift&lt;M&gt;) == m</code>, this provides a way of executing an action inside a monadic chain without influencing its result. This is useful to e.g. insert debug statements or perform actions that are not tied to the chain but that need to be executed inside of it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The data type (a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>) of the monads in the tapped monadic chain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function to be executed inside a monadic chain. It will be called as <code>f(x)</code>, where <code>x</code> is a value inside the previous monad in the chain. The result of <code>f</code> is always discarded.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">std::stringstream before, after;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> xs = make&lt;Tuple&gt;(1, 2, 3)</div>
<div class="line">    | tap&lt;Tuple&gt;([&amp;](<span class="keyword">auto</span> x) { before &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>; })</div>
<div class="line">    | [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> make&lt;Tuple&gt;(x, -x); }</div>
<div class="line">    | tap&lt;Tuple&gt;([&amp;](<span class="keyword">auto</span> x) { after &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>; });</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(before.str() == <span class="stringliteral">&quot;1 2 3 &quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(after.str() == <span class="stringliteral">&quot;1 -1 2 -2 3 -3 &quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(xs == make&lt;Tuple&gt;(1, -1, 2, -2, 3, -3));</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_monad.html">Monad</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
