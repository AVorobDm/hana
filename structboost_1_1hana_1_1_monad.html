<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Monad Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/fb54ae3856341ef4bd3acf877ccf24836fc079d9/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.5.0/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_monad.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_monad-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Monad Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> concept represents <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>s with the ability to flatten nested levels of structure. </p>
<p>Historically, Monads are a construction coming from category theory, an abstract branch of mathematics. The functional programming community eventually discovered how Monads could be used to formalize several useful things like side effects, which led to the wide adoption of Monads in that community. However, even in a multi-paradigm language like C++, there are several constructs which turn out to be Monads, like <code>std::optional</code>, <code>std::vector</code> and others.</p>
<p>Everybody tries to introduce <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>s with a different analogy, and most people fail. This is called the <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">Monad tutorial fallacy</a>. We will try to avoid this trap by not presenting a specific intuition, and we will instead present what monads are mathematically. For specific intuitions, we will let readers who are new to this concept read one of the many excellent tutorials available online. Understanding Monads might take time at first, but once you get it, a lot of patterns will become obvious Monads; this enlightening will be your reward for the hard work.</p>
<p>There are different ways of defining a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>; Haskell uses a function called <code>bind</code> (<code>&gt;&gt;=</code>) and another one called <code>return</code> (it has nothing to do with C++'s <code>return</code> statement). They then introduce relationships that must be satisfied for a type to be a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> with those functions. Mathematicians sometimes use a function called <code>join</code> and another one called <code>unit</code>, or they also sometimes use other category theoretic constructions like functor adjunctions and the Kleisli category.</p>
<p>This library uses a composite approach. First, we use the <code>flatten</code> function (equivalent to <code>join</code>) along with the <code>lift</code> function from <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> (equivalent to <code>unit</code>) to introduce the notion of monadic function composition. We then write the properties that must be satisfied by a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> using this monadic composition operator, because we feel it shows the link between Monads and Monoids more clearly than other approaches.</p>
<p>Roughly speaking, we will say that a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> is an <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> which also defines a way to compose functions returning a monadic result, as opposed to only being able to compose functions returning a normal result. We will then ask for this composition to be associative and to have a neutral element, just like normal function composition. For usual composition, the neutral element is the identity function <code>id</code>. For monadic composition, the neutral element is the <code>lift</code> function defined by <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>. This construction is made clearer in the laws below.</p>
<h2>Minimal complete definitions </h2>
<p>First, a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> must be both a <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> and an <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>. Also, an implementation of <code>flatten</code> or <code>chain</code> satisfying the laws below for monadic composition must be provided.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>ap</code> method for <code>Applicatives</code> may be derived from the minimal complete definition of <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> and <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>; see below for more information.</dd></dl>
<h2>Laws </h2>
<p>To simplify writing the laws, we use the comparison between functions. For two functions <code>f</code> and <code>g</code>, we define </p><div class="fragment"><div class="line">f == g  <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>  f(x) == g(x) for all x</div>
</div><!-- fragment --><p>With the usual composition of functions, we are given two functions \( f : A \to B \) and \( g : B \to C \), and we must produce a new function \( compose(g, f) : A \to C \). This composition of functions is associative, which means that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(h, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, f)) == <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(h, g), f)</div>
</div><!-- fragment --><p>Also, this composition has an identity element, which is the identity function. This simply means that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, <span class="keywordtype">id</span>) == <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(<span class="keywordtype">id</span>, f) == f</div>
</div><!-- fragment --><p>This is probably nothing new if you are reading the <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> laws. Now, we can observe that the above is equivalent to saying that functions with the composition operator form a <code><a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a></code>, where the neutral element is the identity function.</p>
<p>Given an <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> <code>F</code>, what if we wanted to compose two functions \( f : A \to F(B) \) and \( g : B \to F(C) \)? When the <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> <code>F</code> is also a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>, such functions taking normal values but returning monadic values are called <em>monadic functions</em>. To compose them, we obviously can't use normal function composition, since the domains and codomains of <code>f</code> and <code>g</code> do not match properly. Instead, we'll need a new operator &ndash; let's call it <code>monadic_compose</code>: </p><p class="formulaDsp">
\[ \mathrm{monadic\_compose} : (B \to F(C)) \times (A \to F(B)) \to (A \to F(C)) \]
</p>
<p>How could we go about implementing this function? Well, since we know <code>F</code> is an <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>, the only functions we have are <code>transform</code> (from <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>), and <code>lift</code> and <code>ap</code> (from <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>). Hence, the only thing we can do at this point while respecting the signatures of <code>f</code> and <code>g</code> is to set (for <code>x</code> of type <code>A</code>) </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(g, f)(x) = transform(f(x), g)</div>
</div><!-- fragment --><p>Indeed, <code>f(x)</code> is of type <code>F(B)</code>, so we can map <code>g</code> (which takes <code>B</code>'s) on it. Doing so will leave us with a result of type <code>F(F(C))</code>, but what we wanted was a result of type <code>F(C)</code> to respect the signature of <code>monadic_compose</code>. If we had a joker of type \( F(F(C)) \to F(C) \), we could simply set </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(g, f)(x) = joker(transform(f(x), g))</div>
</div><!-- fragment --><p>and we would be happy. It turns out that <code>flatten</code> is precisely this joker. Now, we'll want our joker to satisfy some properties to make sure this composition is associative, just like our normal composition was. These properties are slightly cumbersome to specify, so we won't do it here. Also, we'll need some kind of neutral element for the composition. This neutral element can't be the usual identity function, because it does not have the right type: our neutral element needs to be a function of type \( X \to F(X) \) but the identity function has type \( X \to X \). It is now the right time to observe that <code>lift</code> from <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> has exactly the right signature, and so we'll take this for our neutral element.</p>
<p>We are now ready to formulate the <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> laws using this composition operator. For a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> <code>M</code> and functions \( f : A \to M(B) \), \( g : B \to M(C) \) and \( h : C \to M(D) \), the following must be satisfied: </p><div class="fragment"><div class="line"><span class="comment">// associativity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(h, <a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(g, f)) == <a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(h, g), f)</div>
<div class="line"></div>
<div class="line"><span class="comment">// right identity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(f, lift&lt;M(A)&gt;) == f</div>
<div class="line"></div>
<div class="line"><span class="comment">// left identity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(lift&lt;M(B)&gt;, f) == f</div>
</div><!-- fragment --><p>which is to say that <code>M</code> along with monadic composition is a <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> where the neutral element is <code>lift</code>.</p>
<h2>Provided superclass methods </h2>
<ol type="1">
<li><code>ap</code> from <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code><br />
When the minimal complete definition for <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> and <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> are both satisfied, it is possible to automatically implement <code>ap</code> by setting <div class="fragment"><div class="line">ap(fs, xs) = <a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(fs, [](<span class="keyword">auto</span> f) {</div>
<div class="line">    <span class="keywordflow">return</span> transform(xs, f);</div>
<div class="line">})</div>
</div><!-- fragment --> This implementation is provided through the <code>Monad::ap_impl</code> type, which you can use as follows: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>ap_impl&lt;YourDatatype&gt;</div>
<div class="line">    : Monad::ap_impl&lt;YourDatatype&gt;</div>
<div class="line">{ };</div>
</div><!-- fragment --> </li>
</ol>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:ae8749eb63880a6a84ddee9ada5c1466c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a></td></tr>
<tr class="memdesc:ae8749eb63880a6a84ddee9ada5c1466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed a monadic value into a monadic computation.  <a href="#ae8749eb63880a6a84ddee9ada5c1466c">More...</a><br /></td></tr>
<tr class="separator:ae8749eb63880a6a84ddee9ada5c1466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45985423d0658e88f0403773146af110"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a></td></tr>
<tr class="memdesc:a45985423d0658e88f0403773146af110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse two levels of monadic structure into a single level.  <a href="#a45985423d0658e88f0403773146af110">More...</a><br /></td></tr>
<tr class="separator:a45985423d0658e88f0403773146af110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9320a2061eb61136c4ea0ea74b22ce"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a></td></tr>
<tr class="memdesc:a0e9320a2061eb61136c4ea0ea74b22ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of monadic functions.  <a href="#a0e9320a2061eb61136c4ea0ea74b22ce">More...</a><br /></td></tr>
<tr class="separator:a0e9320a2061eb61136c4ea0ea74b22ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc7efb0044a87a21f663b1a151dac56"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#abfc7efb0044a87a21f663b1a151dac56">then</a></td></tr>
<tr class="memdesc:abfc7efb0044a87a21f663b1a151dac56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially compose two monadic actions, discarding any value produced by the first but not its effects.  <a href="#abfc7efb0044a87a21f663b1a151dac56">More...</a><br /></td></tr>
<tr class="separator:abfc7efb0044a87a21f663b1a151dac56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad.html#a17ea859a2702ea45ea4999a8a0d2cc63">tap</a></td></tr>
<tr class="memdesc:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tap inside a monadic chain.  <a href="#a17ea859a2702ea45ea4999a8a0d2cc63">More...</a><br /></td></tr>
<tr class="separator:a17ea859a2702ea45ea4999a8a0d2cc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="ae8749eb63880a6a84ddee9ada5c1466c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto chain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Feed a monadic value into a monadic computation. </p>
<p>Given a monadic value and a monadic function, <code>chain</code> feeds the monadic value into the function, thus performing some Monad-specific effects, and returns the result. An implementation of <code>chain</code> must satisfy </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(xs, f) == <a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(transform(xs, f))</div>
</div><!-- fragment --><h2>Signature </h2>
<p>For a monad <code>M</code>, given a monadic value of type <code>M(A)</code> and a monadic function \( f : A \to M(B) \), <code>chain</code> has the signature \( \mathrm{chain} : M(A) \times (A \to M(B)) \to M(B) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic value to be fed to the function <code>f</code>.</td></tr>
    <tr><td class="paramname">f</td><td>A function taking a normal value in the <code>xs</code> structure, and returning a monadic value. This function is called as <code>f(x)</code>, where <code>x</code> is an element of the structure <code>xs</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Operator-form </h2>
<p>For convenience, the <code>chain</code> method can be applied to <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>s that support it by using the <code>|</code> operator. Hence, if <code>xs</code> supports the operator, </p><div class="fragment"><div class="line">xs | f == <a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(xs, f)</div>
</div><!-- fragment --><p>Furthermore, this operator is left associative, which means that </p><div class="fragment"><div class="line">xs | f | g == (xs | f) | g == <a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(xs, f), g)</div>
</div><!-- fragment --><p>This allows creating chains of monadic computations easily.</p>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> deref = [](<span class="keyword">auto</span> x) -&gt; decltype(*x) {</div>
<div class="line">    <span class="keywordflow">return</span> *x;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> age = [](<span class="keyword">auto</span> x) -&gt; decltype(x.age) {</div>
<div class="line">    <span class="keywordflow">return</span> x.age;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(sfinae(deref)(x), sfinae(age));</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> age;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{30};</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Can&#39;t dereference a non-pointer.</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(f(john) == nothing);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// `int` has no member named `age`.</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(f(1) == nothing);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// All is good.</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(f(&amp;john) == just(30u));</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45985423d0658e88f0403773146af110"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto flatten</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Collapse two levels of monadic structure into a single level. </p>
<p>Given a monadic value wrapped into two levels of monad, <code>flatten</code> removes one such level. An implementation of <code>flatten</code> must satisfy </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(xs) == <a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(xs, <span class="keywordtype">id</span>)</div>
</div><!-- fragment --><h2>Signature </h2>
<p>For a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> <code>M</code> and an arbitrary data type <code>T</code>, <code>flatten</code> has a signature of \( \mathrm{flatten} : M(M(T)) \to M(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A value with two levels of monadic structure, which should be collapsed into a single level of structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2, 3), make&lt;Tuple&gt;(4, 5), make&lt;Tuple&gt;(6, 7, 8, 9)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(1, 2, 3, 4, 5, 6, 7, 8, 9)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(nothing) == nothing);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(just(just(1))) == just(1));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad.html#a45985423d0658e88f0403773146af110">flatten</a>(just(nothing)) == nothing);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e9320a2061eb61136c4ea0ea74b22ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto monadic_compose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; g) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> hana::chain(forwarded(g)(forwarded(x)), forwarded(f));</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Composition of monadic functions. </p>
<p>Given two monadic functions <code>f</code> and <code>g</code>, <code>monadic_compose</code> returns a new function equivalent to the composition of <code>f</code> with <code>g</code>, except the result of <code>g</code> is <code>chain</code>ed into <code>f</code> instead of simply passed to it, as with normal composition. <code>monadic_compose</code> satisfies </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(f, g)(x) == <a class="code" href="structboost_1_1hana_1_1_monad.html#ae8749eb63880a6a84ddee9ada5c1466c">chain</a>(g(x), f)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Unlike <code>compose</code>, <code>monadic_compose</code> does not generalize nicely to arities higher than one. Hence, only unary functions may be used with <code>monadic_compose</code>.</dd></dl>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> <code>M</code> and two functions \( f : B \to M(C) \) and \( g : A \to M(B) \), the signature is \( \mathrm{monadic_compose} : (B \to M(C)) \times (A \to M(B)) \to (A \to M(C)) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A monadic function with signature \( B \to M(C) \).</td></tr>
    <tr><td class="paramname">g</td><td>A monadic function with signature \( A \to M(B) \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is not tag-dispatched, so it can't be customized directly.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> block = [](<span class="keyword">auto</span> ...types) {</div>
<div class="line">    <span class="keywordflow">return</span> [=](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(elem(make&lt;Tuple&gt;(types...), decltype_(x)),</div>
<div class="line">            nothing,</div>
<div class="line">            just(x)</div>
<div class="line">        );</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> f = block(type&lt;double&gt;);</div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> g = block(type&lt;int&gt;);</div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> h = <a class="code" href="structboost_1_1hana_1_1_monad.html#a0e9320a2061eb61136c4ea0ea74b22ce">monadic_compose</a>(g, f);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(h(1)    == nothing); <span class="comment">// fails inside g; 1 has type int</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(h(1.2)  == nothing); <span class="comment">// fails inside f; 1.2 has type double</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(h(<span class="charliteral">&#39;x&#39;</span>) == just(<span class="charliteral">&#39;x&#39;</span>)); <span class="comment">// ok; &#39;x&#39; has type char</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abfc7efb0044a87a21f663b1a151dac56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto then</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; before, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sequentially compose two monadic actions, discarding any value produced by the first but not its effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">before</td><td>The first <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> in the monadic composition chain. The result of this monad is ignored, but its effects are combined with that of the second monad.</td></tr>
    <tr><td class="paramname">xs</td><td>The second <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> in the monadic composition chain.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>undefined { };</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad.html#abfc7efb0044a87a21f663b1a151dac56">then</a>(make&lt;Tuple&gt;(undefined{}, undefined{}), make&lt;Tuple&gt;(1, 2, 3)) == make&lt;Tuple&gt;(</div>
<div class="line">        1, 2, 3,</div>
<div class="line">        1, 2, 3</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a17ea859a2702ea45ea4999a8a0d2cc63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Tap inside a monadic chain. </p>
<p>Given a function <code>f</code>, <code>tap&lt;M&gt;</code> returns a new function which performs <code>f</code> on its argument and then returns the argument lifted in the <code>M</code> <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>. Combined with the property that <code>chain(m, lift&lt;M&gt;) == m</code>, this provides a way of executing an action inside a monadic chain without influencing its overall result. This is useful to e.g. insert debug statements or perform actions that are not tied to the chain but that need to be executed inside of it.</p>
<dl class="section note"><dt>Note</dt><dd>Since C++ is not a pure language, it is possible to perform side effects inside the <code>f</code> function. Actually, side effects are the only reason why one might want to use <code>tap</code>. However, one should not rely on the side effects being done in any specific order.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The data type (a <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>) of the monads in the tapped monadic chain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function to be executed inside a monadic chain. It will be called as <code>f(x)</code>, where <code>x</code> is a value inside the previous monad in the chain. The result of <code>f</code> is always discarded.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">std::stringstream before, after;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> xs = make&lt;Tuple&gt;(1, 2, 3)</div>
<div class="line">    | tap&lt;Tuple&gt;([&amp;](<span class="keyword">auto</span> x) { before &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>; })</div>
<div class="line">    | [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> make&lt;Tuple&gt;(x, -x); }</div>
<div class="line">    | tap&lt;Tuple&gt;([&amp;](<span class="keyword">auto</span> x) { after &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>; });</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(before.str() == <span class="stringliteral">&quot;1 2 3 &quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(after.str() == <span class="stringliteral">&quot;1 -1 2 -2 3 -3 &quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(xs == make&lt;Tuple&gt;(1, -1, 2, -2, 3, -3));</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_monad.html">Monad</a></li>
  </ul>
</div>
</body>
</html>
