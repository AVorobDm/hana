<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: boost::hana::Foldable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/9029554299b379bd015d102ecdcc5ff455469b6b/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/implementation-defined/g, "implementation-defined".link("index.html#tutorial-glossary-implementation_defined").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.6.2/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Foldable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1Foldable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Foldable Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> concept represents data structures that can be reduced to a single value. </p>
<p>Generally speaking, folding refers to the concept of summarizing a complex structure as a single value, by successively applying a binary operation which reduces two elements of the structure to a single value. Folds come in many flavors; left folds, right folds, folds with and without an initial reduction state, and their monadic variants. This concept is able to express all of these fold variants.</p>
<p>Another way of seeing <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> is as data structures supporting internal iteration with the ability to accumulate a result. By internal iteration, we mean that the <em>loop control</em> is in the hand of the structure, not the caller. Hence, it is the structure who decides when the iteration stops, which is normally when the whole structure has been consumed. Since C++ is an eager language, this requires <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> structures to be finite, or otherwise one would need to loop indefinitely to consume the whole structure.</p>
<dl class="section note"><dt>Note</dt><dd>While the fact that <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> only works for finite structures may seem overly restrictive in comparison to the Haskell definition of <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>, a finer grained separation of the concepts should mitigate the issue. For iterating over possibly infinite data structures, see the <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code> concept. For searching a possibly infinite data structure, see the <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> concept.</dd></dl>
<h2>Minimal complete definition </h2>
<p><code>fold_left</code> or <code>unpack</code></p>
<p>However, please note that a minimal complete definition provided through <code>unpack</code> will be much more compile-time efficient than one provided through <code>fold_left</code>.</p>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique and Comparable keys. ">hana::map</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1pair.html" title="Generic container for two elements. ">hana::pair</a></code>, <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring compile-time Comparable elements. ">hana::set</a></code>, <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants. ">hana::range</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code></p>
<p><a class="anchor" id="Foldable-lin"></a></p><h2>The linearization of a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> </h2>
<p>Intuitively, for a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> structure <code>xs</code>, the <em>linearization</em> of <code>xs</code> is the sequence of all the elements in <code>xs</code> as if they had been put in a list: </p><div class="fragment"><div class="line">linearization(xs) = [x1, x2, ..., xn]</div>
</div><!-- fragment --><p>Note that it is always possible to produce such a linearization for a finite <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> by setting </p><div class="fragment"><div class="line">linearization(xs) = <a class="code" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a>(xs, [], <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(prepend))</div>
</div><!-- fragment --><p> for an appropriate definition of <code>[]</code> and <code>prepend</code>. The notion of linearization is useful for expressing various properties of <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> structures, and is used across the documentation. Also note that <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>s define an <a class="el" href="structboost_1_1hana_1_1Iterable.html#Iterable-lin">extended version</a> of this allowing for infinite structures.</p>
<h2>Compile-time Foldables </h2>
<p>A compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> is a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> whose total length is known at compile-time. In other words, it is a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> whose <code>length</code> method returns a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type. When folding a compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>, the folding can be unrolled, because the final number of steps of the algorithm is known at compile-time.</p>
<p>Additionally, the <code>unpack</code> method is only available to compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>s. This is because the return <em>type</em> of <code>unpack</code> depends on the number of objects in the structure. Being able to resolve <code>unpack</code>'s return type at compile-time hence requires the length of the structure to be known at compile-time too.</p>
<p><b>In the current version of the library, only compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>s are supported.</b> While it would be possible in theory to support runtime <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>s too, doing so efficiently requires more research.</p>
<h2>Provided conversion to <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s </h2>
<p>Given a tag <code>S</code> which is a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>, an object whose tag is a model of the <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> concept can be converted to an object of tag <code>S</code>. In other words, a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> can be converted to a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S</code>, by simply taking the linearization of the <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> and creating the sequence with that. More specifically, given a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> <code>xs</code> with a linearization of <code>[x1, ..., xn]</code> and a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> tag <code>S</code>, <code>to&lt;S&gt;(xs)</code> is equivalent to <code>make&lt;S&gt;(x1, ..., xn)</code>. </p><div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2convert_8hpp.html">boost/hana/core/convert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    static_assert(hana::to&lt;hana::Tuple&gt;(hana::just(1)) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::to&lt;hana::Tuple&gt;(hana::nothing) == hana::make_tuple());</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::to&lt;hana::Tuple&gt;(hana::make_range(hana::int_c&lt;3&gt;, hana::int_c&lt;6&gt;))</div>
<div class="line">            ==</div>
<div class="line">        hana::tuple_c&lt;int, 3, 4, 5&gt;</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Free model for builtin arrays </h2>
<p>Builtin arrays whose size is known can be folded as-if they were homogeneous tuples. However, note that builtin arrays can't be made more than <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> (e.g. <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>) because they can't be empty and they also can't be returned from functions.</p>
<p><a class="anchor" id="monadic-folds"></a></p><h2>Primer on monadic folds </h2>
<p>A monadic fold is a fold in which subsequent calls to the binary function are chained with the monadic <code>chain</code> operator of the corresponding <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>. This allows a structure to be folded in a custom monadic context. For example, performing a monadic fold with the <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code> monad would require the binary function to return the result as a <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, and the fold would abort and return <code>nothing</code> whenever one of the accumulation step would fail (i.e. return <code>nothing</code>). If, however, all the reduction steps succeed, then <code>just</code> the result would be returned. Different monads will of course result in different effects. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a></td></tr>
<tr class="memdesc:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure that compare equal to a given value.  <a href="#ae0a55dd7eb4bd4f587f51ffd8c923e53">More...</a><br /></td></tr>
<tr class="separator:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca48cce90274a5f54354f9d4622930"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a21ca48cce90274a5f54354f9d4622930">count_if</a></td></tr>
<tr class="memdesc:a21ca48cce90274a5f54354f9d4622930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure for which the <code>predicate</code> is satisfied.  <a href="#a21ca48cce90274a5f54354f9d4622930">More...</a><br /></td></tr>
<tr class="separator:a21ca48cce90274a5f54354f9d4622930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e653553829fc2bf88f13ab907def1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a> = <a class="el" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a></td></tr>
<tr class="memdesc:a4e8e653553829fc2bf88f13ab907def1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>fold_left</code>; provided for convenience.  <a href="#a4e8e653553829fc2bf88f13ab907def1">More...</a><br /></td></tr>
<tr class="separator:a4e8e653553829fc2bf88f13ab907def1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46946b7ca62544d9e131906a9013c96"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a></td></tr>
<tr class="memdesc:ab46946b7ca62544d9e131906a9013c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-fold of a structure using a binary operation and an optional initial reduction state.  <a href="#ab46946b7ca62544d9e131906a9013c96">More...</a><br /></td></tr>
<tr class="separator:ab46946b7ca62544d9e131906a9013c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8d32dd48a8f0406d92b70c18fdf7ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a8d8d32dd48a8f0406d92b70c18fdf7ec">fold_right</a></td></tr>
<tr class="memdesc:a8d8d32dd48a8f0406d92b70c18fdf7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-fold of a structure using a binary operation and an optional initial reduction state.  <a href="#a8d8d32dd48a8f0406d92b70c18fdf7ec">More...</a><br /></td></tr>
<tr class="separator:a8d8d32dd48a8f0406d92b70c18fdf7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80176fbdfbccc09e902263557eb0984d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a></td></tr>
<tr class="memdesc:a80176fbdfbccc09e902263557eb0984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an action on each element of a foldable, discarding the result each time.  <a href="#a80176fbdfbccc09e902263557eb0984d">More...</a><br /></td></tr>
<tr class="separator:a80176fbdfbccc09e902263557eb0984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0840e48f29a87467e23d801ca0ca122a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a0840e48f29a87467e23d801ca0ca122a">fuse</a></td></tr>
<tr class="memdesc:a0840e48f29a87467e23d801ca0ca122a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a function taking multiple arguments into a function that can be called with a compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>.  <a href="#a0840e48f29a87467e23d801ca0ca122a">More...</a><br /></td></tr>
<tr class="separator:a0840e48f29a87467e23d801ca0ca122a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb377e43aa7753bb77aa346c67fae0d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a></td></tr>
<tr class="memdesc:a5fb377e43aa7753bb77aa346c67fae0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in a foldable structure.  <a href="#a5fb377e43aa7753bb77aa346c67fae0d">More...</a><br /></td></tr>
<tr class="separator:a5fb377e43aa7753bb77aa346c67fae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a8fde2d3de61959c99e755a81c0a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a></td></tr>
<tr class="memdesc:ac49a8fde2d3de61959c99e755a81c0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.  <a href="#ac49a8fde2d3de61959c99e755a81c0a1">More...</a><br /></td></tr>
<tr class="separator:ac49a8fde2d3de61959c99e755a81c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead74d4a75dd467873fcc9124d06b5f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a></td></tr>
<tr class="memdesc:aead74d4a75dd467873fcc9124d06b5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.  <a href="#aead74d4a75dd467873fcc9124d06b5f4">More...</a><br /></td></tr>
<tr class="separator:aead74d4a75dd467873fcc9124d06b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52e67ac8ae8529882650a6d03326f6c"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ab52e67ac8ae8529882650a6d03326f6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#ab52e67ac8ae8529882650a6d03326f6c">monadic_fold_left</a></td></tr>
<tr class="memdesc:ab52e67ac8ae8529882650a6d03326f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monadic left-fold of a structure with a binary operation and an optional initial reduction state.  <a href="#ab52e67ac8ae8529882650a6d03326f6c">More...</a><br /></td></tr>
<tr class="separator:ab52e67ac8ae8529882650a6d03326f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aab99a990fb0c212456962ffdfe6cff"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a8aab99a990fb0c212456962ffdfe6cff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a8aab99a990fb0c212456962ffdfe6cff">monadic_fold_right</a></td></tr>
<tr class="memdesc:a8aab99a990fb0c212456962ffdfe6cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monadic right-fold of a structure with a binary operation and an optional initial reduction state.  <a href="#a8aab99a990fb0c212456962ffdfe6cff">More...</a><br /></td></tr>
<tr class="separator:a8aab99a990fb0c212456962ffdfe6cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37fd8d56461f749d49423c711e4c67a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#aa37fd8d56461f749d49423c711e4c67a">product</a> = see documentation</td></tr>
<tr class="memdesc:aa37fd8d56461f749d49423c711e4c67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the numbers of a structure.  <a href="#aa37fd8d56461f749d49423c711e4c67a">More...</a><br /></td></tr>
<tr class="separator:aa37fd8d56461f749d49423c711e4c67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9240a51cd23ef65186e32d643e82f52e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a></td></tr>
<tr class="memdesc:a9240a51cd23ef65186e32d643e82f52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>reverse_fold</code> in Boost.Fusion and Boost.MPL.  <a href="#a9240a51cd23ef65186e32d643e82f52e">More...</a><br /></td></tr>
<tr class="separator:a9240a51cd23ef65186e32d643e82f52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d3fe103aa2ab8634a824562dd8390c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a95d3fe103aa2ab8634a824562dd8390c">size</a> = hana::length</td></tr>
<tr class="memdesc:a95d3fe103aa2ab8634a824562dd8390c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>length</code>; provided for consistency with the standard library.  <a href="#a95d3fe103aa2ab8634a824562dd8390c">More...</a><br /></td></tr>
<tr class="separator:a95d3fe103aa2ab8634a824562dd8390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99a05a203907d1381a00d9e05425ab7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#ae99a05a203907d1381a00d9e05425ab7">sum</a> = see documentation</td></tr>
<tr class="memdesc:ae99a05a203907d1381a00d9e05425ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the numbers of a structure.  <a href="#ae99a05a203907d1381a00d9e05425ab7">More...</a><br /></td></tr>
<tr class="separator:ae99a05a203907d1381a00d9e05425ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3e724580e826eaa39a934eefa2b328"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Foldable.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a></td></tr>
<tr class="memdesc:a0e3e724580e826eaa39a934eefa2b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the elements of a <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> as arguments.  <a href="#a0e3e724580e826eaa39a934eefa2b328">More...</a><br /></td></tr>
<tr class="separator:a0e3e724580e826eaa39a934eefa2b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="ae0a55dd7eb4bd4f587f51ffd8c923e53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; value) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in the structure that compare equal to a given value. </p>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> structure <code>xs</code> and a value <code>value</code>, <code>count</code> returns an unsigned integral, or a <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> thereof, representing the number of elements of <code>xs</code> that compare equal to <code>value</code>. For this method to be well-defined, all the elements of the structure must be <a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a> with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">value</td><td>A value compared with each element in the structure. Elements that compare equal to this value are counted, others are not.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count_8hpp.html">boost/hana/count.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keyword">auto</span> ints = hana::tuple_c&lt;int, 1, 2, 3, 2, 2, 4, 2&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::count(ints, hana::int_c&lt;2&gt;) == hana::size_c&lt;4&gt;);</div>
<div class="line">    static_assert(hana::count(ints, 2) == 4, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;int, char, long, short, char, double&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::count(types, hana::type_c&lt;char&gt;) == hana::size_c&lt;2&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a21ca48cce90274a5f54354f9d4622930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto count_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in the structure for which the <code>predicate</code> is satisfied. </p>
<p>Specifically, returns an object of an unsigned integral type, or a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding such an object, which represents the number of elements in the structure satisfying the given <code>predicate</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should be counted.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count__if_8hpp.html">boost/hana/count_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rem_8hpp.html">boost/hana/rem.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keyword">auto</span> ints = hana::tuple_c&lt;int, 1, 2, 3&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::count_if(ints, is_odd) == hana::size_c&lt;2&gt;);</div>
<div class="line"></div>
<div class="line">    constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;int, char, long, short, char, double&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::count_if(types, hana::trait&lt;std::is_floating_point&gt;) == hana::size_c&lt;1&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::count_if(types, hana::equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;char&gt;)) == hana::size_c&lt;2&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::count_if(types, hana::equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;void&gt;)) == hana::size_c&lt;0&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.count_if.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a4e8e653553829fc2bf88f13ab907def1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fold = <a class="el" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>fold_left</code>; provided for convenience. </p>
<p><code>fold</code> is equivalent to <code>fold_left</code>. However, it is not tag-dispatched on its own because it is just an alias to <code>fold_left</code>. Also note that <code>fold</code> can be called with or without an initial state, just like <code>fold_left</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>(xs, state, f) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a>(xs, state, f)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#a4e8e653553829fc2bf88f13ab907def1">fold</a>(xs, f) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a>(xs, f)</div>
</div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold_8hpp.html">boost/hana/fold.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// with an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::fold(hana::make_tuple(2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), <span class="stringliteral">&quot;1&quot;</span>, f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// without initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::fold(hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, 2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab46946b7ca62544d9e131906a9013c96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fold_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Left-fold of a structure using a binary operation and an optional initial reduction state. </p>
<p><code>fold_left</code> is a left-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_left</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">f(... f(f(f(x1, x2), x3), x4) ..., xn) <span class="comment">// without state</span></div>
<div class="line">f(... f(f(f(f(state, x1), x2), x3), x4) ..., xn) <span class="comment">// with state</span></div>
</div><!-- fragment --><p>When the structure is empty, two things may arise. If an initial state was provided, it is returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is returned as is.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>fold_left</code> are </p><p class="formulaDsp">
\[ \mathtt{fold\_left} : F(T) \times S \times (S \times T \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{fold\_left} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For left folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold__left_8hpp.html">boost/hana/fold_left.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// with an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::fold_left(hana::make_tuple(2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), <span class="stringliteral">&quot;1&quot;</span>, f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// without initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::fold_left(hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, 2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.fold_left.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a8d8d32dd48a8f0406d92b70c18fdf7ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fold_right</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Right-fold of a structure using a binary operation and an optional initial reduction state. </p>
<p><code>fold_right</code> is a right-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_right</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn-1, xn) ... )))) <span class="comment">// without state</span></div>
<div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn, state) ... )))) <span class="comment">// with state</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>fold_left</code>.</dd></dl>
<p>When the structure is empty, two things may arise. If an initial state was provided, it is returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is returned as is.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>fold_right</code> are </p><p class="formulaDsp">
\[ \mathtt{fold\_right} : F(T) \times S \times (T \times S \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{fold\_right} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For right folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold__right_8hpp.html">boost/hana/fold_right.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> f = [=](<span class="keyword">auto</span> element, std::string s) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + to_string(element) + <span class="stringliteral">&quot;, &quot;</span> + s + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// with an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::fold_right(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4), <span class="stringliteral">&quot;5&quot;</span>, f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(1, f(2, f(3, f(4, 5))))&quot;</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// without initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::fold_right(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4, <span class="stringliteral">&quot;5&quot;</span>), f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(1, f(2, f(3, f(4, 5))))&quot;</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.fold_right.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a80176fbdfbccc09e902263557eb0984d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto for_each</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Perform an action on each element of a foldable, discarding the result each time. </p>
<p>Iteration is done from left to right, i.e. in the same order as when using <code>fold_left</code>. If the structure is not finite, this method will not terminate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to iterate over.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> for each element <code>x</code> of the structure. The result of <code>f(x)</code>, whatever it is, is ignored.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="for__each_8hpp.html">boost/hana/for_each.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    hana::for_each(hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, <span class="stringliteral">&quot;234&quot;</span>, 5.5), [&amp;](<span class="keyword">auto</span> x) {</div>
<div class="line">        ss &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ss.str() == <span class="stringliteral">&quot;0 1 234 5.5 &quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0840e48f29a87467e23d801ca0ca122a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fuse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Foldable.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a>(forwarded(xs), forwarded(f));</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Transform a function taking multiple arguments into a function that can be called with a compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>. </p>
<p>This function is provided for convenience as a different way of calling <code>unpack</code>. Specifically, <code>fuse(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#a0840e48f29a87467e23d801ca0ca122a">fuse</a>(f)(foldable) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a>(foldable, f)</div>
<div class="line">                  == f(x...)</div>
</div><!-- fragment --><p> where <code>x...</code> are the elements in the foldable. This function is useful when one wants to create a function that accepts a foldable which is not known yet.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not tag-dispatched; customize <code>unpack</code> instead.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fuse_8hpp.html">boost/hana/fuse.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> tie = [](<span class="keyword">auto</span>&amp; ...vars) {</div>
<div class="line">    <span class="keywordflow">return</span> hana::fuse([&amp;vars...](auto ...values) {</div>
<div class="line">        <span class="comment">// Using an initializer list to sequence the assignments.</span></div>
<div class="line">        int dummy[] = {0, ((void)(vars = values), 0)...};</div>
<div class="line">        (<span class="keywordtype">void</span>)dummy;</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordtype">int</span> a = 0;</div>
<div class="line">    <span class="keywordtype">char</span> b = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    <span class="keywordtype">double</span> c = 0;</div>
<div class="line"></div>
<div class="line">    tie(a, b, c)(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(a == 1 &amp;&amp; b == <span class="charliteral">&#39;2&#39;</span> &amp;&amp; c == 3.3);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5fb377e43aa7753bb77aa346c67fae0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in a foldable structure. </p>
<p>Specifically, returns an object of an unsigned integral type, or a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding such an object, which represents the number of elements in the structure.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::length(hana::make_tuple()) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::length(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == hana::size_c&lt;3&gt;);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::length(hana::nothing) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::length(hana::just(<span class="charliteral">&#39;x&#39;</span>)) == hana::size_c&lt;1&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac49a8fde2d3de61959c99e755a81c0a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto maximum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; predicate]) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the greatest element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>. </p>
<p>Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>maximum</code> returns the greatest element of the structure, i.e. an element which is greater than or equal to every other element in the structure, according to the predicate.</p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. If no predicate is provided, the elements in the structure must be <a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>, or compile-time <a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a> if the structure is heterogeneous.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> <code>F</code>, a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a predicate \( \mathtt{pred} : T \times T \to Bool \), <code>maximum</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathtt{maximum} : F(T) \times (T \times T \to Bool) \to T \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>. The signature is then </p><p class="formulaDsp">
\[ \mathtt{maximum} : F(T) \to T \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to find the greatest element of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are elements of the structure. <code>predicate</code> should be a strict weak ordering on the elements of the structure and its return value should be a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, or a compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> if the structure is heterogeneous.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="greater_8hpp.html">boost/hana/greater.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="maximum_8hpp.html">boost/hana/maximum.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// without a predicate</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::maximum(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;) == hana::int_c&lt;9&gt;</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// with a predicate</span></div>
<div class="line">    <span class="keyword">auto</span> smallest = hana::maximum(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;, [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> x &gt; y; <span class="comment">// order is reversed!</span></div>
<div class="line">    });</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(smallest == hana::int_c&lt;-4&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Syntactic sugar (<code>maximum.by</code>) </h2>
<p><code>maximum</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(predicate) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>maximum(-, predicate)</code> denotes the partial application of <code>maximum</code> to <code>predicate</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="maximum_8hpp.html">boost/hana/maximum.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ordering_8hpp.html">boost/hana/ordering.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    static_assert(</div>
<div class="line">        hana::maximum.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(hana::ordering(hana::length), hana::make_tuple(</div>
<div class="line">            hana::make_tuple(),</div>
<div class="line">            hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>),</div>
<div class="line">            hana::make_tuple(3.3, <span class="keyword">nullptr</span>, 4)</div>
<div class="line">        ))</div>
<div class="line">        == hana::make_tuple(3.3, <span class="keyword">nullptr</span>, 4)</div>
<div class="line">    , <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>maximum</code> are tag-dispatched methods, and hence they can be customized independently. One reason for this is that some structures are able to provide a much more efficient implementation of <code>maximum</code> when the <code>less</code> predicate is used. Here is how the different versions of <code>maximum</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">maximum_impl&lt;data type of xs&gt;::apply</a>(xs)</div>
<div class="line">maximum(xs, pred) -&gt; maximum_pred_impl&lt;data type of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div>
</div><!-- fragment --><p>Also note that <code>maximum.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>maximum</code>. </p>

</div>
</div>
<a class="anchor" id="aead74d4a75dd467873fcc9124d06b5f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto minimum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; predicate]) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the least element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>. </p>
<p>Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>minimum</code> returns the least element of the structure, i.e. an element which is less than or equal to every other element in the structure, according to the predicate.</p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. If no predicate is provided, the elements in the structure must be <a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>, or compile-time <a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a> if the structure is heterogeneous.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> <code>F</code>, a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a predicate \( \mathtt{pred} : T \times T \to Bool \), <code>minimum</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathtt{minimum} : F(T) \times (T \times T \to Bool) \to T \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a>. The signature is then </p><p class="formulaDsp">
\[ \mathtt{minimum} : F(T) \to T \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to find the least element of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are elements of the structure. <code>predicate</code> should be a strict weak ordering on the elements of the structure and its return value should be a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, or a compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> if the structure is heterogeneous.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="greater_8hpp.html">boost/hana/greater.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="minimum_8hpp.html">boost/hana/minimum.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// without a predicate</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::minimum(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;) == hana::int_c&lt;-4&gt;</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// with a predicate</span></div>
<div class="line">    <span class="keyword">auto</span> largest = hana::minimum(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;, [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> x &gt; y; <span class="comment">// order is reversed!</span></div>
<div class="line">    });</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(largest == hana::int_c&lt;9&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Syntactic sugar (<code>minimum.by</code>) </h2>
<p><code>minimum</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(predicate) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>minimum(-, predicate)</code> denotes the partial application of <code>minimum</code> to <code>predicate</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="minimum_8hpp.html">boost/hana/minimum.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ordering_8hpp.html">boost/hana/ordering.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::minimum.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(hana::ordering(hana::length), hana::make_tuple(</div>
<div class="line">            hana::make_tuple(),</div>
<div class="line">            hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>),</div>
<div class="line">            hana::make_tuple(3.3, <span class="keyword">nullptr</span>, 4)</div>
<div class="line">        ))</div>
<div class="line">        == hana::make_tuple()</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>minimum</code> are tag-dispatched methods, and hence they can be customized independently. One reason for this is that some structures are able to provide a much more efficient implementation of <code>minimum</code> when the <code>less</code> predicate is used. Here is how the different versions of <code>minimum</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">minimum_impl&lt;data type of xs&gt;::apply</a>(xs)</div>
<div class="line">minimum(xs, pred) -&gt; minimum_pred_impl&lt;data type of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div>
</div><!-- fragment --><p>Also note that <code>minimum.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>minimum</code>. </p>

</div>
</div>
<a class="anchor" id="ab52e67ac8ae8529882650a6d03326f6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto monadic_fold_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Monadic left-fold of a structure with a binary operation and an optional initial reduction state. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes the reader to be accustomed to non-monadic left-folds as explained by <code>hana::fold_left</code>, and to have read the <a class="el" href="structboost_1_1hana_1_1Foldable.html#monadic-folds">primer</a> on monadic folds.</dd></dl>
<p><code>monadic_fold_left&lt;M&gt;</code> is a left-associative monadic fold. Given a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> with linearization <code>[x1, ..., xn]</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold_left&lt;M&gt;</code> applies <code>f</code> as follows: </p><div class="fragment"><div class="line"><span class="comment">// with state</span></div>
<div class="line">((((f(state, x1) | f(-, x2)) | f(-, x3)) | ...) | f(-, xn))</div>
<div class="line"></div>
<div class="line"><span class="comment">// without state</span></div>
<div class="line">((((f(x1, x2) | f(-, x3)) | f(-, x4)) | ...) | f(-, xn))</div>
</div><!-- fragment --><p>where <code>f(-, xk)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>chain</code>.</p>
<p>When the structure is empty, one of two things may happen. If an initial state was provided, it is lifted to the given <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is lifted into the given <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and returned as is.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> <code>M</code>, a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> <code>F</code>, an initial state of tag <code>S</code>, and a function \( f : S \times T \to M(S) \), the signatures of <code>monadic_fold_left&lt;M&gt;</code> are </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_left}_M : F(T) \times S \times (S \times T \to M(S)) \to M(S) \]
</p>
<p>for the version with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_left}_M : F(T) \times (T \times T \to M(T)) \to M(T) \]
</p>
<p>for the version without an initial state.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> representing the monadic context in which the fold happens. The return type of <code>f</code> must be in that <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. If the structure is empty, this value is lifted in to the <code>M</code> <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and then returned as-is.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. The function must return its result inside the <code>M</code> <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="utility_8hpp.html">boost/hana/ext/std/utility.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="monadic__fold__left_8hpp.html">boost/hana/monadic_fold_left.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> builtin_common_t = hana::sfinae([](<span class="keyword">auto</span>&amp;&amp; t, <span class="keyword">auto</span>&amp;&amp; u) -&gt; decltype(hana::type_c&lt;</div>
<div class="line">    std::decay_t&lt;decltype(<span class="keyword">true</span> ? hana::traits::declval(t) : hana::traits::declval(u))&gt;</div>
<div class="line">&gt;) { <span class="keywordflow">return</span> {}; });</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keyword">struct </span>common_type { };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div>
<div class="line"><span class="keyword">struct </span>common_type&lt;T, U&gt;</div>
<div class="line">    : std::conditional_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, T&gt;{} &amp;&amp;</div>
<div class="line">                         std::is_same&lt;std::decay_t&lt;U&gt;, U&gt;{},</div>
<div class="line">        decltype(builtin_common_t(hana::type_c&lt;T&gt;, hana::type_c&lt;U&gt;)),</div>
<div class="line">        common_type&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> ...Tn&gt;</div>
<div class="line"><span class="keyword">struct </span>common_type&lt;T1, Tn...&gt;</div>
<div class="line">    : decltype(hana::monadic_fold_left&lt;hana::Optional&gt;(</div>
<div class="line">        hana::tuple_t&lt;Tn...&gt;,</div>
<div class="line">        hana::type_c&lt;std::decay_t&lt;T1&gt;&gt;,</div>
<div class="line">        hana::sfinae(hana::metafunction&lt;common_type&gt;)</div>
<div class="line">    ))</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Ts&gt;</div>
<div class="line"><span class="keyword">using</span> common_type_t = <span class="keyword">typename</span> common_type&lt;Ts...&gt;::type;</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    common_type_t&lt;char, short, char, short&gt;,</div>
<div class="line">    <span class="keywordtype">int</span></div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    common_type_t&lt;char, double, short, char, short, double&gt;,</div>
<div class="line">    <span class="keywordtype">double</span></div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    common_type_t&lt;char, short, float, short&gt;,</div>
<div class="line">    <span class="keywordtype">float</span></div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::sfinae(hana::metafunction&lt;common_type&gt;)(</div>
<div class="line">        hana::type_c&lt;int&gt;, hana::type_c&lt;int&gt;, hana::type_c&lt;int*&gt;</div>
<div class="line">    ) == hana::nothing</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8aab99a990fb0c212456962ffdfe6cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto monadic_fold_right</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Monadic right-fold of a structure with a binary operation and an optional initial reduction state. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes the reader to be accustomed to non-monadic right-folds as explained by <code>hana::fold_right</code>, and to have read the <a class="el" href="structboost_1_1hana_1_1Foldable.html#monadic-folds">primer</a> on monadic folds.</dd></dl>
<p><code>monadic_fold_right&lt;M&gt;</code> is a right-associative monadic fold. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold_right&lt;M&gt;</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line"><span class="comment">// with state</span></div>
<div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn, state)))))</div>
<div class="line"></div>
<div class="line"><span class="comment">// without state</span></div>
<div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn-1, xn)))))</div>
</div><!-- fragment --><p>where <code>f(xk, -)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>chain</code>. It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>monadic_fold_left&lt;M&gt;</code>.</p>
<p>When the structure is empty, one of two things may happen. If an initial state was provided, it is lifted to the given <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is lifted into the given <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and returned as is.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> <code>M</code>, a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> <code>F</code>, an initial state of tag <code>S</code>, and a function \( f : T \times S \to M(S) \), the signatures of <code>monadic_fold_right&lt;M&gt;</code> are </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_right}_M : F(T) \times S \times (T \times S \to M(S)) \to M(S) \]
</p>
<p>for the version with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_right}_M : F(T) \times (T \times T \to M(T)) \to M(T) \]
</p>
<p>for the version without an initial state.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> representing the monadic context in which the fold happens. The return type of <code>f</code> must be in that <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. If the structure is empty, this value is lifted in to the <code>M</code> <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> and then returned as-is.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. The function must return its result inside the <code>M</code> <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval__if_8hpp.html">boost/hana/eval_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="monadic__fold__right_8hpp.html">boost/hana/monadic_fold_right.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quot_8hpp.html">boost/hana/quot.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> safe_div = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::eval_if(y == hana::int_c&lt;0&gt;,</div>
<div class="line">            hana::make_lazy(hana::nothing),</div>
<div class="line">            [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) {</div>
<div class="line">                <span class="keywordflow">return</span> hana::just(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(x) / y);</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// with an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::monadic_fold_right&lt;hana::Optional&gt;(</div>
<div class="line">            hana::tuple_c&lt;int, 1000, 8, 4&gt;, hana::int_c&lt;2&gt;, safe_div</div>
<div class="line">        )</div>
<div class="line">            ==</div>
<div class="line">        hana::just(hana::int_c&lt;1000&gt; / (hana::int_c&lt;8&gt; / (hana::int_c&lt;4&gt; / hana::int_c&lt;2&gt;)))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::monadic_fold_right&lt;hana::Optional&gt;(</div>
<div class="line">            hana::tuple_c&lt;int, 1000, 8, 4&gt;, hana::int_c&lt;0&gt;, safe_div</div>
<div class="line">        )</div>
<div class="line">            ==</div>
<div class="line">        hana::nothing</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// without an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::monadic_fold_right&lt;hana::Optional&gt;(</div>
<div class="line">            hana::tuple_c&lt;int, 1000, 8, 4, 2&gt;, safe_div</div>
<div class="line">        )</div>
<div class="line">            ==</div>
<div class="line">        hana::just(hana::int_c&lt;1000&gt; / (hana::int_c&lt;8&gt; / (hana::int_c&lt;4&gt; / hana::int_c&lt;2&gt;)))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::monadic_fold_right&lt;hana::Optional&gt;(</div>
<div class="line">            hana::tuple_c&lt;int, 1000, 8, 4, 0&gt;, safe_div</div>
<div class="line">        )</div>
<div class="line">            ==</div>
<div class="line">        hana::nothing</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa37fd8d56461f749d49423c711e4c67a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto product = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of the numbers of a structure. </p>
<p>More generally, <code>product</code> will take any foldable structure containing objects forming a <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> and reduce them using the <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a>'s binary operation. The initial state for folding is the identity of the <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a>'s operation. It is sometimes necessary to specify the <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> to use; this is possible by using <code>product&lt;R&gt;</code>. If no <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> is specified, the structure will use the <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Tag representing hana::integral_constant. ">IntegralConstant</a>&lt;int&gt;</code> otherwise. Hence, </p><div class="fragment"><div class="line">product&lt;R&gt;(xs) = <a class="code" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a>(xs, one&lt;R or inferred Ring&gt;(), mult)</div>
<div class="line">product&lt;&gt; = <a class="code" href="structboost_1_1hana_1_1Foldable.html#aa37fd8d56461f749d49423c711e4c67a">product</a>&lt;IntegralConstant&lt;int&gt;&gt;</div>
</div><!-- fragment --><p>For numbers, this will just compute the product of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a>, but it must be possible to perform <code>mult</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the <a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> concept.</dd>
<dd>
See the documentation for <code>sum</code> to understand why the <a class="el" href="structboost_1_1hana_1_1Ring.html" title="The Ring concept represents Groups that also form a Monoid under a second binary operation that distr...">Ring</a> must sometimes be specified explicitly.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="product_8hpp.html">boost/hana/product.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::product&lt;&gt;(hana::make_range(hana::int_c&lt;1&gt;, hana::int_c&lt;6&gt;)) == hana::int_c&lt;1 * 2 * 3 * 4 * 5&gt;</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::product&lt;&gt;(hana::make_tuple(1, hana::int_c&lt;3&gt;, hana::long_c&lt;-5&gt;, 9)) == 1 * 3 * -5 * 9</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::product&lt;unsigned long&gt;(hana::make_tuple(2ul, 3ul)) == 6ul</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.product.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a9240a51cd23ef65186e32d643e82f52e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse_fold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Foldable.html#a8d8d32dd48a8f0406d92b70c18fdf7ec">fold_right</a>(forwarded(xs), forwarded(state), <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(forwarded(f)));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>reverse_fold</code> in Boost.Fusion and Boost.MPL. </p>
<p>This method has the same semantics as <code>reverse_fold</code> in Boost.Fusion and Boost.MPL, with the extension that an initial state is not required. This method is equivalent to <code>fold_right</code>, except that the accumulating function must take its arguments in reverse order, to match the order used in Fusion. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a>(sequence, state, f) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#a8d8d32dd48a8f0406d92b70c18fdf7ec">fold_right</a>(sequence, state, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Foldable.html#a9240a51cd23ef65186e32d643e82f52e">reverse_fold</a>(sequence, f) == <a class="code" href="structboost_1_1hana_1_1Foldable.html#a8d8d32dd48a8f0406d92b70c18fdf7ec">fold_right</a>(sequence, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This method is a convenience alias to <code>fold_right</code>. As an alias, <code>reverse_fold</code> is not tag-dispatched on its own and <code>fold_right</code> should be customized instead.</dd></dl>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>reverse_fold</code> are </p><p class="formulaDsp">
\[ \mathtt{reverse\_fold} : F(T) \times S \times (S \times T \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{reverse\_fold} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For reverse folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reverse__fold_8hpp.html">boost/hana/reverse_fold.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// With an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::reverse_fold(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4), <span class="stringliteral">&quot;5&quot;</span>, f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(5, 4), 3), 2), 1)&quot;</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Without an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::reverse_fold(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4, <span class="stringliteral">&quot;5&quot;</span>), f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(5, 4), 3), 2), 1)&quot;</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a95d3fe103aa2ab8634a824562dd8390c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto size = hana::length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>length</code>; provided for consistency with the standard library. </p>
<p>This method is an alias to <code>length</code> provided for convenience and consistency with the standard library. As an alias, <code>size</code> is not tag-dispatched on its own and <code>length</code> should be customized instead.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="size_8hpp.html">boost/hana/size.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::size(hana::make_tuple()) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::size(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == hana::size_c&lt;3&gt;);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::size(hana::nothing) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::size(hana::just(<span class="charliteral">&#39;x&#39;</span>)) == hana::size_c&lt;1&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae99a05a203907d1381a00d9e05425ab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sum = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of the numbers of a structure. </p>
<p>More generally, <code>sum</code> will take any foldable structure containing objects forming a <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> and reduce them using the <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>'s binary operation. The initial state for folding is the identity of the <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>. It is sometimes necessary to specify the <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> to use; this is possible by using <code>sum&lt;M&gt;</code>. If no <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> is specified, the structure will use the <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Tag representing hana::integral_constant. ">IntegralConstant</a>&lt;int&gt;</code> otherwise. Hence, </p><div class="fragment"><div class="line">sum&lt;M&gt;(xs) = <a class="code" href="structboost_1_1hana_1_1Foldable.html#ab46946b7ca62544d9e131906a9013c96">fold_left</a>(xs, zero&lt;M or inferred Monoid&gt;(), plus)</div>
<div class="line">sum&lt;&gt; = <a class="code" href="structboost_1_1hana_1_1Foldable.html#ae99a05a203907d1381a00d9e05425ab7">sum</a>&lt;IntegralConstant&lt;int&gt;&gt;</div>
</div><!-- fragment --><p>For numbers, this will just compute the sum of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>, but it must be possible to perform <code>plus</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the <a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> concept.</dd></dl>
<h2>Why must we sometimes specify the <code><a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a></code> by using <code>sum&lt;M&gt;</code>? </h2>
<p>This is because sequence tags like <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="Tag representing hana::tuples. ">Tuple</a></code> are not parameterized (by design). Hence, we do not know what kind of objects are in the sequence, so we can't know a <code>0</code> value of which type should be returned when the sequence is empty. Therefore, the type of the <code>0</code> to return in the empty case must be specified explicitly. Other foldable structures like Ranges will ignore the suggested <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> because they know the data type of the objects they contain. This inconsistent behavior is a limitation of the current design with non-parameterized tags, but we have no good solution for now.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sum_8hpp.html">boost/hana/sum.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::sum&lt;&gt;(hana::make_range(hana::int_c&lt;1&gt;, hana::int_c&lt;6&gt;)) == hana::int_c&lt;15&gt;);</div>
<div class="line"></div>
<div class="line">static_assert(hana::sum&lt;&gt;(hana::make_tuple(1, hana::int_c&lt;3&gt;, hana::long_c&lt;-5&gt;, 9)) == 8, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(hana::sum&lt;unsigned long&gt;(hana::make_tuple(1ul, 3ul)) == 4ul, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0e3e724580e826eaa39a934eefa2b328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unpack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invoke a function with the elements of a <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> as arguments. </p>
<p>Given a function and a foldable structure whose length can be known at compile-time, <code>unpack</code> invokes the function with the contents of that structure. In other words, <code>unpack(xs, f)</code> is equivalent to <code>f(x...)</code>, where <code>x...</code> are the elements of the structure. The length of the structure must be known at compile-time, because the version of <code>f</code>'s <code>operator()</code> that will be compiled depends on the number of arguments it is called with, which has to be known at compile-time.</p>
<p>To create a function that accepts a foldable instead of variadic arguments, see <code>fuse</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to expand into the function.</td></tr>
    <tr><td class="paramname">f</td><td>A function to be invoked as <code>f(x...)</code>, where <code>x...</code> are the elements of the structure as-if they had been linearized with <code>to&lt;<a class="el" href="structboost_1_1hana_1_1Tuple.html" title="Tag representing hana::tuples. ">Tuple</a>&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unpack_8hpp.html">boost/hana/unpack.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div>
<div class="line">        <span class="keywordflow">return</span> x + y + z;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::unpack(hana::make_tuple(1, 2, 3), add) == 6);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Rationale: <code>unpack</code>'s name and parameter order </h2>
<p>It has been suggested a couple of times that <code>unpack</code> be called <code>apply</code> instead, and that the parameter order be reversed to match that of the <a href="http://en.cppreference.com/w/cpp/experimental/apply">proposed std::apply function</a>. However, the name <code>apply</code> is already used to denote normal function application, an use which is consistent with the Boost MPL library and with the rest of the world, especially the functional programming community. Furthermore, the author of this library considers the proposed <code>std::apply</code> to have both an unfortunate name and an unfortunate parameter order. Indeed, taking the function as the first argument means that using <code>std::apply</code> with a lambda function looks like </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">std::apply</a>([](<span class="keyword">auto</span> ...args) {</div>
<div class="line">    use(args...);</div>
<div class="line">}, tuple);</div>
</div><!-- fragment --><p>which is undeniably ugly because of the trailing <code>, tuple)</code> part on the last line. On the other hand, taking the function as a second argument allows one to write </p><div class="fragment"><div class="line">hana::unpack(tuple, [](<span class="keyword">auto</span> ...args) {</div>
<div class="line">    use(args...);</div>
<div class="line">});</div>
</div><!-- fragment --><p>which looks much nicer. Because of these observations, the author of this library feels justified to use <code>unpack</code> instead of <code>apply</code>, and to use a sane parameter order. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Foldable.html">Foldable</a></li>
  </ul>
</div>
</body>
</html>
