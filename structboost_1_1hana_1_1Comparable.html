<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: boost::hana::Comparable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/9029554299b379bd015d102ecdcc5ff455469b6b/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/implementation-defined/g, "implementation-defined".link("index.html#tutorial-glossary-implementation_defined").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.6.2/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Comparable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1Comparable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Comparable Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> concept defines equality and inequality. </p>
<p>Intuitively, <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> objects must define a binary predicate named <code>equal</code> that returns whether both objects represent the same abstract value. In other words, <code>equal</code> must check for deep equality. Since "representing the same abstract value" is difficult to express formally, the exact meaning of equality is partially left to interpretation by the programmer with the following guidelines:<br />
</p><ol type="1">
<li>Equality should be compatible with copy construction; copy constructing a value yields an <code>equal</code> value.</li>
<li>Equality should be independent of representation; an object representing a fraction as <code>4/8</code> should be <code>equal</code> to an object representing a fraction as <code>2/4</code>, because they both represent the mathematical object <code>1/2</code>.</li>
</ol>
<p>Moreover, <code>equal</code> must exhibit properties that make it intuitive to use for determining the equivalence of objects, which is formalized by the laws for <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>.</p>
<h2>Minimal complete definition </h2>
<ol type="1">
<li><code>equal</code><br />
When <code>equal</code> is defined, <code>not_equal</code> is implemented by default as its complement. For all objects <code>x</code>, <code>y</code> of a <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> tag, <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a>(x, y) == not_(<a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(x, y))</div>
</div><!-- fragment --></li>
</ol>
<h2>Laws </h2>
<p><code>equal</code> must define an <a href="http://en.wikipedia.org/wiki/Equivalence_relation#Definition">equivalence relation</a>, and <code>not_equal</code> must be its complement. In other words, for all objects <code>a</code>, <code>b</code>, <code>c</code> of a <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> tag, the following must be true (where <code>x == y</code> and <code>x != y</code> denote <code>equal(x, y)</code> and <code>not_equal(x, y)</code>, respectively): </p><div class="fragment"><div class="line">a == a                          <span class="comment">// Reflexivity</span></div>
<div class="line"><span class="keywordflow">if</span> a == b then b == a           <span class="comment">// Symmetry</span></div>
<div class="line"><span class="keywordflow">if</span> a == b &amp;&amp; b == c then a == c <span class="comment">// Transitivity</span></div>
<div class="line">a != b is equivalent <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a> !(a == b)</div>
</div><!-- fragment --><h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1integral__constant.html" title="Compile-time value of an integral type. ">hana::integral_constant</a></code>, <code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique and Comparable keys. ">hana::map</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1pair.html" title="Generic container for two elements. ">hana::pair</a></code>, <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants. ">hana::range</a></code>, <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring compile-time Comparable elements. ">hana::set</a></code>, <code><a class="el" href="structboost_1_1hana_1_1string.html" title="Compile-time string. ">hana::string</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code>, <code><a class="el" href="structboost_1_1hana_1_1type.html" title="C++ type in value-level representation. ">hana::type</a></code></p>
<h2>Free model for <code>EqualityComparable</code> data types </h2>
<p>Two tags <code>T</code> and <code>U</code> that model the cross-type EqualityComparable concept presented in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">N3351</a> automatically model the <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> concept by setting </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(x, y) = (x == y)</div>
</div><!-- fragment --><p> Note that this also makes EqualityComparable types in the <a href="http://en.cppreference.com/w/cpp/concept/EqualityComparable">usual sense</a> models of <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> in the same way.</p>
<h2>Equality-preserving functions </h2>
<p>Let <code>A</code> and <code>B</code> be two <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> tags. A function \(f : A \to B\) is said to be equality-preserving if it preserves the structure of the <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> concept, which can be rigorously stated as follows. For all objects <code>x</code>, <code>y</code> of tag <code>A</code>, </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>  <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(x, y)  then  <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(f(x), f(y))</div>
</div><!-- fragment --><p> Equivalently, we simply require that <code>f</code> is a function in the usual mathematical sense. Another property is <a href="http://en.wikipedia.org/wiki/Injective_function">injectivity</a>, which can be viewed as being a "lossless" mapping. This property can be stated as </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>  <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(f(x), f(y))  then  <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(x, y)</div>
</div><!-- fragment --><p> This is equivalent to saying that <code>f</code> maps distinct elements to distinct elements, hence the "lossless" analogy. In other words, <code>f</code> will not collapse distinct elements from its domain into a single element in its image, thus losing information.</p>
<p>These functions are very important, especially equality-preserving ones, because they allow us to reason simply about programs. Also note that the property of being equality-preserving is taken for granted in mathematics because it is part of the definition of a function. We feel it is important to make the distinction here because programming has evolved differently and as a result programmers are used to work with functions that do not preserve equality.</p>
<h2>Cross-type version of the methods </h2>
<p>The <code>equal</code> and <code>not_equal</code> methods are "overloaded" to handle distinct tags with certain properties. Specifically, they are defined for <em>distinct</em> tags <code>A</code> and <code>B</code> such that</p><ol type="1">
<li><code>A</code> and <code>B</code> share a common tag <code>C</code>, as determined by the <code>common</code> metafunction</li>
<li><code>A</code>, <code>B</code> and <code>C</code> are all <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> when taken individually</li>
<li>\( \mathtt{to&lt;C&gt;} : A \to C \) and \(\mathtt{to&lt;C&gt;} : B \to C\) are both equality-preserving and injective (i.e. they are embeddings), as determined by the <code>is_embedding</code> metafunction.</li>
</ol>
<p>The method definitions for tags satisfying the above properties are </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(x, y)     = <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(to&lt;C&gt;(x), to&lt;C&gt;(y))</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a>(x, y) = <a class="code" href="structboost_1_1hana_1_1Comparable.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a>(<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>&lt;C&gt;(x), <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>&lt;C&gt;(y))</div>
</div><!-- fragment --><h2>Important note: special behavior of <code>equal</code> </h2>
<p>In the context of programming with heterogeneous values, it is useful to have unrelated objects compare <code>false</code> instead of triggering an error. For this reason, <code>equal</code> adopts a special behavior for unrelated objects of tags <code>T</code> and <code>U</code> that do not satisfy the above requirements for the cross-type overloads. Specifically, when <code>T</code> and <code>U</code> are unrelated (i.e. <code>T</code> can't be converted to <code>U</code> and vice-versa), comparing objects with those tags yields a compile-time false value. This has the effect that unrelated objects like <code>float</code> and <code>std::string</code> will compare false, while comparing related objects that can not be safely embedded into the same super structure (like <code>long long</code> and <code>float</code> because of the precision loss) will trigger a compile-time assertion. Also note that for any tag <code>T</code> for which the minimal complete definition of <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> is not provided, a compile-time assertion will also be triggered because <code>T</code> and <code>T</code> trivially share the common tag <code>T</code>, which is the expected behavior. This design choice aims to provide more flexibility for comparing objects, while still rejecting usage patterns that are most likely programming errors. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:a350ae6cc37fa971f203065bb628a7948"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Comparable.html#a350ae6cc37fa971f203065bb628a7948">comparing</a></td></tr>
<tr class="memdesc:a350ae6cc37fa971f203065bb628a7948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function performing <code>equal</code> after applying a transformation to both arguments.  <a href="#a350ae6cc37fa971f203065bb628a7948">More...</a><br /></td></tr>
<tr class="separator:a350ae6cc37fa971f203065bb628a7948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d0a020ddd527610472c91f5a8cc627"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a></td></tr>
<tr class="memdesc:aa3d0a020ddd527610472c91f5a8cc627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> is equal to <code>y</code>.  <a href="#aa3d0a020ddd527610472c91f5a8cc627">More...</a><br /></td></tr>
<tr class="separator:aa3d0a020ddd527610472c91f5a8cc627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6983538356aab75eddf1a7aace6c7925"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Comparable.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a></td></tr>
<tr class="memdesc:a6983538356aab75eddf1a7aace6c7925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> is not equal to <code>y</code>.  <a href="#a6983538356aab75eddf1a7aace6c7925">More...</a><br /></td></tr>
<tr class="separator:a6983538356aab75eddf1a7aace6c7925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="a350ae6cc37fa971f203065bb628a7948"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto comparing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; y) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(f(forwarded(x)), f(forwarded(y)));</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a function performing <code>equal</code> after applying a transformation to both arguments. </p>
<p><code>comparing</code> creates an equivalence relation based on the result of applying a function to some objects, which is especially useful in conjunction with algorithms that accept a custom predicate that must represent an equivalence relation.</p>
<p>Specifically, <code>comparing</code> is such that </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#a350ae6cc37fa971f203065bb628a7948">comparing</a>(f) == <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a> ^<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>^ f</div>
</div><!-- fragment --><p> or, equivalently, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#a350ae6cc37fa971f203065bb628a7948">comparing</a>(f)(x, y) == <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(f(x), f(y))</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This is not a tag-dispatched method (hence it can't be customized), but just a convenience function provided with the <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> concept.</dd></dl>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a <a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a> <code>B</code>, the signature is \( \mathtt{comparing} : (A \to B) \to (A \times A \to Bool) \).</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="comparing_8hpp.html">boost/hana/comparing.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="group_8hpp.html">boost/hana/group.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keyword">auto</span> sequences = hana::make_tuple(</div>
<div class="line">        hana::make_tuple(1, 2, 3),</div>
<div class="line">        hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;z&#39;</span>),</div>
<div class="line">        hana::range_c&lt;long, 0, 1&gt;,</div>
<div class="line">        hana::tuple_t&lt;char, int&gt;,</div>
<div class="line">        hana::range_c&lt;int, 0, 2&gt;,</div>
<div class="line">        hana::make_tuple(123.4, <span class="keyword">nullptr</span>)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    constexpr <span class="keyword">auto</span> grouped = hana::group.by(hana::comparing(hana::length), sequences);</div>
<div class="line"></div>
<div class="line">    static_assert(grouped == hana::make_tuple(</div>
<div class="line">        hana::make_tuple(</div>
<div class="line">            hana::make_tuple(1, 2, 3),</div>
<div class="line">            hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;z&#39;</span>)</div>
<div class="line">        ),</div>
<div class="line">        hana::make_tuple(</div>
<div class="line">            hana::range_c&lt;long, 0, 1&gt;</div>
<div class="line">        ),</div>
<div class="line">        hana::make_tuple(</div>
<div class="line">            hana::tuple_t&lt;char, int&gt;,</div>
<div class="line">            hana::range_c&lt;int, 0, 2&gt;,</div>
<div class="line">            hana::make_tuple(123.4, <span class="keyword">nullptr</span>)</div>
<div class="line">        )</div>
<div class="line">    ), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa3d0a020ddd527610472c91f5a8cc627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto equal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; y) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> is equal to <code>y</code>. </p>
<p>The <code>equal</code> function can be called in two different ways. First, it can be called like a normal function: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(x, y)</div>
</div><!-- fragment --><p>However, it may also be partially applied to an argument by using <code>equal.to</code>: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>.to(x)(y) == <a class="code" href="structboost_1_1hana_1_1Comparable.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a>(x, y)</div>
</div><!-- fragment --><p>In other words, <code>equal.to(x)</code> is a function object that is equivalent to <code>partial(equal, x)</code>. This is provided to enhance the readability of some constructs, especially when using higher order algorithms.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and two Comparables <code>A</code> and <code>B</code> that share a common embedding, the signature is \( \mathtt{equal} : A \times B \to Bool \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>Two objects to compare for equality.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="any__of_8hpp.html">boost/hana/any_of.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    static_assert(hana::equal(hana::make_tuple(1, 2), hana::make_tuple(1, 2)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(!hana::equal(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::equal(hana::make_tuple(1, 2), <span class="charliteral">&#39;y&#39;</span>));</div>
<div class="line"></div>
<div class="line">    static_assert(hana::any_of(hana::make_tuple(1, 2, 3), hana::equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(2)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<h4>Rationale for the arity of <code>equal</code></h4>
<p>It is a valid question whether <code>equal</code> should accept more than 2 arguments and have semantics matching those of Python's <code>==</code>. This is not supported right now for the following reasons:</p><ul>
<li>It was implemented in the MPL11, but it was not shown to be useful so far.</li>
<li>It does not make sense for <code>not_equal</code> to have an arity of more than 2, only <code>equal</code> could maybe have those semantics, which would break symmetry. </li>
</ul>
</blockquote>

</div>
</div>
<a class="anchor" id="a6983538356aab75eddf1a7aace6c7925"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto not_equal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; y) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> is not equal to <code>y</code>. </p>
<p>The <code>not_equal</code> function can be called in two different ways. First, it can be called like a normal function: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a>(x, y)</div>
</div><!-- fragment --><p>However, it may also be partially applied to an argument by using <code>not_equal.to</code>: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Comparable.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a>.to(x)(y) == <a class="code" href="structboost_1_1hana_1_1Comparable.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a>(x, y)</div>
</div><!-- fragment --><p>In other words, <code>not_equal.to(x)</code> is a function object that is equivalent to <code>partial(not_equal, x)</code>. This is provided to enhance the readability of some constructs, especially when using higher order algorithms.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and two Comparables <code>A</code> and <code>B</code> that share a common embedding, the signature is \( \mathtt{not\_equal} : A \times B \to Bool \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>Two objects to compare for inequality.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all__of_8hpp.html">boost/hana/all_of.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    static_assert(hana::not_equal(hana::make_tuple(1, 2), hana::make_tuple(3)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(hana::not_equal(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::not_equal(hana::make_tuple(1, 2), <span class="charliteral">&#39;y&#39;</span>));</div>
<div class="line"></div>
<div class="line">    static_assert(hana::all_of(hana::make_tuple(1, 2, 3), hana::not_equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(5)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Comparable.html">Comparable</a></li>
  </ul>
</div>
</body>
</html>
