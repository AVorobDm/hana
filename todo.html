<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('todo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="structboost_1_1hana_1_1Applicative.html#a5a974a72d39f90af2626d167d4efe29a">ap</a>  </dt>
<dd>Consider giving access to all the arguments to the tag-dispatched implementation for performance purposes.  </dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="group__group-functional.html#ga6acc765a35c4dc85f0deab4785831a3d">boost::hana::arg</a>  </dt>
<dd>This implementation is less compile-time efficient than <code>variadic::at</code>, but at least we can use perfect forwarding. Is there a way to get the efficiency of <code>variadic::at</code> with perfect forwarding?  </dd>
<dt><a class="anchor" id="_todo000007"></a>Class <a class="el" href="structboost_1_1hana_1_1Comparable.html">boost::hana::Comparable</a>  </dt>
<dd><ul>
<li>Make sure no circularity issue with our provided operators can arise when checking for the EqualityComparable concept.</li>
<li>We could do some data type checks at the interface level, but those checks would be a bit hairy because of the cross-type methods. How should we handle that? </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000008"></a>Class <a class="el" href="structboost_1_1hana_1_1Constant.html">boost::hana::Constant</a>  </dt>
<dd><ul>
<li>Document the nested value_type.</li>
<li>Document the provided models, but that should be done in each concept.</li>
<li>The fact that <code>common_t&lt;<a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;int&gt;, <a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;long&gt;&gt;</code> is <code>CanonicalConstant&lt;long&gt;</code> is unsatisfactory. We use a super ugly hack right now to avoid it; get rid of it.</li>
<li>Are the conversions required to be embeddings? It seems like this should always be the case?</li>
<li>Right now, the provided conversion to non-constants T is marked as an embedding whenever conversion from the underlying type to T is an embedding, regardless of the fact that we actually lose the <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a>'s structure. This is a real bummer, but without this expressions like <code>plus(int_&lt;1&gt;, 1)</code> would fail. What should be done? In the same vein, we currently provide a common type with non-constants for which our underlying type has a common type. Does this respect the requirements of a common type? Add tests for that in the <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> automatic tests once this is settled. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000002"></a>Class <a class="el" href="structboost_1_1hana_1_1constant__detail_1_1which.html">boost::hana::constant_detail::which&lt; A, B, C &gt;</a>  </dt>
<dd>This is an awful hack to avoid having <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;common&lt;IntegralConstant&lt;int&gt;, IntegralConstant&lt;long&gt;&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    ==</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;CanonicalConstant&lt;long&gt;</div>
</div><!-- fragment -->  </dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="group__group-details.html#ga5d30ed36591b4062f54ab0c87ad8d7f0">boost::hana::detail::reverse_partial</a>  </dt>
<dd>Perhaps find a better name and make this part of Functional.  </dd>
<dt><a class="anchor" id="_todo000010"></a>Class <a class="el" href="structboost_1_1hana_1_1IntegralConstant.html">boost::hana::IntegralConstant&lt; T &gt;</a>  </dt>
<dd><p class="startdd"><code>times</code> should be a shortcut to some tag-dispatched method. Specifically, anything that can be incremented, decremented and compared to some "zero" value can implement a <code>times</code> method with the same semantics.</p>
<p class="enddd">Implicit conversions to the underlying integral type can be problematic: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;constexpr auto odd = [](auto x) {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    return x % int_&lt;2&gt;;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;};</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;if_(odd(int_&lt;1&gt;), something_of_type_A, something_of_type_B)</div>
</div><!-- fragment --><p> This will fail because <code>odd(int_&lt;1&gt;)</code> has type <code>Int&lt;1 % 2&gt;</code>, which is convertible to <code>bool</code> but not to <code>Bool&lt;...&gt;</code>. Because of this, the runtime <code>if_</code> is used and compilation fails.  </p>
</dd>
<dt><a class="anchor" id="_todo000013"></a>Class <a class="el" href="structboost_1_1hana_1_1Iterable.html">boost::hana::Iterable</a>  </dt>
<dd><p class="startdd">There's a problem; <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> is more general than <a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a>, but there are some infinite Iterables that can't be folded properly. So both concepts actually just overlap and there is no superclass relation?</p>
<ul>
<li>Add perfect forwarding in the methods.</li>
<li>Use perfect forwarding in <code>Iterable::find_impl</code> once Clang bug #20619 is fixed.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">boost::hana::lockstep</a>  </dt>
<dd>I think this is equivalent to <code>&lt;*&gt;</code> for <code>((-&gt;) r)</code>.  </dd>
<dt><a class="anchor" id="_todo000016"></a>Class <a class="el" href="structboost_1_1hana_1_1Logical.html">boost::hana::Logical</a>  </dt>
<dd></dd>
<dt><a class="anchor" id="_todo000017"></a>Class <a class="el" href="structboost_1_1hana_1_1Map.html">boost::hana::Map</a>  </dt>
<dd>We should allow duplicate keys, with a documented policy (e.g. we keep the last one). </dd>
<dt><a class="anchor" id="_todo000018"></a>Class <a class="el" href="structboost_1_1hana_1_1Orderable.html">boost::hana::Orderable</a>  </dt>
<dd><p class="startdd">Consider allowing another minimal complete definition using <code>less_equal</code>.</p>
<p class="enddd">Make sure no circularity issue with our provided operators can arise when checking for the LessThanComparable concept. </p>
</dd>
<dt><a class="anchor" id="_todo000023"></a>Class <a class="el" href="structboost_1_1hana_1_1Record.html">boost::hana::Record</a>  </dt>
<dd>The restrictions on what constitutes an accessor are pretty fierce, and using <code>std::move</code> on the same object twice feels completely wrong. Is there a better way to allow an object to be decomposed optimally into its subobjects without resorting to such hacks? </dd>
<dt><a class="anchor" id="_todo000024"></a>Class <a class="el" href="structboost_1_1hana_1_1Searchable.html">boost::hana::Searchable</a>  </dt>
<dd>We should provide a member <code>operator[]</code> equivalent to <code>find</code>.  </dd>
<dt><a class="anchor" id="_todo000026"></a>Class <a class="el" href="structboost_1_1hana_1_1Sequence.html">boost::hana::Sequence</a>  </dt>
<dd><p class="startdd"></p>
<p>Implement these methods: <code>intercalate</code>, <code>transpose</code>, <code>subsequences</code>, <code>split_at</code>, <code>break</code>, <code>inits</code>, <code>tails</code>, <code>iterate</code></p>
<p class="enddd">Document the <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> -&gt; <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> conversion, and also the <code>make</code> function.  </p>
</dd>
<dt><a class="anchor" id="_todo000035"></a>Class <a class="el" href="structboost_1_1hana_1_1sequence__detail_1_1partition__helper.html">boost::hana::sequence_detail::partition_helper</a>  </dt>
<dd>How could we avoid copying <code>parts</code> and <code>x</code> to both branches?  </dd>
<dt><a class="anchor" id="_todo000031"></a>Class <a class="el" href="structboost_1_1hana_1_1String.html">boost::hana::String</a>  </dt>
<dd>Right now, we use a different template specialization to store each different string. This could also work by using an anonymous type, but there seems to be a bug in Clang right now that makes this fail in some circumstances: <a href="http://llvm.org/bugs/show_bug.cgi?id=20625">http://llvm.org/bugs/show_bug.cgi?id=20625</a>. Using an anonymous type could have compile-time performance benefits, so this avenue should be explored once the bug is fixed.  </dd>
<dt><a class="anchor" id="_todo000032"></a>Class <a class="el" href="structboost_1_1hana_1_1Traversable.html">boost::hana::Traversable</a>  </dt>
<dd>Write the laws for this concept. Can be based on [1]. The problem is that the current data type system is too weak to write complex laws, because we don't even officially have parameterized data types. </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="structboost_1_1hana_1_1Iterable.html#a322ee5c860b93d6bfb5571a028f5e5b2">drop</a>  </dt>
<dd>Provide two variants; <code>drop.at_most</code> and <code>drop.exactly</code>.  </dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="structboost_1_1hana_1_1Foldable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>  </dt>
<dd>The presence of implicit side effects in this function might be a smell that it should be moved to a different concept and handled through <code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code>s. </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="structboost_1_1hana_1_1Set.html#ade2be766c8daa85306a8d9c29bf75dfe">make&lt; Set &gt;</a>  </dt>
<dd>Consider allowing duplicates elements in this constructor. </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="structboost_1_1hana_1_1Orderable.html#a9fb8718f43756efef3953635f34fd67e">max</a>  </dt>
<dd>Can't specify the signature here either. See <code>min</code> for details. </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="structboost_1_1hana_1_1Orderable.html#af10ea2fee24c0a780758f67721bb5bfa">min</a>  </dt>
<dd>We can't specify the signature right now, because the returned data type depends on whether <code>x &lt; y</code> or not. If we wanted to be mathematically correct, we should probably ask that <code>if_(cond, x, y)</code> returns a common data type of <code>x</code> and <code>y</code>, and then the behavior of <code>min</code> would follow naturally. However, I'm unsure whether this is desirable because that's a big requirement. </dd>
<dt><a class="anchor" id="_todo000012"></a>Member <a class="el" href="structboost_1_1hana_1_1IntegralConstant.html#a1c078fd00db48686ca9e0aa17f47344e">operator</a> "_c" </dt>
<dd>Add support for stuff like <code>0x1234_c</code>.  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="structboost_1_1hana_1_1Sequence.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a>  </dt>
<dd>When the size of the sequence is known at compile-time, we can generate the indices <code>constexpr</code> and then simply use <code>at_c</code>. This could vastly improve the compilation time.  </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="structboost_1_1hana_1_1Searchable.html#aa713b34e28603ea39c8873609fd24801">subset</a>  </dt>
<dd>Consider using the data type of both arguments for tag-dispatching.  </dd>
<dt><a class="anchor" id="_todo000038"></a>page <a class="el" href="index.html">User Manual</a>  </dt>
<dd><ul>
<li>Provide links to the scattered examples, and also to example/misc/mini_mpl. For some reason, I can't get Doxygen to generate a link.</li>
<li>Expand this section to explain the philosophy behind Hana's metaprogramming paradigm, i.e. that you only retrieve the types at the end and that you do not try to represent everything as a type.</li>
<li>Write a cheatsheet mapping common MPL/Fusion idioms to idiomatic Hana code. Maybe this should go in some Appendix?</li>
<li>Introduce the mini-MPL</li>
<li>Introduce the integration with <code>&lt;type_traits&gt;</code></li>
</ul>
<p class="enddd">There is obviously a connection between generalized types and concepts. I think that generalized types are concepts whose models are unique up to a unique isomorphism. Still, it is necessary to distinguish between isomorphic models when we want to provide an implementation or create an object. If you see how it all fits together better than I do right now, let me know.</p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
