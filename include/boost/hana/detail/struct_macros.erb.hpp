<%#
    This is an ERB [1] template file used to generate the
    <boost/hana/detail/struct_macros.hpp> header. The maximum
    number of members that can be handled by the macros can
    be controlled with the 'MAX_NUMBER_OF_MEMBERS' variable,
    which can be set when calling ERB to generate the header:

        export MAX_NUMBER_OF_MEMBERS=55; erb struct_macros.erb.hpp

    'MAX_NUMBER_OF_MEMBERS' must be <= 62, otherwise an error is triggered.
    In case 'MAX_NUMBER_OF_MEMBERS' is not specified, it defaults to 40.

    [1]: http://en.wikipedia.org/wiki/ERuby
%>

<%
    MAX_NUMBER_OF_MEMBERS = (ENV["MAX_NUMBER_OF_MEMBERS"] || 40).to_i
    raise "MAX_NUMBER_OF_MEMBERS must be <= 62" if MAX_NUMBER_OF_MEMBERS > 62
%>

/*!
@file
Defines the `BOOST_HANA_DEFINE_STRUCT` and the `BOOST_HANA_ADAPT_STRUCT` macros.

@copyright Louis Dionne 2015
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
 */

//////////////////////////////////////////////////////////////////////////////
// THIS FILE IS GENERATED FROM THE <boost/hana/detail/struct_macros.erb.hpp>
// ERB TEMPLATE. DO NOT EDIT THIS FILE DIRECTLY.
//
// THE ERB TEMPLATE CONTAINS INFORMATION ABOUT HOW TO REGENERATE THIS FILE.
//////////////////////////////////////////////////////////////////////////////

#ifndef BOOST_HANA_DETAIL_STRUCT_MACROS_HPP
#define BOOST_HANA_DETAIL_STRUCT_MACROS_HPP

#include <boost/hana/detail/preprocessor.hpp>

namespace boost { namespace hana { namespace detail {
    template <typename Memptr, Memptr ptr>
    struct member_ptr {
        template <typename T>
        constexpr decltype(auto) operator()(T&& t) const
        { return static_cast<T&&>(t).*ptr; }
    };
}}}

//////////////////////////////////////////////////////////////////////////////
// BOOST_HANA_ADAPT_STRUCT
//////////////////////////////////////////////////////////////////////////////
#define BOOST_HANA_ADAPT_STRUCT(...)                                        \
  BOOST_HANA_ADAPT_STRUCT_IMPL(BOOST_HANA_PP_NARG(__VA_ARGS__), __VA_ARGS__)\
  static_assert(true, "force the usage of a trailing semicolon")            \
/**/

#define BOOST_HANA_ADAPT_STRUCT_IMPL(N, ...) \
  BOOST_HANA_PP_CONCAT(BOOST_HANA_ADAPT_STRUCT_IMPL_, N)(__VA_ARGS__)

#define BOOST_HANA_MEMBER_PAIR_IMPL(TYPE, MEMBER)                           \
  ::boost::hana::make_pair(                                                 \
    BOOST_HANA_STRING(BOOST_HANA_PP_STRINGIZE(MEMBER)),                     \
    ::boost::hana::detail::member_ptr<                                      \
      decltype(&TYPE::MEMBER), &TYPE::MEMBER                                \
    >{}                                                                     \
  )                                                                         \
/**/

<% (0..MAX_NUMBER_OF_MEMBERS).each do |n|
    members = (1..n).to_a.map { |i| "m#{i}" }
    args = ["TYPE"] + members
    member_pairs = members.map { |member|
        "BOOST_HANA_MEMBER_PAIR_IMPL(TYPE, BOOST_HANA_PP_BACK #{member})"
    }
%>
#define BOOST_HANA_ADAPT_STRUCT_IMPL_<%= n+1 %>(<%= args.join(', ') %>)     \
    namespace boost { namespace hana {                                      \
        template <>                                                         \
        struct accessors_impl<TYPE> {                                       \
            static BOOST_HANA_CONSTEXPR_LAMBDA auto apply() {               \
                return ::boost::hana::make_tuple(                           \
                    <%= member_pairs.join(', ') %>                          \
                );                                                          \
            }                                                               \
        };                                                                  \
    }}                                                                      \
/**/
<% end %>

//////////////////////////////////////////////////////////////////////////////
// BOOST_HANA_DEFINE_STRUCT
//////////////////////////////////////////////////////////////////////////////
#define BOOST_HANA_DEFINE_STRUCT(...) \
    BOOST_HANA_DEFINE_STRUCT_IMPL(BOOST_HANA_PP_NARG(__VA_ARGS__), __VA_ARGS__)

#define BOOST_HANA_DEFINE_STRUCT_IMPL(N, ...) \
    BOOST_HANA_PP_CONCAT(BOOST_HANA_DEFINE_STRUCT_IMPL_, N)(__VA_ARGS__)

<% (0..MAX_NUMBER_OF_MEMBERS).each do |n|
    members = (1..n).to_a.map { |i| "m#{i}" }
    args = ["TYPE"] + members
    member_pairs = members.map { |member|
        "BOOST_HANA_MEMBER_PAIR_IMPL(TYPE, BOOST_HANA_PP_BACK #{member})"
    }
    member_decls = members.map { |member|
        "BOOST_HANA_PP_DROP_BACK #{member} BOOST_HANA_PP_BACK #{member};"
    }
%>
#define BOOST_HANA_DEFINE_STRUCT_IMPL_<%= n+1 %>(<%= args.join(', ') %> )   \
  <%= member_decls.join(' ') %>                                             \
  struct hana { struct accessors_impl {                                     \
    static BOOST_HANA_CONSTEXPR_LAMBDA auto apply() {                       \
      return ::boost::hana::make_tuple(                                     \
        <%= member_pairs.join(", ") %>                                      \
      );                                                                    \
    }                                                                       \
  }; }                                                                      \
/**/
<% end %>

#endif // !BOOST_HANA_DETAIL_STRUCT_MACROS_HPP
