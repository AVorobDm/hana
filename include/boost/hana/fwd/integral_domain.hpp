/*!
@file
Forward declares `boost::hana::IntegralDomain`.

@copyright Louis Dionne 2014
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
 */

#ifndef BOOST_HANA_FWD_INTEGRAL_DOMAIN_HPP
#define BOOST_HANA_FWD_INTEGRAL_DOMAIN_HPP

#include <boost/hana/core/datatype.hpp>
#include <boost/hana/core/method.hpp>
#include <boost/hana/detail/std/forward.hpp>


namespace boost { namespace hana {
    //! @ingroup group-typeclasses
    //! `IntegralDomain`s are commutative `Ring`s with only `zero` as a
    //! zero divisor.
    //!
    //! Typical examples of `IntegralDomain` include integers and polynomials
    //! over a field. The method names refer to the integral domain of
    //! integers under addition and multiplication.
    //!
    //!
    //! Superclass
    //! ----------
    //! `Ring`
    //!
    //!
    //! Laws
    //! ----
    //! For all objects `a`, `b` and `k` of an `IntegralDomain` `D`, the
    //! following laws must be satisfied:
    //! @code
    //!     mult(a, b) == mult(b, a)                                  // commutativity
    //!     plus(mult(quot(a, b), b), mod(a, b)) == a if b is non-zero
    //!     mod(plus(a, mult(k, b)), b) == mod(a, b)  if b is non-zero // canonicity
    //!     mod(zero<D>(), b) == zero<D>()            if b is non-zero
    //! @endcode
    //!
    //!
    //! Minimal complete definitions
    //! ----------------------------
    //! 1. `mod` and `quot`
    //! @todo
    //!
    //! 2. `operator%` and `operator/`
    //! Any data type whose objects can be divided and moded with the usual
    //! operators (`/` and `%`) naturally form an integral domain with those
    //! operations.
    struct IntegralDomain { };

    //! Generalized integer remainder.
    //! @relates IntegralDomain
    //!
    //! Specifically, `mod(x, y)` picks a canonical element of the equivalence
    //! class of `x` in the ideal generated by `y`.
    //!
    //! ### Example
    //! @snippet example/integral_domain.cpp mod
#ifdef BOOST_HANA_DOXYGEN_INVOKED
    constexpr auto mod = [](auto&& x, auto&& y) -> decltype(auto) {
        return tag-dispatched;
    };
#else
    BOOST_HANA_BINARY_METHOD(mod_impl);

    struct _mod {
        template <typename X, typename Y>
        constexpr decltype(auto) operator()(X&& x, Y&& y) const {
            return dispatch<mod_impl<
                typename datatype<X>::type, typename datatype<Y>::type
            >>::apply(
                detail::std::forward<X>(x),
                detail::std::forward<Y>(y)
            );
        }
    };

    constexpr _mod mod{};
#endif

    //! Generalized integer quotient.
    //! @relates IntegralDomain
    //!
    //! ### Example
    //! @snippet example/integral_domain.cpp quot
#ifdef BOOST_HANA_DOXYGEN_INVOKED
    constexpr auto quot = [](auto&& x, auto&& y) -> decltype(auto) {
        return tag-dispatched;
    };
#else
    BOOST_HANA_BINARY_METHOD(quot_impl);

    struct _quot {
        template <typename X, typename Y>
        constexpr decltype(auto) operator()(X&& x, Y&& y) const {
            return dispatch<quot_impl<
                typename datatype<X>::type, typename datatype<Y>::type
            >>::apply(
                detail::std::forward<X>(x),
                detail::std::forward<Y>(y)
            );
        }
    };

    constexpr _quot quot{};
#endif
}} // end namespace boost::hana

#endif // !BOOST_HANA_FWD_INTEGRAL_DOMAIN_HPP
