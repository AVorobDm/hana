/*!
@file
Forward declares `boost::hana::IntegralDomain`.

@copyright Louis Dionne 2014
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
 */

#ifndef BOOST_HANA_FWD_INTEGRAL_DOMAIN_HPP
#define BOOST_HANA_FWD_INTEGRAL_DOMAIN_HPP

#include <boost/hana/core/datatype.hpp>
#include <boost/hana/core/typeclass.hpp>
#include <boost/hana/detail/std/forward.hpp>


namespace boost { namespace hana {
    //! @ingroup group-typeclasses
    //! `IntegralDomain`s are commutative `Ring`s with only `zero` as a
    //! zero divisor.
    //!
    //! Typical examples of `IntegralDomain` include integers and polynomials
    //! over a field. The method names refer to the integral domain of
    //! integers under addition and multiplication.
    //!
    //! ### Requires
    //! `Ring`
    //!
    //! ### Laws
    //! For all objects `a`, `b` and `k` of an `IntegralDomain` `D`, the
    //! following laws must be satisfied:
    //! @code
    //!     mult(a, b) == mult(b, a)                                  // commutativity
    //!     plus(mult(quot(a, b), b), mod(a, b)) == a if b is non-zero
    //!     mod(plus(a, mult(k, b)), b) == mod(a, b)  if b is non-zero // canonicity
    //!     mod(zero<D>, b) == zero<D>                if b is non-zero
    //! @endcode
    struct IntegralDomain {
        BOOST_HANA_BINARY_TYPECLASS(IntegralDomain);
        struct mcd;
        template <typename I1, typename I2>
        struct integral_constant_mcd;
    };

    //! Generalized integer remainder.
    //! @relates IntegralDomain
    //!
    //! Specifically, `mod(x, y)` picks a canonical element of the equivalence
    //! class of `x` in the ideal generated by `y`.
    //!
    //! ### Example
    //! @snippet example/integral_domain.cpp mod
#ifdef BOOST_HANA_DOXYGEN_INVOKED
    constexpr auto mod = [](auto&& x, auto&& y) -> decltype(auto) {
        return tag-dispatched;
    };
#else
    struct _mod {
        template <typename X, typename Y>
        constexpr decltype(auto) operator()(X&& x, Y&& y) const {
            return IntegralDomain::instance<
                datatype_t<X>, datatype_t<Y>
            >::mod_impl(
                detail::std::forward<X>(x),
                detail::std::forward<Y>(y)
            );
        }
    };

    constexpr _mod mod{};
#endif

    //! Generalized integer quotient.
    //! @relates IntegralDomain
    //!
    //! ### Example
    //! @snippet example/integral_domain.cpp quot
#ifdef BOOST_HANA_DOXYGEN_INVOKED
    constexpr auto quot = [](auto&& x, auto&& y) -> decltype(auto) {
        return tag-dispatched;
    };
#else
    struct _quot {
        template <typename X, typename Y>
        constexpr decltype(auto) operator()(X&& x, Y&& y) const {
            return IntegralDomain::instance<
                datatype_t<X>, datatype_t<Y>
            >::quot_impl(
                detail::std::forward<X>(x),
                detail::std::forward<Y>(y)
            );
        }
    };

    constexpr _quot quot{};
#endif
}} // end namespace boost::hana

#endif // !BOOST_HANA_FWD_INTEGRAL_DOMAIN_HPP
