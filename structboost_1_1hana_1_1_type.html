<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Type Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_type.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Type Struct Reference<div class="ingroups"><a class="el" href="group__group-datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Represents a C++ type. </p>
<dl class="section note"><dt>Note</dt><dd>This page explains how Types work at a low level. To gain intuition about type-level metaprogramming in Hana, you should read the <a class="el" href="index.html#tutorial-type">tutorial section</a> on type-level computations.</dd></dl>
<p>A <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code> is a special kind of object representing a C++ type like <code>int</code>, <code>void</code>, <code>std::vector&lt;float&gt;</code> or anything else you can imagine. Basically, the trick to implement such an object is to create the following dummy type: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>_type { };</div>
</div><!-- fragment --><p>Now, if we want to represent the type <code>int</code> by an object, we just create the following object </p><div class="fragment"><div class="line">_type&lt;int&gt; foo;</div>
</div><!-- fragment --><p> and pretend that <code>foo</code> represents the type <code>int</code>. Note that since <code>_type&lt;int&gt;</code> can only be default constructed and hence has only one value, we could even not bother giving this object a name and we could simply use the <code>_type&lt;int&gt;{}</code> expression. The point here is that there is nothing special about the <code>foo</code> variable; it is just an alias for <code>_type&lt;int&gt;{}</code>.</p>
<blockquote class="doxtable">
<p><b>Note</b> This is not exactly how <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>s are implemented in Hana because of some subtleties; things were dumbed down here for the sake of clarity. Please check below to know exactly what you can expect from a <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>. </p>
</blockquote>
<p>Now, let's say we wanted to transform our type <code>int</code> (represented by <code>foo</code>) into a type <code>int*</code> (represented by some other variable); how could we do that? More generally, how could we transform a type <code>T</code> into a type <code>T*</code>? Let's write a function! </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">_type&lt;T*&gt; add_pointer(_type&lt;T&gt; foo) {</div>
<div class="line">    _type&lt;T*&gt; bar;</div>
<div class="line">    <span class="keywordflow">return</span> bar;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We just let the compiler deduce the <code>T</code>, and from that we are able to generate the proper return type. That's it for the signature. For the implementation, we provide the simplest one that will make the code compile; we create a dummy object of the proper type and we return it. We can now use our function like: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> bar = add_pointer(foo);</div>
<div class="line"><span class="keyword">auto</span> baz = add_pointer(bar);</div>
</div><!-- fragment --><p> and we now have objects that represent the types <code>int*</code> and <code>int**</code>, respectively.</p>
<p>As a side note, since we're lazy and we want to save as many keystrokes as possible, we'll use a variable template (new in C++14) to create our dummy variables: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">_type&lt;T&gt; <a class="code" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0">type</a>;</div>
</div><!-- fragment --><p> Instead of typing <code>foo</code> or <code>_type&lt;int&gt;{}</code>, we can now simply write <code>type&lt;int&gt;</code>, which is effectively the same but looks better.</p>
<p>However, the current definition of <code>_type</code> does not make it very useful. Indeed, we are only able to copy those objects around and perform pattern matching in template functions, which is still a bit limited. To make them more widely useful, we add the requirement that a <code>_type&lt;T&gt;</code> provides a nested alias to the type it wraps. In Boost.MPL parlance, we make <code>_type&lt;T&gt;</code> a nullary metafunction: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>_type {</div>
<div class="line">    <span class="keyword">using</span> type = T;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now, we can get the type represented by one of our objects without having to perform pattern matching inside a template function: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> bar = type&lt;int*&gt;;</div>
<div class="line"><span class="keyword">using</span> Bar = decltype(bar)::type;</div>
<div class="line">static_assert(std::is_same&lt;int*, Bar&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>Also, this makes any function returning a <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code> easily usable as a classic metafunction, by simply using decltype. For example, let's consider the following function, which finds the largest type in a sequence of types:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Types&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> largest(Types ...types) {</div>
<div class="line">    <span class="keywordflow">return</span> maximum_by(less ^<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>^ <a class="code" href="structboost_1_1hana_1_1_type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>, make&lt;Tuple&gt;(types...));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> size&gt;</div>
<div class="line"><span class="keyword">struct </span>storage { <span class="keywordtype">char</span> s[size]; };</div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    largest(type&lt;storage&lt;1&gt;&gt;, type&lt;storage&lt;2&gt;&gt;, type&lt;storage&lt;3&gt;&gt;) == type&lt;storage&lt;3&gt;&gt;</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To make it a classic metafunction instead, we only need to modify it slightly using <code>decltype</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Note: tuple_t&lt;T...&gt; is equivalent to make&lt;Tuple&gt;(type&lt;T&gt;...)</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keyword">struct </span>largest</div>
<div class="line">    : decltype(maximum_by(less ^on^ sizeof_, tuple_t&lt;T...&gt;))</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> size&gt;</div>
<div class="line"><span class="keyword">struct </span>storage { <span class="keywordtype">char</span> s[size]; };</div>
<div class="line"></div>
<div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    largest&lt;storage&lt;1&gt;, storage&lt;2&gt;, storage&lt;3&gt;&gt;::type,</div>
<div class="line">    storage&lt;3&gt;</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> While this new paradigm for type level programming might be difficult to grok at first, it will make more sense as you use it more and more. You will also come to appreciate how it blurs the line between types and values, opening new exciting possibilities.</p>
<h2>Lvalues and rvalues </h2>
<p>When storing <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>s in heterogeneous containers, some algorithms will return references to those objects. Since we are primarily interested in accessing their nested <code><a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0" title="Creates an object representing the C++ type T. ">type</a></code>, receiving a reference is undesirable; we would end up trying to fetch the nested <code><a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0" title="Creates an object representing the C++ type T. ">type</a></code> inside a reference type, which is a compilation error: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ts = std::make_tuple(type&lt;int&gt;, type&lt;char&gt;);</div>
<div class="line"><span class="comment">// Error; decltype(...) is a reference!</span></div>
<div class="line"><span class="keyword">using</span> T = decltype(std::get&lt;1&gt;(ts))::type;</div>
</div><!-- fragment --><p>For this reason, <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>s provide an overload of the unary <code>+</code> operator that can be used to turn a lvalue into a rvalue. So when using a result which might be a reference to a <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code> object, one can use <code>+</code> to make sure a rvalue is obtained before fetching its nested <code><a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0" title="Creates an object representing the C++ type T. ">type</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ts = std::make_tuple(type&lt;int&gt;, type&lt;char&gt;);</div>
<div class="line"><span class="comment">// Good; decltype(+...) is an rvalue.</span></div>
<div class="line"><span class="keyword">using</span> T = decltype(+std::get&lt;1&gt;(ts))::type;</div>
</div><!-- fragment --><h2>The actual representation of a <a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a> </h2>
<p>For subtle reasons having to do with ADL, the actual type of the <code>type&lt;T&gt;</code> expression is not <code>_type&lt;T&gt;</code>. It is a dependent type which inherits <code>_type&lt;T&gt;</code>. Hence, you should never rely on the fact that <code>type&lt;T&gt;</code> is of type <code>_type&lt;T&gt;</code>, but you can rely on the fact that it inherits it, which is different in some contexts, e.g. for template specialization.</p>
<h2>Modeled concepts </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> (operators provided)<br />
Two <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>s are equal if and only if they represent the same C++ type. Hence, equality is equivalent to the <code>std::is_same</code> type trait. <div class="fragment"><div class="line"><span class="keyword">struct </span>T;</div>
<div class="line"><span class="keyword">struct </span>U;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(type&lt;T&gt; == type&lt;T&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(type&lt;T&gt; != type&lt;U&gt;);</div>
</div><!-- fragment --></li>
</ol>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd><ul>
<li>Completely figure out and document the category theoretical foundation of this data type.</li>
<li>Consider instantiating <code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> and <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> if that's possible. </li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a4b171ee57f23017113921071f72639d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b171ee57f23017113921071f72639d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr unspecified type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_type.html#a4b171ee57f23017113921071f72639d0">type</a> {}</td></tr>
<tr class="memdesc:a4b171ee57f23017113921071f72639d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object representing the C++ type <code>T</code>.  <a href="#a4b171ee57f23017113921071f72639d0">More...</a><br /></td></tr>
<tr class="separator:a4b171ee57f23017113921071f72639d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68ff2275cbb295556d83598f04e39a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a></td></tr>
<tr class="memdesc:a7d68ff2275cbb295556d83598f04e39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of an object as a <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>.  <a href="#a7d68ff2275cbb295556d83598f04e39a">More...</a><br /></td></tr>
<tr class="separator:a7d68ff2275cbb295556d83598f04e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b702b280ca02f118affaaca9112a8c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a></td></tr>
<tr class="memdesc:a26b702b280ca02f118affaaca9112a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the C++ type represented by a <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>.  <a href="#a26b702b280ca02f118affaaca9112a8c">More...</a><br /></td></tr>
<tr class="separator:a26b702b280ca02f118affaaca9112a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a4b171ee57f23017113921071f72639d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unspecified type type {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object representing the C++ type <code>T</code>. </p>

</div>
</div>
<a class="anchor" id="a7d68ff2275cbb295556d83598f04e39a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto decltype_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> type&lt;decltype(x)&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns the type of an object as a <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X { };</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(type&lt;X&gt; == <a class="code" href="structboost_1_1hana_1_1_type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(X{}));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(type&lt;int&gt; == <a class="code" href="structboost_1_1hana_1_1_type.html#a7d68ff2275cbb295556d83598f04e39a">decltype_</a>(1));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a26b702b280ca02f118affaaca9112a8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sizeof_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](_type&lt;T&gt; <span class="keyword">const</span>&amp;) {</div>
<div class="line">        <span class="keywordflow">return</span> size_t&lt;sizeof(T)&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns the size of the C++ type represented by a <code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X { };</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>(type&lt;X&gt;) == <span class="keyword">sizeof</span>(X), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_type.html#a26b702b280ca02f118affaaca9112a8c">sizeof_</a>(type&lt;int&gt;) == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000042">Todo:</a></b></dt><dd>Should we also support non-<code><a class="el" href="structboost_1_1hana_1_1_type.html" title="Represents a C++ type. ">Type</a></code>s? That could definitely be useful. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_type.html">Type</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
