<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Traversable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/fb54ae3856341ef4bd3acf877ccf24836fc079d9/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/unspecified-type/g, "unspecified-type".link("index.html#tutorial-glossary-unspecified_type").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.5.0/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Traversable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1Traversable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Traversable Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a></code> concept represents types admitting a structure-preserving right fold with an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>. </p>
<p>Intuitively, the <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a> concept provides the minimal requirement for commuting two Applicatives, i.e. for turning a <code>F(G(T))</code> into a <code>G(F(T))</code>, where <code>F</code> and <code>G</code> are two Applicatives. For example, this could allow turning a tree of lists into a list of trees, because the tree is <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a> and the list is (in particular) an <a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a>.</p>
<p>The ability to commute structures is fundamental when trying to compose Monads. For example, suppose that <code>M</code> and <code>N</code> are Monads (thus they are also Applicatives), and that we want to build the composition of <code>M</code> and <code>N</code> given by <code>Z(T) = M(N(T))</code> for any type <code>T</code>. If we want the composition to be a <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>, we will need to implement the <code>flatten</code> method, whose signature is then </p><p class="formulaDsp">
\[ \mathrm{flatten} : Z(Z(T)) \to Z(T) \]
</p>
<p>which is equivalent to </p><p class="formulaDsp">
\[ \mathrm{flatten} : M(N(M(N(T)))) \to M(N(T)) \]
</p>
<p>To be able to implement <code>flatten</code>, one has to be able to commute <code>N</code> and <code>M</code>, and then use the <code>flatten</code> of each <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> <code>M</code> and <code>N</code> to produce a value of the correct type. In other words, we want to do </p><p class="formulaDsp">
\begin{align*} M(N(M(N(T)))) &amp;\to M(M(N(N(T)))) &amp; (\text{commute $M$ and $N$}) \\ &amp;\to M(M(N(T))) &amp; (\text{flatten $N$}) \\ &amp;\to M(N(T)) &amp; (\text{flatten $M$}) \end{align*}
</p>
<p>Hence, the composition of two monads <code>M</code> and <code>N</code> will be a <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> whenever <code>M</code> is <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a>. The ability to commute structures in this way is exactly what the <code>sequence</code> method provides.</p>
<h2>Superclasses </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code></p>
<h2>Minimal complete definition </h2>
<ol type="1">
<li><code>sequence</code><br />
When <code>sequence</code> is defined, <code>traverse</code> can be obtained by setting <div class="fragment"><div class="line">traverse&lt;A&gt;(xs, f) = sequence&lt;A&gt;(transform(xs, f))</div>
</div><!-- fragment --></li>
<li><code>traverse</code><br />
When <code>traverse</code> is defined, <code>sequence</code> can be obtained by setting <div class="fragment"><div class="line">sequence&lt;A&gt;(xs) = traverse&lt;A&gt;(xs, <span class="keywordtype">id</span>)</div>
</div><!-- fragment --></li>
</ol>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1Either.html" title="Represents a value with two possibilities. ">Either</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Maybe.html" title="Represents an optional value. ">Maybe</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code></p>
<h2>Laws </h2>
<p>In the laws below, we use the <code>Identity</code> and <code>Compose</code> functors defined <a href="https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Traversable.html">here</a>. Note that those functors are not provided by Hana and they are only used here for documentation purposes.</p>
<p>Let <code>A</code>, <code>B</code> be arbitrary Applicatives, and let <code>xs</code> be a <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a> of data type <code>T(A(X))</code>. Then, for any <a class="el" href="structboost_1_1hana_1_1Applicative.html#applicative-transformation">applicative-transformation</a> \( f : A(X) \to B(X) \), the following must hold. First, <code>sequence</code> must <em>play well</em> with <code>transform</code>: </p><div class="fragment"><div class="line"><span class="comment">// naturality</span></div>
<div class="line">f(sequence&lt;A&gt;(xs)) == sequence&lt;B&gt;(transform(xs, f))</div>
</div><!-- fragment --><p>Second, using <code>sequence</code> with the Identity functor must not do anything special, which means that <code>sequence</code> can't make up arbitrary effects: </p><div class="fragment"><div class="line"><span class="comment">// identity</span></div>
<div class="line">sequence&lt;Identity&gt;(transform(xs, make&lt;Identity&gt;)) == make&lt;Identity&gt;(xs)</div>
</div><!-- fragment --><p>Finally, for any <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a> <code>xxs</code> of data type <code>T(A(B(X)))</code>, doing two traversals in sequence (commuting from <code>T(A(B(X)))</code> to <code>A(B(T(X)))</code>) must be collapsible into a single traversal: </p><div class="fragment"><div class="line"><span class="comment">// composition</span></div>
<div class="line">sequence&lt;Compose&gt;(transform(xxs, make&lt;Compose&gt;))</div>
<div class="line">    == make&lt;Compose&gt;(transform(sequence&lt;A&gt;(xxs), sequence&lt;B&gt;))</div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:ad2bcf2a65d198953b1690b02f9425419"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ad2bcf2a65d198953b1690b02f9425419"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Traversable.html#ad2bcf2a65d198953b1690b02f9425419">sequence</a></td></tr>
<tr class="memdesc:ad2bcf2a65d198953b1690b02f9425419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the applicatives in a structure from left to right and collect the results.  <a href="#ad2bcf2a65d198953b1690b02f9425419">More...</a><br /></td></tr>
<tr class="separator:ad2bcf2a65d198953b1690b02f9425419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f448955bcfe5b536c94a76b0c007fb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a15f448955bcfe5b536c94a76b0c007fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Traversable.html#a15f448955bcfe5b536c94a76b0c007fb">traverse</a></td></tr>
<tr class="memdesc:a15f448955bcfe5b536c94a76b0c007fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1Map.html" title="A basic associative array requiring unique and Comparable keys. ">Map</a> each element of a structure to an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>, and then do the same as <code>sequence</code>.  <a href="#a15f448955bcfe5b536c94a76b0c007fb">More...</a><br /></td></tr>
<tr class="separator:a15f448955bcfe5b536c94a76b0c007fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="ad2bcf2a65d198953b1690b02f9425419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sequence</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine the applicatives in a structure from left to right and collect the results. </p>
<h2>Signature </h2>
<p>Given an <a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a> <code>A</code>, a <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a> <code>T</code> and an arbitrary data type <code>X</code>, the signature is \( \mathrm{sequence_A} : T(A(X)) \to A(T(X)) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The data type (an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>) of the elements in the structure. We must specify this data type explicitly because the current data type system is not powerful enough to let us peek into the contents of the traversable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure containing the <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>s to combine.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    sequence&lt;Maybe&gt;(make&lt;Tuple&gt;(just(1), just(<span class="charliteral">&#39;2&#39;</span>), just(3.3))) ==</div>
<div class="line">    just(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    sequence&lt;Maybe&gt;(make&lt;Tuple&gt;(just(1), nothing, just(3.3))) == nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is a generalized Cartesian product.</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    sequence&lt;Tuple&gt;(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2, 3),</div>
<div class="line">                                make&lt;Tuple&gt;(4),</div>
<div class="line">                                make&lt;Tuple&gt;(5, 6)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(1, 4, 5), make&lt;Tuple&gt;(1, 4, 6),</div>
<div class="line">        make&lt;Tuple&gt;(2, 4, 5), make&lt;Tuple&gt;(2, 4, 6),</div>
<div class="line">        make&lt;Tuple&gt;(3, 4, 5), make&lt;Tuple&gt;(3, 4, 6)</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15f448955bcfe5b536c94a76b0c007fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto traverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><a class="el" href="structboost_1_1hana_1_1Map.html" title="A basic associative array requiring unique and Comparable keys. ">Map</a> each element of a structure to an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>, and then do the same as <code>sequence</code>. </p>
<h2>Signature </h2>
<p>Given an <a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a> <code>A</code>, a <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure-preserving right fold with an Applicat...">Traversable</a> <code>T</code> and a function \( f : X \to A(Y) \), the signature is \( \mathrm{traverse_A} : T(X) \times (X \to A(Y)) \to A(T(Y)) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The data type (an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>) of an object returned by <code>f</code> when called with an element of the structure. We must specify this data type explicitly because the current data type system is not powerful enough to let us peek into the data type returned by <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be mapped over and then <code>sequence</code>d.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> for each element <code>x</code> of the structure and returning an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> that will then be combined as per <code>sequence</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> half = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> if_(x % int_&lt;2&gt; == int_&lt;0&gt;,</div>
<div class="line">        just(x / int_&lt;2&gt;),</div>
<div class="line">        nothing</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;4&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    just(make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> twice = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> make&lt;Tuple&gt;(x, x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    traverse&lt;Tuple&gt;(just(<span class="charliteral">&#39;x&#39;</span>), twice) == make&lt;Tuple&gt;(just(<span class="charliteral">&#39;x&#39;</span>), just(<span class="charliteral">&#39;x&#39;</span>))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Tuple&gt;(nothing, twice) == make&lt;Tuple&gt;(nothing)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Traversable.html">Traversable</a></li>
  </ul>
</div>
</body>
</html>
