<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Traversable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Traversable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1Traversable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Traversable Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure- preserving right fold with an Applica...">Traversable</a></code> concept represents types admitting a structure- preserving right fold with an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>. </p>
<p>Intuitively, the <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure- preserving right fold with an Applica...">Traversable</a> concept provides the minimal requirement for commuting two Applicatives, i.e. for turning a <code>F&lt;G&lt;T&gt;&gt;</code> into a <code>G&lt;F&lt;T&gt;&gt;</code>, where <code>F</code> and <code>G</code> are two Applicatives. For example, this could allow turning a tree of lists into a list of trees, because the tree is <a class="el" href="structboost_1_1hana_1_1Traversable.html" title="The Traversable concept represents types admitting a structure- preserving right fold with an Applica...">Traversable</a> and the list is (in particular) an <a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a>.</p>
<p>The ability to commute Applicatives is fundamental when trying to compose Monads. For example, suppose that <code>M</code> and <code>N</code> are Monads (thus they are also Applicatives), and that we want to build the composition of <code>M</code> and <code>N</code> given by <code>Z&lt;T&gt; = M&lt;N&lt;T&gt;&gt;</code> for any type <code>T</code>. If we want the composition to be a <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a>, we will need to implement the <code>flatten</code> method, whose pseudo type is </p><div class="fragment"><div class="line">flatten : Z&lt;Z&lt;T&gt;&gt; -&gt; Z&lt;T&gt;</div>
</div><!-- fragment --><p> which is equivalent to </p><div class="fragment"><div class="line">flatten : M&lt;N&lt;M&lt;N&lt;T&gt;&gt;&gt;&gt; -&gt; M&lt;N&lt;T&gt;&gt;</div>
</div><!-- fragment --><p> To be able to implement <code>flatten</code>, one has to be able to commute <code>N</code> and <code>M</code>, and then use the <code>flatten</code> of each <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> <code>M</code> and <code>N</code> to produce a value of the correct type. In other words, we want to do </p><div class="fragment"><div class="line">M&lt;N&lt;M&lt;N&lt;T&gt;&gt;&gt;&gt;   -&gt;   M&lt;M&lt;N&lt;N&lt;T&gt;&gt;&gt;&gt;  (commute M and N)</div>
<div class="line">                -&gt;   M&lt;M&lt;N&lt;T&gt;&gt;&gt;     (flatten N)</div>
<div class="line">                -&gt;   M&lt;N&lt;T&gt;&gt;        (flatten M)</div>
</div><!-- fragment --><p>The ability to commute Applicatives in this way is exactly what the <code>sequence</code> method provides.</p>
<h2>Minimal complete definition </h2>
<ol type="1">
<li><code>sequence</code><br />
When <code>sequence</code> is defined, <code>traverse</code> can be obtained by setting <div class="fragment"><div class="line">traverse&lt;A&gt;(xs, f) = sequence&lt;A&gt;(transform(xs, f))</div>
</div><!-- fragment --></li>
<li><code>traverse</code><br />
When <code>traverse</code> is defined, <code>sequence</code> can be obtained by setting <div class="fragment"><div class="line">sequence&lt;A&gt;(xs) = traverse&lt;A&gt;(xs, <span class="keywordtype">id</span>)</div>
</div><!-- fragment --></li>
</ol>
<h2>Superclass </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code></p>
<h2>Laws </h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>Write the laws for this concept. Can be based on [1]. The problem is that the current data type system is too weak to write complex laws, because we don't even officially have parameterized data types.</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:ad2bcf2a65d198953b1690b02f9425419"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ad2bcf2a65d198953b1690b02f9425419"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Traversable.html#ad2bcf2a65d198953b1690b02f9425419">sequence</a></td></tr>
<tr class="memdesc:ad2bcf2a65d198953b1690b02f9425419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the applicatives in a structure from left to right and collect the results.  <a href="#ad2bcf2a65d198953b1690b02f9425419">More...</a><br /></td></tr>
<tr class="separator:ad2bcf2a65d198953b1690b02f9425419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f448955bcfe5b536c94a76b0c007fb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a15f448955bcfe5b536c94a76b0c007fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Traversable.html#a15f448955bcfe5b536c94a76b0c007fb">traverse</a></td></tr>
<tr class="memdesc:a15f448955bcfe5b536c94a76b0c007fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1Map.html" title="A basic associative array requiring unique and Comparable keys. ">Map</a> each element of a structure to an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>, and then do the same as <code>sequence</code>.  <a href="#a15f448955bcfe5b536c94a76b0c007fb">More...</a><br /></td></tr>
<tr class="separator:a15f448955bcfe5b536c94a76b0c007fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="ad2bcf2a65d198953b1690b02f9425419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sequence</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine the applicatives in a structure from left to right and collect the results. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The data type (an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>) of the elements in the structure. We must specify this data type explicitly because the current data type system is not powerful enough to let us peek into the contents of the traversable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure containing the <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>s to combine.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    sequence&lt;Maybe&gt;(make&lt;Tuple&gt;(just(1), just(<span class="charliteral">&#39;2&#39;</span>), just(3.3))) ==</div>
<div class="line">    just(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    sequence&lt;Maybe&gt;(make&lt;Tuple&gt;(just(1), nothing, just(3.3))) == nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is a generalized Cartesian product.</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    sequence&lt;Tuple&gt;(make&lt;Tuple&gt;(make&lt;Tuple&gt;(1, 2, 3),</div>
<div class="line">                                make&lt;Tuple&gt;(4),</div>
<div class="line">                                make&lt;Tuple&gt;(5, 6)))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        make&lt;Tuple&gt;(1, 4, 5), make&lt;Tuple&gt;(1, 4, 6),</div>
<div class="line">        make&lt;Tuple&gt;(2, 4, 5), make&lt;Tuple&gt;(2, 4, 6),</div>
<div class="line">        make&lt;Tuple&gt;(3, 4, 5), make&lt;Tuple&gt;(3, 4, 6)</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15f448955bcfe5b536c94a76b0c007fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto traverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><a class="el" href="structboost_1_1hana_1_1Map.html" title="A basic associative array requiring unique and Comparable keys. ">Map</a> each element of a structure to an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>, and then do the same as <code>sequence</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The data type (an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code>) of an object returned by <code>f</code> when called with an element of the structure. We must specify this data type explicitly because the current data type system is not powerful enough to let us peek into the data type returned by <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be mapped over and then <code>sequence</code>d.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> for each element <code>x</code> of the structure and returning an <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> that will then be combined as per <code>sequence</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> half = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> if_(x % int_&lt;2&gt; == int_&lt;0&gt;,</div>
<div class="line">        just(x / int_&lt;2&gt;),</div>
<div class="line">        nothing</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;4&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    just(make&lt;Tuple&gt;(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Maybe&gt;(make&lt;Tuple&gt;(int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;6&gt;), half)</div>
<div class="line">    ==</div>
<div class="line">    nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> twice = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> make&lt;Tuple&gt;(x, x);</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    traverse&lt;Tuple&gt;(just(<span class="charliteral">&#39;x&#39;</span>), twice) == make&lt;Tuple&gt;(just(<span class="charliteral">&#39;x&#39;</span>), just(<span class="charliteral">&#39;x&#39;</span>))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    traverse&lt;Tuple&gt;(nothing, twice) == make&lt;Tuple&gt;(nothing)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Traversable.html">Traversable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
