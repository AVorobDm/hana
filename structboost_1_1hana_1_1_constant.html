<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Constant Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_constant.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_constant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Constant Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> concept represents data that can be manipulated at compile-time. </p>
<p>At its core, <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> is simply a generalization of the principle behind <code>std::integral_constant</code> to all types that can be constructed at compile-time, i.e. to all types with a <code>constexpr</code> constructor (also called <a href="http://en.cppreference.com/w/cpp/concept/LiteralType">Literal types</a>). More specifically, a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> is an object from which a <code>constexpr</code> value may be obtained (through the <code>value</code> method) regardless of the <code>constexpr</code>ness of the object itself.</p>
<p>All <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s must be somewhat equivalent, in the following sense. Let <code>C(T)</code> and <code>D(U)</code> denote the data types of <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s holding objects of type <code>T</code> and <code>U</code>, respectively. Then, an object of data type <code>D(U)</code> must be convertible to an object of type <code>C(T)</code> whenever <code>U</code> is convertible to <code>T</code>, has determined by <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">is_convertible</a></code>. The interpretation here is that a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> is just a box holding an object of some type, and it should be possible to swap between boxes whenever the objects inside the boxes can be swapped.</p>
<p>Because of this last requirement, one could be tempted to think that specialized "boxes" like <code>std::integral_constant</code> are prevented from being <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s because they are not able to hold objects of any type <code>T</code> (<code>std::integral_constant</code> may only hold integral types). This is false; the requirement should be interpreted as saying that whenever <code>C(T)</code> is <em>meaningful</em> (e.g. only when <code>T</code> is integral for <code>std::integral_constant</code>) <em>and</em> there exists a conversion from <code>U</code> to <code>T</code>, then a conversion from <code>D(U)</code> to <code>C(T)</code> should also exist. The precise requirements for being a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> are embodied in the following laws.</p>
<h2>Laws </h2>
<p>Let <code>c</code> be an object of a data type <code>C</code>, which represents a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding an object of data type <code>T</code>. The first law ensures that the value of the wrapped object is always a constant expression by requiring the following to be well-formed: </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> x = hana::value&lt;decltype(x)&gt;();</div>
</div><!-- fragment --><p>This means that the <code>value</code> function must return an object that can be constructed at compile-time. It is important to note how <code>value</code> only receives the type of the object and not the object itself. This is the core of the <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> concept; it means that the only information required to implement <code>value</code> must be stored in the <em>type</em> of its argument, and hence be available statically.</p>
<p>The second law that must be satisfied ensures that <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s are basically dumb boxes, which makes it possible to provide models for many concepts without much work from the user. The law simply asks for the following expression to be valid: </p><div class="fragment"><div class="line">to&lt;C&gt;(i)</div>
</div><!-- fragment --><p> where, <code>i</code> is an <em>arbitrary</em> <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding an internal value of a data type which can be converted to <code>T</code>, as determined by the <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">is_convertible</a></code> metafunction. In other words, whenever <code>U</code> is convertible to <code>T</code>, a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding a <code>U</code> is convertible to a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding a <code>T</code>, if such a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> can be created.</p>
<h2>Minimal complete definition </h2>
<p><code>value</code>, satisfying the laws above.</p>
<h2>Provided conversions </h2>
<ol type="1">
<li>To the data type of the underlying value<br />
Any <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>c</code> holding an underlying value of data type <code>T</code> is convertible to any data type <code>U</code> such that <code>T</code> is convertible to <code>U</code>. Specifically, the conversion is equivalent to <div class="fragment"><div class="line">to&lt;U&gt;(c) == to&lt;U&gt;(<a class="code" href="structboost_1_1hana_1_1_constant.html#adea9453327ac4d6834a555ae9887d3f5">value</a>&lt;decltype(c)&gt;())</div>
</div><!-- fragment --></li>
</ol>
<h2>Provided common data type </h2>
<p>Because of the requirement that <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s be interchangeable when their contents are compatible, two <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s <code>A</code> and <code>B</code> will have a common data type whenever <code>A::value_type</code> and <code>B::value_type</code> have one. Their common data type is an unspecified <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>C</code> such that <code>C::value_type</code> is exactly <code>common_t&lt;A::value_type, B::value_type&gt;</code>. A specialization of the <code>common</code> metafunction is provided for <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s to reflect this.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd><ul>
<li>Document the nested value_type.</li>
<li>Document the provided models, but that should be done in each concept.</li>
<li>The fact that <code>common_t&lt;<a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;int&gt;, <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;long&gt;&gt;</code> is <code>CanonicalConstant&lt;long&gt;</code> is unsatisfactory. We use a super ugly hack right now to avoid it; get rid of it.</li>
<li>Are the conversions required to be embeddings? It seems like this should always be the case?</li>
<li>Right now, the provided conversion to non-constants T is marked as an embedding whenever conversion from the underlying type to T is an embedding, regardless of the fact that we actually lose the <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a>'s structure. This is a real bummer, but without this expressions like <code>plus(int_&lt;1&gt;, 1)</code> would fail. What should be done? In the same vein, we currently provide a common type with non-constants for which our underlying type has a common type. Does this respect the requirements of a common type? Add tests for that in the <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> automatic tests once this is settled.</li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:adea9453327ac4d6834a555ae9887d3f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adea9453327ac4d6834a555ae9887d3f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_constant.html#adea9453327ac4d6834a555ae9887d3f5">value</a></td></tr>
<tr class="memdesc:adea9453327ac4d6834a555ae9887d3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the compile-time value associated to a constant.  <a href="#adea9453327ac4d6834a555ae9887d3f5">More...</a><br /></td></tr>
<tr class="separator:adea9453327ac4d6834a555ae9887d3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06a1ad6dece8a0337c3a9e754067051"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_constant.html#ad06a1ad6dece8a0337c3a9e754067051">value_of</a></td></tr>
<tr class="memdesc:ad06a1ad6dece8a0337c3a9e754067051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>value</code>, but can be passed to higher-order algorithms.  <a href="#ad06a1ad6dece8a0337c3a9e754067051">More...</a><br /></td></tr>
<tr class="separator:ad06a1ad6dece8a0337c3a9e754067051"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="adea9453327ac4d6834a555ae9887d3f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the compile-time value associated to a constant. </p>
<p>This function returns the value associated to a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>. That value is always a constant expression. The normal way of using <code>value</code> on an object <code>c</code> is </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> result = hana::value&lt;decltype(c)&gt;();</div>
</div><!-- fragment --><p>However, for convenience, an overload of <code>value</code> is provided so that it can be called as: </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> result = hana::value(c);</div>
</div><!-- fragment --><p>This overload works by taking a <code>const&amp;</code> to its argument, and then forwarding to the first version of <code>value</code>. Since it does not use its argument, the result can still be a constant expression, even if the argument is not a constant expression.</p>
<dl class="section note"><dt>Note</dt><dd><code>value&lt;T&gt;()</code> is tag-dispatched as <code>value_impl&lt;C&gt;::apply&lt;T&gt;()</code>, where <code>C</code> is the data type of <code>T</code>.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">auto</span> i = integral_constant&lt;int, 3&gt;; <span class="comment">// notice no constexpr</span></div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_constant.html#adea9453327ac4d6834a555ae9887d3f5">value</a>&lt;decltype(i)&gt;() == 3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1_constant.html#adea9453327ac4d6834a555ae9887d3f5">value</a>(i) == 3, <span class="stringliteral">&quot;value(i) is always a constant expression!&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad06a1ad6dece8a0337c3a9e754067051"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto value_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; c) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_constant.html#adea9453327ac4d6834a555ae9887d3f5">value</a>(c);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>value</code>, but can be passed to higher-order algorithms. </p>
<p>This function object is equivalent to <code>value</code>, except it can be passed to higher order algorithms because it is a function object. <code>value</code> can't be passed to higher-order algorithms because it is implemented as an overloaded function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a simple alias to <code>value</code>, and hence it is not tag-dispatched and can't be customized.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> xs = tuple_c&lt;int, 1, 2, 3, 4, 5&gt;;</div>
<div class="line">constexpr <span class="keyword">auto</span> vs = transform(xs, <a class="code" href="structboost_1_1hana_1_1_constant.html#ad06a1ad6dece8a0337c3a9e754067051">value_of</a>);</div>
<div class="line">static_assert(vs == make&lt;Tuple&gt;(1, 2, 3, 4, 5), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_constant.html">Constant</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
