<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Constant Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_constant.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_constant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Constant Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> type class represents data that can be manipulated at compile-time. </p>
<p>At its core, <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> is simply a generalization of the principle behind <code>std::integral_constant</code> to all types that can be constructed at compile-time, i.e. to all types with a <code>constexpr</code> constructor (also called <a href="http://en.cppreference.com/w/cpp/concept/LiteralType">Literal</a> types). More specifically, a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> is an object from which a <code>constexpr</code> value may be obtained (through the <code>value</code> method) regardless of the <code>constexpr</code>ness of the object itself. For this to be possible, the type of that object must look somewhat like </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Something {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> the_constexpr_value = ...;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Then, the <code>value</code> method can be implemented as </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(Something) {</div>
<div class="line">    <span class="keywordflow">return</span> Something::the_constexpr_value;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Holding the value as a static constant makes it possible to obtain a <code>constexpr</code> result even when calling <code>value</code> on a non-constexpr object of type <code>Something</code>. If the function had used the <em>value</em> of its argument, it could not have returned a constant expression when its argument is not one. Hence, the function is only allowed to depend on the <em>type</em> of its argument.</p>
<p>Also, all <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s must be somewhat equivalent, in the following sense. Let <code>C&lt;T&gt;</code> and <code>D&lt;U&gt;</code> denote the data types of <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s holding objects of type <code>T</code> and <code>U</code>, respectively. Then, an object of data type <code>D&lt;U&gt;</code> must be convertible to an object of type <code>C&lt;T&gt;</code> whenever <code>U</code> is convertible to <code>T</code>, has determined by <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">is_convertible</a></code>. The interpretation here is that a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> is just a box holding an object of some type, and it should be possible to swap between boxes whenever the objects inside the boxes can be swapped.</p>
<p>Because of this last requirement, one could be tempted to think that specialized "boxes" like <code>std::integral_constant</code> are prevented from being <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s because they are not able to hold objects of any type <code>T</code> (<code>std::integral_constant</code> may only hold integral types). This is false; the requirement should be interpreted as saying that whenever <code>C&lt;T&gt;</code> is <em>meaningful</em> (e.g. only when <code>T</code> is integral for <code>std::integral_constant</code>) <em>and</em> there exists a conversion from <code>U</code> to <code>T</code>, then a conversion from <code>D&lt;U&gt;</code> to <code>C&lt;T&gt;</code> should also exist. The precise requirements for being a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> are embodied in the following laws.</p>
<h2>Laws </h2>
<p>Let <code>c</code> be an object of a data type <code>C</code>, which represents a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> holding an object of data type <code>T</code>. The first law ensures that the value of the wrapped object can always be obtained as a constant expression, by requiring that the following program be well-formed: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keywordtype">void</span> f(X x) {</div>
<div class="line">    constexpr <span class="keyword">auto</span> y = <a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    f(c);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This means that the <code>value</code> function must return an object that can be constructed at compile-time. It is important to note that since </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> y = <a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(x);</div>
</div><!-- fragment --><p>appears in a context where <code>x</code> is <em>not</em> a constant expression (function arguments are never <code>constexpr</code> inside the function's context), this law precisely means that <code>value</code> must be able to return a constant expression even when called with something that isn't one. This requirement is the core of the <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> concept; it means that the only information required to implement <code>value</code> must be stored in the <em>type</em> of its argument, and hence be available statically.</p>
<p>The second law that must be satisfied ensures that <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s are basically dumb boxes, which makes it possible to provide models for many concepts without much work from the user. The law simply asks for the following expression to be valid: </p><div class="fragment"><div class="line">to&lt;C&gt;(i)</div>
</div><!-- fragment --><p> where, <code>i</code> is an <em>arbitrary</em> <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> holding an internal value of a data type which can be converted to <code>T</code>, as determined by the <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">is_convertible</a></code> metafunction. In other words, whenever <code>U</code> is convertible to <code>T</code>, a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> holding a <code>U</code> is convertible to a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> holding a <code>T</code>, if such a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> can be created.</p>
<h2>Minimal complete definition </h2>
<p><code>value</code>, satisfying the laws above.</p>
<h2>Provided conversions </h2>
<ol type="1">
<li>To the data type of the underlying value<br />
Any <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> <code>c</code> holding an underlying value of data type <code>T</code> is convertible to any data type <code>U</code> such that <code>T</code> is convertible to <code>U</code>. Specifically, the conversion is equivalent to <div class="fragment"><div class="line">to&lt;U&gt;(c) == to&lt;U&gt;(<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(c))</div>
</div><!-- fragment --></li>
</ol>
<h2>Provided common data type </h2>
<p>Because of the requirement that <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s be interchangeable when their contents are compatible, two <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s <code>A</code> and <code>B</code> will have a common data type whenever <code>A::value_type</code> and <code>B::value_type</code> have one. Their common data type is an unspecified <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> <code>C</code> such that <code>C::value_type</code> is exactly <code>common_t&lt;A::value_type, B::value_type&gt;</code>. A specialization of the <code>common</code> metafunction is provided for <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code>s to embody this.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd><ul>
<li>Replace value by an equivalent version that works with types only.</li>
<li>Document the nested value_type.</li>
<li>Document the provided models, but that should be done in each concept.</li>
<li>The fact that <code>common_t&lt;<a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;int&gt;, <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>&lt;long&gt;&gt;</code> is <code>CanonicalConstant&lt;long&gt;</code> is unsatisfactory. We use a super ugly hack right now to avoid it; get rid of it.</li>
<li>Are the conversions required to be embeddings? It seems like this should always be the case?</li>
<li>Right now, the provided conversion to non-constants T is marked as an embedding whenever conversion from the underlying type to T is an embedding, regardless of the fact that we actually lose the <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a>'s structure. This is a real bummer, but without this expressions like <code>plus(int_&lt;1&gt;, 1)</code> would fail. What should be done? In the same vein, we currently provide a common type with non-constants for which our underlying type has a common type. Does this respect the requirements of a common type? Add tests for that in the <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> automatic tests once this is settled.</li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a615a7728e2278acb2cab50854079d7fc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a></td></tr>
<tr class="memdesc:a615a7728e2278acb2cab50854079d7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the compile-time value associated to a constant.  <a href="#a615a7728e2278acb2cab50854079d7fc">More...</a><br /></td></tr>
<tr class="separator:a615a7728e2278acb2cab50854079d7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a615a7728e2278acb2cab50854079d7fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; constant) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the compile-time value associated to a constant. </p>
<p>This function returns a value which is always a constant expression, and this function can always be called inside a constant expression. This imposes some rather heavy restrictions on the implementation; specifically, it means that the implementation is fully determined by the type of its argument, and that it does not use the value of its argument at all.</p>
<h2>Example </h2>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> i = integral_constant&lt;int, 3&gt;; <span class="comment">// notice no constexpr</span></div>
<div class="line">    static_assert(<a class="code" href="structboost_1_1hana_1_1_constant.html#a615a7728e2278acb2cab50854079d7fc">value</a>(i) == 3, <span class="stringliteral">&quot;value(i) is always a constant expression!&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_constant.html">Constant</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
