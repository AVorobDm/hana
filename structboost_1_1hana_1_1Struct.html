<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: boost::hana::Struct Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/9029554299b379bd015d102ecdcc5ff455469b6b/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/implementation-defined/g, "implementation-defined".link("index.html#tutorial-glossary-implementation_defined").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.6.2/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Struct.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1Struct-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Struct Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept represents <code>struct</code>-like user-defined types. </p>
<p>The <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept allows restricted compile-time reflection over user-defined types. In particular, it allows accessing the names of the members of a user-defined type, and also the value of those members. <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>s can also be folded, searched and converted to some types of containers, where more advanced transformations can be performed.</p>
<p>While all types can <em>in theory</em> be made <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>s, only a subset of them are actually interesting to see as such. More precisely, it is only interesting to make a type a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> when it is conceptually a C++ <code>struct</code>, i.e. a mostly dumb aggregate of named data. The way this data is accessed is mostly unimportant to the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept; it could be through getters and setters, through public members, through non-member functions or it could even be generated on-the-fly. The important part, which is made precise below, is that those accessor methods should be move-independent.</p>
<p>Another way to see a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> is as a map where the keys are the names of the members and the values are the values of those members. However, there are subtle differences like the fact that one can't add a member to a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>, and also that the order of the members inside a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> plays a role in determining the equality of <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>s, which is not the case for maps.</p>
<h2>Minimal complete definition </h2>
<p><code>accessors</code></p>
<p>A model of <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> is created by specifying a sequence of key/value pairs with the <code>accessors</code> function. The first element of a pair in this sequence represents the "name" of a member of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>, while the second element is a function which retrieves this member from an object. The "names" do not have to be in any special form; they just have to be compile-time <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>. For example, it is common to provide "names" that are <code><a class="el" href="structboost_1_1hana_1_1string.html" title="Compile-time string. ">hana::string</a></code>s representing the actual names of the members, but one could provide <code><a class="el" href="structboost_1_1hana_1_1integral__constant.html" title="Compile-time value of an integral type. ">hana::integral_constant</a></code>s just as well. The values must be functions which, when given an object, retrieve the appropriate member from it. It is not important that the functions actually retrieve a member (e.g. <code>x.member</code>); what is important is that they are move-independent, a notion which is defined below.</p>
<p>There are several ways of providing the <code>accessors</code> method, some of which are more flexible and others which are more convenient. First, one can define it through tag-dispatching, as usual. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The keys can be anything as long as they are compile-time comparable.</span></div>
<div class="line">constexpr <span class="keyword">auto</span> name = hana::integral_c&lt;std::string Person::*, &amp;Person::name&gt;;</div>
<div class="line">constexpr <span class="keyword">auto</span> age = hana::string_c&lt;&#39;a&#39;, &#39;g&#39;, &#39;e&#39;&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceboost.html">boost</a> { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>accessors_impl&lt;Person&gt; {</div>
<div class="line">        <span class="keyword">static</span> BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>() {</div>
<div class="line">            <span class="keywordflow">return</span> make_tuple(</div>
<div class="line">                make_pair(name, [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(std::forward&lt;decltype(p)&gt;(p).name);</div>
<div class="line">                }),</div>
<div class="line">                make_pair(age, [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(std::forward&lt;decltype(p)&gt;(p).age);</div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}}</div>
</div><!-- fragment --><p> Secondly, it is possible to provide a nested <code>hana::accessors_impl</code> type, which should be equivalent to a specialization of <code>accessors_impl</code> for tag-dispatching. However, for a type <code>S</code>, this technique only works when the data type of <code>S</code> is <code>S</code> itself, which is the case unless you explicitly asked for something else. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">struct </span>hana { <span class="keyword">struct </span>accessors_impl {</div>
<div class="line">        <span class="keyword">static</span> BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>() {</div>
<div class="line">            <span class="keywordflow">return</span> boost::hana::make_tuple(</div>
<div class="line">                boost::hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>),</div>
<div class="line">                [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">boost::hana::id</a>(std::forward&lt;decltype(p)&gt;(p).name);</div>
<div class="line">                }),</div>
<div class="line">                boost::hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>),</div>
<div class="line">                [](<span class="keyword">auto</span>&amp;&amp; p) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                    <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">boost::hana::id</a>(std::forward&lt;decltype(p)&gt;(p).age);</div>
<div class="line">                })</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };};</div>
<div class="line">};</div>
</div><!-- fragment --><p> Finally, the most convenient (but least flexible) option is to use the <code>BOOST_HANA_DEFINE_STRUCT</code> or the <code>BOOST_HANA_ADAPT_STRUCT</code> macro to provide a model of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept with minimal syntactic overhead. See the documentation of these macros for details on how to use them.</p>
<p><a class="anchor" id="move-independence"></a></p><h2>Move-independence </h2>
<p>The notion of move-independence presented here defines rigorously when it is legitimate to "double-move" from an object.</p>
<p>A collection of functions <code>f1, ..., fn</code> sharing the same domain is said to be <em>move-independent</em> if for every fresh (not moved-from) object <code>x</code> in the domain, any permutation of the following statements is valid and leaves the <code>zk</code> objects in a fresh (not moved-from) state: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> z1 = f1(std::move(x));</div>
<div class="line">...</div>
<div class="line">auto zn = fn(std::move(x));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In the special case where some functions return objects that can't be bound to with <code>auto zk =</code> (like <code>void</code> or a non-movable, non-copyable type), just pretend the return value is ignored.</dd></dl>
<p>Intuitively, this ensures that we can treat <code>f1, ..., fn</code> as "accessors" that decompose <code>x</code> into independent subobjects, and that do so without moving from <code>x</code> more than that subobject. This is important because it allows us to optimally decompose <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>s into their subparts inside the library.</p>
<h2>Laws </h2>
<p>For any <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> <code>S</code>, the accessors in the <code>accessors&lt;S&gt;()</code> sequence must be move-independent, as defined above.</p>
<h2>Refined concepts </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> (free model)<br />
<code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>s are required to be <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>. Specifically, two <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>s of the same data type <code>S</code> must be equal if and only if all of their members are equal. By default, a model of <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> doing just that is provided for models of <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>. In particular, note that the comparison of the members is made in the same order as they appear in the <code>hana::members</code> sequence. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="keys_8hpp.html">boost/hana/keys.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30}, kevin{<span class="stringliteral">&quot;Kevin&quot;</span>, 20};</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::equal(john, john));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::not_equal(john, kevin));</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> (free model)<br />
A <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> can be folded by considering it as a list of pairs each containing the name of a member and the value associated to that member, in the same order as they appear in the <code>hana::members</code> sequence. By default, a model of <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> doing just that is provided for models of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold__left_8hpp.html">boost/hana/fold_left.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="second_8hpp.html">boost/hana/second.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Classroom {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Classroom,</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, boys),</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, girls)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr Classroom compsci{20, 3};</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::fold_left(compsci, 0, [](<span class="keyword">auto</span> total, <span class="keyword">auto</span> member) {</div>
<div class="line">            <span class="comment">// first(member) is the name of the member, here</span></div>
<div class="line">            <span class="comment">// &quot;boys&quot; or &quot;girls&quot;, and second(member) is its value.</span></div>
<div class="line">            <span class="keywordflow">return</span> hana::second(member) + total;</div>
<div class="line">        }) == 23</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<p>Being a model of <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> makes it possible to turn a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> into basically any <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>, but also into a <code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique and Comparable keys. ">hana::map</a></code> by simply using the <code>to&lt;...&gt;</code> function! </p><div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2convert_8hpp.html">boost/hana/core/convert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30u};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::to&lt;hana::Map&gt;(john) == hana::make_map(</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>), <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>), 30u)</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> (free model)<br />
A <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> can be searched by considering it as a map where the keys are the names of the members of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>, and the values are the members associated to those names. By default, a model of <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> is provided for any model of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find_8hpp.html">boost/hana/find.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30};</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>)) == hana::just(<span class="stringliteral">&quot;John&quot;</span>)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;foobar&quot;</span>)) == hana::nothing</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ol>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:a5706310d661d5d88e708d684e4ea0739"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a5706310d661d5d88e708d684e4ea0739"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Struct.html#a5706310d661d5d88e708d684e4ea0739">accessors</a></td></tr>
<tr class="memdesc:a5706310d661d5d88e708d684e4ea0739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> of pairs representing the accessors of the data structure.  <a href="#a5706310d661d5d88e708d684e4ea0739">More...</a><br /></td></tr>
<tr class="separator:a5706310d661d5d88e708d684e4ea0739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f32260f859b2510dd16235b7bc011ac"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Struct.html#a0f32260f859b2510dd16235b7bc011ac">keys</a></td></tr>
<tr class="memdesc:a0f32260f859b2510dd16235b7bc011ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> containing the name of the members of the data structure.  <a href="#a0f32260f859b2510dd16235b7bc011ac">More...</a><br /></td></tr>
<tr class="separator:a0f32260f859b2510dd16235b7bc011ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daffa262501273590ec3164122eb92e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Struct.html#a5daffa262501273590ec3164122eb92e">members</a></td></tr>
<tr class="memdesc:a5daffa262501273590ec3164122eb92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> containing the members of a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>.  <a href="#a5daffa262501273590ec3164122eb92e">More...</a><br /></td></tr>
<tr class="separator:a5daffa262501273590ec3164122eb92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41037f470ac6ca2f7135802592ef5977"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Struct.html#a41037f470ac6ca2f7135802592ef5977">BOOST_HANA_ADAPT_STRUCT</a>(...)                                                                                                                                                    </td></tr>
<tr class="memdesc:a41037f470ac6ca2f7135802592ef5977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a model of <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> with the given members.  <a href="#a41037f470ac6ca2f7135802592ef5977">More...</a><br /></td></tr>
<tr class="separator:a41037f470ac6ca2f7135802592ef5977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733de713ae2407331983c60186b215ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(...)&#160;&#160;&#160;BOOST_HANA_DEFINE_STRUCT_IMPL(<a class="el" href="group__group-details.html#ga62fe3327023c37706c827cc82624998b">BOOST_HANA_PP_NARG</a>(__VA_ARGS__), __VA_ARGS__)</td></tr>
<tr class="memdesc:a733de713ae2407331983c60186b215ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines members of a structure, while at the same time modeling <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>.  <a href="#a733de713ae2407331983c60186b215ca">More...</a><br /></td></tr>
<tr class="separator:a733de713ae2407331983c60186b215ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="a5706310d661d5d88e708d684e4ea0739"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto accessors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> of pairs representing the accessors of the data structure. </p>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> <code>S</code>, <code>accessors&lt;S&gt;()</code> is a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> of <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>s where the first element of each pair is the "name" of a member of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>, and the second element of each pair is a function that can be used to access that member when given an object of the proper data type. As described in the global documentation for <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>, the accessor functions in this sequence must be move-independent.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="accessors_8hpp.html">boost/hana/accessors.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="first_8hpp.html">boost/hana/first.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="second_8hpp.html">boost/hana/second.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keyword">auto</span> <a class="code" href="structboost_1_1hana_1_1Struct.html#a5706310d661d5d88e708d684e4ea0739">accessors</a> = hana::accessors&lt;Person&gt;();</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::first(accessors[hana::size_c&lt;0&gt;]) == BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::first(accessors[hana::size_c&lt;1&gt;]) == BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    constexpr <span class="keyword">auto</span> get_name = hana::second(accessors[hana::size_c&lt;0&gt;]);</div>
<div class="line">    constexpr <span class="keyword">auto</span> get_age = hana::second(accessors[hana::size_c&lt;1&gt;]);</div>
<div class="line"></div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(get_name(john) == <span class="stringliteral">&quot;John&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(get_age(john) == 30);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0f32260f859b2510dd16235b7bc011ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto keys</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; object) {</div>
<div class="line">        <span class="keywordflow">return</span> implementation-defined;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> containing the name of the members of the data structure. </p>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> object, <code>keys</code> returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> containing the name of all the members of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>, in the same order as they appear in the <code>accessors</code> sequence.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="keys_8hpp.html">boost/hana/keys.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::keys(john) == hana::make_tuple(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>),</div>
<div class="line">                                             BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>))</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5daffa262501273590ec3164122eb92e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto members</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; object) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> containing the members of a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>. </p>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> object, <code>members</code> returns a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> containing all the members of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>, in the same order as their respective accessor appears in the <code>accessors</code> sequence.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="members_8hpp.html">boost/hana/members.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::members(john) == hana::make_tuple(<span class="stringliteral">&quot;John&quot;</span>, 30));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a41037f470ac6ca2f7135802592ef5977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_ADAPT_STRUCT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;                                                               \</div>
<div class="line">  struct BOOST_HANA_ADAPT_STRUCT_must_be_called_in_the_global_namespace&lt;&gt;;  \</div>
<div class="line">  BOOST_HANA_ADAPT_STRUCT_IMPL(<a class="code" href="group__group-details.html#ga62fe3327023c37706c827cc82624998b">BOOST_HANA_PP_NARG</a>(__VA_ARGS__), __VA_ARGS__)\</div>
<div class="line">  static_assert(<span class="keyword">true</span>, <span class="stringliteral">&quot;force the usage of a trailing semicolon&quot;</span>)            \</div>
</div><!-- fragment -->
<p>Defines a model of <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> with the given members. </p>
<p>Using this macro at <em>global scope</em> will define a model of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept for the given type. This can be used to easily adapt existing user-defined types in a ad-hoc manner. Unlike the <code>BOOST_HANA_DEFINE_STRUCT</code> macro, this macro does not require the types of the members to be specified.</p>
<dl class="section note"><dt>Note</dt><dd>This macro only works if the tag of the user-defined type <code>T</code> is <code>T</code> itself. This is the case unless you specifically asked for something different; see <code>datatype</code>'s documentation.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="accessors_8hpp.html">boost/hana/accessors.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="adapt__struct_8hpp.html">boost/hana/adapt_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2convert_8hpp.html">boost/hana/core/convert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find_8hpp.html">boost/hana/find.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="first_8hpp.html">boost/hana/first.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>ns {</div>
<div class="line">    <span class="keyword">struct </span>Person {</div>
<div class="line">        std::string name;</div>
<div class="line">        <span class="keywordtype">int</span> age;</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Struct.html#a41037f470ac6ca2f7135802592ef5977">BOOST_HANA_ADAPT_STRUCT</a>(ns::Person,</div>
<div class="line">    name,</div>
<div class="line">    age</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// The member names are hana::strings:</span></div>
<div class="line"><span class="keyword">auto</span> names = hana::transform(hana::accessors&lt;ns::Person&gt;(), hana::first);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    names == hana::make_tuple(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>), BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ns::Person john{<span class="stringliteral">&quot;John&quot;</span>, 30}, bob{<span class="stringliteral">&quot;Bob&quot;</span>, 40};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::equal(john, john));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::not_equal(john, bob));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>)) == hana::just(<span class="stringliteral">&quot;John&quot;</span>));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>)) == hana::just(30));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;foo&quot;</span>)) == hana::nothing);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::to&lt;hana::Tuple&gt;(john) == hana::make_tuple(</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>), <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>), 30)</div>
<div class="line">    ));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::to&lt;hana::Map&gt;(john) == hana::make_map(</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>), <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>), 30)</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a733de713ae2407331983c60186b215ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_HANA_DEFINE_STRUCT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;BOOST_HANA_DEFINE_STRUCT_IMPL(<a class="el" href="group__group-details.html#ga62fe3327023c37706c827cc82624998b">BOOST_HANA_PP_NARG</a>(__VA_ARGS__), __VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines members of a structure, while at the same time modeling <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code>. </p>
<p>Using this macro in the body of a user-defined type will define the given members inside that type, and will also provide a model of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept for that user-defined type. This macro is often the easiest way to define a model of the <code><a class="el" href="structboost_1_1hana_1_1Struct.html" title="The Struct concept represents struct-like user-defined types. ">Struct</a></code> concept.</p>
<dl class="section note"><dt>Note</dt><dd>This macro only works if the tag of the user-defined type <code>T</code> is <code>T</code> itself. This is the case unless you specifically asked for something different; see <code>datatype</code>'s documentation.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="accessors_8hpp.html">boost/hana/accessors.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2convert_8hpp.html">boost/hana/core/convert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="define__struct_8hpp.html">boost/hana/define_struct.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find_8hpp.html">boost/hana/find.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="first_8hpp.html">boost/hana/first.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="string_8hpp.html">boost/hana/string.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Struct.html#a733de713ae2407331983c60186b215ca">BOOST_HANA_DEFINE_STRUCT</a>(Person,</div>
<div class="line">        (std::string, name),</div>
<div class="line">        (<span class="keywordtype">int</span>, age)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The member names are hana::strings:</span></div>
<div class="line"><span class="keyword">auto</span> names = hana::transform(hana::accessors&lt;Person&gt;(), hana::first);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    names == hana::make_tuple(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>), BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30}, bob{<span class="stringliteral">&quot;Bob&quot;</span>, 40};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::equal(john, john));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::not_equal(john, bob));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>)) == hana::just(<span class="stringliteral">&quot;John&quot;</span>));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>)) == hana::just(30));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::find(john, BOOST_HANA_STRING(<span class="stringliteral">&quot;foo&quot;</span>)) == hana::nothing);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::to&lt;hana::Tuple&gt;(john) == hana::make_tuple(</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>), <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>), 30)</div>
<div class="line">    ));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::to&lt;hana::Map&gt;(john) == hana::make_map(</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;name&quot;</span>), <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        hana::make_pair(BOOST_HANA_STRING(<span class="stringliteral">&quot;age&quot;</span>), 30)</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Struct.html">Struct</a></li>
  </ul>
</div>
</body>
</html>
