<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Logical Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_logical.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_logical-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Logical Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> concept represents types with a truth value. </p>
<p>Intuitively, a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> is just a <code>bool</code>, or something that can act like one. However, in the context of programming with heterogeneous objects, it becomes extremely important to distinguish between those objects whose truth value is known at compile-time, and those whose truth value is only known at runtime. The reason why this is so important is because it is possible to branch at compile-time on a condition whose truth value is known at compile-time, and hence the return type of the enclosing function can depend on that truth value. However, if the truth value is only known at runtime, then the compiler has to compile both branches (because any or both of them may end up being used), which creates the additional requirement that both branches must evaluate to the same type.</p>
<p>Specifically, <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> (almost) represents a <a href="http://en.wikipedia.org/wiki/Boolean_algebra_(structure)">boolean algebra</a>, which is a mathematical structure encoding the usual properties that allow us to reason with <code>bool</code>. The exact properties that must be satisfied by any model of <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> are rigorously stated in the laws below.</p>
<h2>Truth, falsity and logical equivalence </h2>
<p>A <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>x</code> is said to be <em>true-valued</em>, or sometimes also just <em>true</em> as an abuse of notation, if </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a06927a2badb729e1522b9030d18234df">if_</a>(x, <span class="keyword">true</span>, <span class="keyword">false</span>) == <span class="keyword">true</span></div>
</div><!-- fragment --><p>Similarly, <code>x</code> is <em>false-valued</em>, or sometimes just <em>false</em>, if </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a06927a2badb729e1522b9030d18234df">if_</a>(x, <span class="keyword">true</span>, <span class="keyword">false</span>) == <span class="keyword">false</span></div>
</div><!-- fragment --><p>This provides a standard way of converting any <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> to a straight <code>bool</code>. The notion of truth value suggests another definition, which is that of logical equivalence. We will say that two <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s <code>x</code> and <code>y</code> are <em>logically equivalent</em> if they have the same truth value. To denote that some expressions <code>p</code> and <code>q</code> of a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> data type are logically equivalent, we will sometimes also write </p><div class="fragment"><div class="line">p   <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>   q</div>
</div><!-- fragment --><p> which is very common in mathematics. The intuition behind this notation is that whenever <code>p</code> is true-valued, then <code>q</code> should be; but when <code>p</code> is false-valued, then <code>q</code> should be too. Hence, <code>p</code> should be true-valued when (and only when) <code>q</code> is true-valued.</p>
<h2>Laws </h2>
<p>As outlined above, the <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> concept almost represents a boolean algebra. The rationale for this laxity is to allow things like integers to act like <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s, which is aligned with C++, even though they do not form a boolean algebra. Even though we depart from the usual axiomatization of boolean algebras, we have found through experience that the definition of a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> given here is largely compatible with intuition.</p>
<p>The following laws must be satisfied for any data type <code>L</code> modeling the <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> concept. Let <code>a</code>, <code>b</code> and <code>c</code> be objects of a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> data type, and let <code>t</code> and <code>f</code> be arbitrary <em>true-valued</em> and <em>false-valued</em> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s of that data type, respectively. Then, </p><div class="fragment"><div class="line"><span class="comment">// associativity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(b, c))   == <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, b), c)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(b, c)) == <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, b), c)</div>
<div class="line"></div>
<div class="line"><span class="comment">// equivalence through commutativity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, b)   if and only if   <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(b, a)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, b)  if and only if   <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(b, a)</div>
<div class="line"></div>
<div class="line"><span class="comment">// absorption</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, b)) == a</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, b)) == a</div>
<div class="line"></div>
<div class="line"><span class="comment">// left identity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, f)  == a</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, t) == a</div>
<div class="line"></div>
<div class="line"><span class="comment">// distributivity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(b, c)) == <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, b), <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, c))</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(b, c)) == <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, b), <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, c))</div>
<div class="line"></div>
<div class="line"><span class="comment">// complements</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#a3c5a578f274b7513e5008eab698fa5bc">not_</a>(a))  is true-valued</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(a, <a class="code" href="structboost_1_1hana_1_1_logical.html#a3c5a578f274b7513e5008eab698fa5bc">not_</a>(a)) is false-valued</div>
</div><!-- fragment --><blockquote class="doxtable">
<h4>Why is the above not a boolean algebra?</h4>
<p>If you look closely, you will find that we depart from the usual boolean algebras because:</p><ol type="1">
<li>we do not require the elements representing truth and falsity to be unique</li>
<li>we do not enforce commutativity of the <code>and_</code> and <code>or_</code> operations</li>
<li>because we do not enforce commutativity, the identity laws become left-identity laws </li>
</ol>
</blockquote>
<h2>Minimal complete definition </h2>
<ol type="1">
<li><code>eval_if</code>, <code>not_</code> and <code>while_</code><br />
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd></dd></dl>
</li>
</ol>
<h2>Provided models </h2>
<ol type="1">
<li>For arithmetic data types<br />
A data type <code>T</code> is arithmetic if <code>std::is_arithmetic&lt;T&gt;<a class="el" href="structboost_1_1hana_1_1_constant.html#adea9453327ac4d6834a555ae9887d3f5" title="Return the compile-time value associated to a constant. ">value</a></code> is true. For an arithmetic data type <code>T</code>, a model of <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> is provided automatically by using the result of the builtin implicit conversion to <code>bool</code> as a truth value. Specifically, the minimal complete definition for those data types is <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a>(cond, then, else_) = cond ? then(<span class="keywordtype">id</span>) : else(<a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a3c5a578f274b7513e5008eab698fa5bc">not_</a>(cond) = static_cast&lt;T&gt;(cond ? false : true)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#abd199c2e8d8947decc01a5e43b1f4489">while_</a>(pred, state, f) = equivalent <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a> a normal while loop</div>
</div><!-- fragment --></li>
</ol>
<blockquote class="doxtable">
<h4>Rationale for not providing a model for all contextually convertible to bool data types</h4>
<p>The <code>not_</code> method can not be implemented in a meaningful way for all of those types. For example, one can not cast a pointer type <code>T*</code> to bool and then back again to <code>T*</code> in a meaningful way. With an arithmetic type <code>T</code>, however, it is possible to cast from <code>T</code> to bool and then to <code>T</code> again; the result will be <code>0</code> or <code>1</code> depending on the truth value. If you want to use a pointer type or something similar in a conditional, it is suggested to explicitly convert it to bool by using <code>to&lt;bool&gt;</code>. </p>
</blockquote>
<h2>Operators </h2>
<p>For convenience, the following operators are provided as an equivalent way of calling the corresponding method: </p><div class="fragment"><div class="line">&amp;&amp;  -&gt;  <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a></div>
<div class="line">||  -&gt;  <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a></div>
</div><!-- fragment --><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>We can't use perfect forwarding in that MCD because of <a href="http://llvm.org/bugs/show_bug.cgi?id=20619">this bug</a>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>The methods don't short-circuit right now, which is a real bummer.</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a06927a2badb729e1522b9030d18234df"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_logical.html#a06927a2badb729e1522b9030d18234df">if_</a></td></tr>
<tr class="memdesc:a06927a2badb729e1522b9030d18234df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally return one of two values based on a condition.  <a href="#a06927a2badb729e1522b9030d18234df">More...</a><br /></td></tr>
<tr class="separator:a06927a2badb729e1522b9030d18234df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f92ff5d73f8ebd7e9eb61142b2e68e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_logical.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a></td></tr>
<tr class="memdesc:a97f92ff5d73f8ebd7e9eb61142b2e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally execute one of two branches based on a condition.  <a href="#a97f92ff5d73f8ebd7e9eb61142b2e68e">More...</a><br /></td></tr>
<tr class="separator:a97f92ff5d73f8ebd7e9eb61142b2e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd199c2e8d8947decc01a5e43b1f4489"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_logical.html#abd199c2e8d8947decc01a5e43b1f4489">while_</a></td></tr>
<tr class="memdesc:abd199c2e8d8947decc01a5e43b1f4489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to an initial state while some predicate is satisfied.  <a href="#abd199c2e8d8947decc01a5e43b1f4489">More...</a><br /></td></tr>
<tr class="separator:abd199c2e8d8947decc01a5e43b1f4489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdaf4c04c0ffd8172004ed37c1d44b7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_logical.html#a4fdaf4c04c0ffd8172004ed37c1d44b7">until</a></td></tr>
<tr class="memdesc:a4fdaf4c04c0ffd8172004ed37c1d44b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to an initial state until some predicate is satisfied.  <a href="#a4fdaf4c04c0ffd8172004ed37c1d44b7">More...</a><br /></td></tr>
<tr class="separator:a4fdaf4c04c0ffd8172004ed37c1d44b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5a578f274b7513e5008eab698fa5bc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_logical.html#a3c5a578f274b7513e5008eab698fa5bc">not_</a></td></tr>
<tr class="memdesc:a3c5a578f274b7513e5008eab698fa5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.  <a href="#a3c5a578f274b7513e5008eab698fa5bc">More...</a><br /></td></tr>
<tr class="separator:a3c5a578f274b7513e5008eab698fa5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0365b860f1383b8077ea86eee79a23"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a></td></tr>
<tr class="memdesc:a8d0365b860f1383b8077ea86eee79a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the arguments are true-valued.  <a href="#a8d0365b860f1383b8077ea86eee79a23">More...</a><br /></td></tr>
<tr class="separator:a8d0365b860f1383b8077ea86eee79a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5683e17dd3318d3be74e5defb1e7252"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a></td></tr>
<tr class="memdesc:ac5683e17dd3318d3be74e5defb1e7252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any of the arguments is true-valued.  <a href="#ac5683e17dd3318d3be74e5defb1e7252">More...</a><br /></td></tr>
<tr class="separator:ac5683e17dd3318d3be74e5defb1e7252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a06927a2badb729e1522b9030d18234df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto if_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; cond, <span class="keyword">auto</span>&amp;&amp; then, <span class="keyword">auto</span>&amp;&amp; else_) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Conditionally return one of two values based on a condition. </p>
<p>Specifically, <code>then</code> is returned iff <code>cond</code> is true-valued, and <code>else_</code> is returned otherwise. Note that some <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> models may allow <code>then</code> and <code>else_</code> to have different types, while others may require both values to have the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition determining which of the two values is returned.</td></tr>
    <tr><td class="paramname">then</td><td>The value returned when <code>cond</code> is true-valued.</td></tr>
    <tr><td class="paramname">else_</td><td>The value returned when <code>cond</code> is false-valued.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a06927a2badb729e1522b9030d18234df">if_</a>(<span class="keyword">true</span>, 1, 2) == 1);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a06927a2badb729e1522b9030d18234df">if_</a>(<span class="keyword">false</span>, 1, 2) == 2);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_logical.html#a06927a2badb729e1522b9030d18234df">if_</a>(true_,</div>
<div class="line">        make&lt;Tuple&gt;(<span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;e&#39;</span>),</div>
<div class="line">        make&lt;Tuple&gt;(<span class="charliteral">&#39;f&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;e&#39;</span>)</div>
<div class="line">    )</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;e&#39;</span>)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97f92ff5d73f8ebd7e9eb61142b2e68e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto eval_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; cond, <span class="keyword">auto</span>&amp;&amp; then, <span class="keyword">auto</span>&amp;&amp; else_) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Conditionally execute one of two branches based on a condition. </p>
<p>Given a condition and two branches in the form of lambdas, <code>eval_if</code> will evaluate the branch selected by the condition and return the result. But that's not all; the lambdas must accept a parameter (usually called <code>_</code>), which can be used to defer the compile-time evaluation of expressions as required. Here's an example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">auto</span> fact(N n) {</div>
<div class="line">    <span class="keywordflow">return</span> hana::eval_if(n == hana::int_&lt;0&gt;,</div>
<div class="line">        [](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) { <span class="keywordflow">return</span> hana::int_&lt;1&gt;; },</div>
<div class="line">        [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) { <span class="keywordflow">return</span> n * fact(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(n) - hana::int_&lt;1&gt;); }</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><p>What happens here is that <code>eval_if</code> will pass an identity function to the selected branch. Hence, <code>_(x)</code> is always the same as <code>x</code>, but the compiler can't tell until the lambda has been called! Hence, the compiler has to wait before it instantiates the body of the lambda and no infinite recursion happens. However, this trick to delay the instantiation of the lambda's body can only be used when the condition is known at compile-time, because otherwise both branches have to be instantiated inside the <code>eval_if</code> anyway. Also note that <code>always</code> can be used to make <code>eval_if</code> easier to work with: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</div>
<div class="line"><span class="keyword">auto</span> fact(N n) {</div>
<div class="line">    <span class="keywordflow">return</span> hana::eval_if(n == hana::int_&lt;0&gt;,</div>
<div class="line">        <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(hana::int_&lt;1&gt;),</div>
<div class="line">        [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) { <span class="keywordflow">return</span> n * fact(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(n) - hana::int_&lt;1&gt;); }</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are several caveats to note with our approach to lazy branching. First, because we're using lambdas, it means that the function's result can't be used in a constant expression. This is a limitation of the current version of C++.</p>
<p>The second caveat is that compilers currently have several bugs regarding deeply nested lambdas with captures. So you always risk crashing the compiler, but this is a question of time before it is not a problem anymore.</p>
<p>Finally, it means that conditionals can't be written directly inside unevaluated contexts. The reason is that a lambda can't appear in an unevaluated context, for example in <code>decltype</code>. One way to workaround this is to completely lift your type computations into variable templates instead. So instead of writing e.g. (stupid example, just to show): </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>f : decltype(eval_if(true_,</div>
<div class="line">        [](auto _) { return type&lt;T&gt;; },</div>
<div class="line">        [](auto _) { return type&lt;T&gt;; }</div>
<div class="line">    ))</div>
<div class="line">{ };</div>
</div><!-- fragment --><p>you could instead write</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> f_impl(_type&lt;T&gt; t) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_logical.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a>(true_,</div>
<div class="line">        [](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> type&lt;T&gt;; },</div>
<div class="line">        [](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> type&lt;T&gt;; }</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using</span> f = decltype(f_impl(type&lt;T&gt;));</div>
</div><!-- fragment --><p>Now, this hoop-jumping only has to be done in one place, because you should use normal function notation everywhere else in your metaprogram to perform type computations. So the syntactic cost is amortized over the whole program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>The condition determining which of the two branches is selected.</td></tr>
    <tr><td class="paramname">then</td><td>A function called as <code>then([](auto x) { return x; })</code> if <code>cond</code> is true-valued.</td></tr>
    <tr><td class="paramname">else_</td><td>A function called as <code>else_([](auto x) { return x; })</code> if <code>cond</code> is false-valued.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example (purely compile-time condition) </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> safe_make_unsigned = [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_logical.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a>(trait&lt;std::is_integral&gt;(t),</div>
<div class="line">        [=](<span class="keyword">auto</span> <span class="keywordtype">id</span>) { <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(template_&lt;std::make_unsigned_t&gt;)(t); },</div>
<div class="line">        <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(t)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(safe_make_unsigned(type&lt;void&gt;) == type&lt;void&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(safe_make_unsigned(type&lt;int&gt;) == type&lt;unsigned int&gt;);</div>
</div><!-- fragment --> <h2>Example (runtime or <code>constexpr</code> condition) </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> safe_divide = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_logical.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a>(y == 0,</div>
<div class="line">        [=](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> 0; },</div>
<div class="line">        [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>) { <span class="keywordflow">return</span> <a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(x) / y; }</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(safe_divide(6, 3) == 2);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(safe_divide(6, 0) == 0);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd199c2e8d8947decc01a5e43b1f4489"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto while_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; pred, <span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Apply a function to an initial state while some predicate is satisfied. </p>
<p>This method is a natural extension of the <code>while</code> language construct to manipulate a state whose type may change from one iteration to another. However, note that having a state whose type changes from one iteration to the other is only possible as long as the predicate returns a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> whose truth value is known at compile-time.</p>
<p>Specifically, <code>while_(pred, state, f)</code> is equivalent to </p><div class="fragment"><div class="line">f(...f(f(state)))</div>
</div><!-- fragment --><p> where <code>f</code> is iterated as long as <code>pred(f(...))</code> is a true-valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>A predicate called on the state or on the result of applying <code>f</code> a certain number of times to the state, and returning whether <code>f</code> should be applied one more time.</td></tr>
    <tr><td class="paramname">state</td><td>The initial state on which <code>f</code> is applied.</td></tr>
    <tr><td class="paramname">f</td><td>A function that is iterated on the initial state. Note that the return type of <code>f</code> may change from one iteration to the other, but only while <code>pred</code> returns a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. In other words, <code>decltype(f(stateN))</code> may differ from <code>decltype(f(stateN+1))</code>, but only if <code>pred(f(stateN))</code> returns a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example (purely compile-time condition) </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line">std::vector&lt;int&gt; ints;</div>
<div class="line"><span class="keyword">auto</span> final_state = <a class="code" href="structboost_1_1hana_1_1_logical.html#abd199c2e8d8947decc01a5e43b1f4489">while_</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 10_c, 0_c, [&amp;](<span class="keyword">auto</span> i) {</div>
<div class="line">    ints.push_back(i);</div>
<div class="line">    <span class="keywordflow">return</span> i + 1_c;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// The state is known at compile-time</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(final_state == 10_c);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ints == std::vector&lt;int&gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});</div>
</div><!-- fragment --> <h2>Example (runtime or <code>constexpr</code> condition) </h2>
<div class="fragment"><div class="line">std::vector&lt;int&gt; ints;</div>
<div class="line"><span class="keywordtype">int</span> final_state = <a class="code" href="structboost_1_1hana_1_1_logical.html#abd199c2e8d8947decc01a5e43b1f4489">while_</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> &lt; 10, 0, [&amp;](<span class="keywordtype">int</span> i) {</div>
<div class="line">    ints.push_back(i);</div>
<div class="line">    <span class="keywordflow">return</span> i + 1;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// The state is known only at runtime</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(final_state == 10);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ints == std::vector&lt;int&gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4fdaf4c04c0ffd8172004ed37c1d44b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto until</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; pred, <span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Apply a function to an initial state until some predicate is satisfied. </p>
<p>Specifically, <code>until(pred, state, f)</code> is equivalent to </p><div class="fragment"><div class="line">f(...f(f(state)))</div>
</div><!-- fragment --><p> where <code>f</code> is iterated until <code>pred(f(...))</code> is a true-valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>A predicate called on the state or on the result of applying <code>f</code> a certain number of times to the state, and returning whether <code>f</code> should stop being applied.</td></tr>
    <tr><td class="paramname">state</td><td>The initial state on which <code>f</code> is applied.</td></tr>
    <tr><td class="paramname">f</td><td>A function that is iterated on the initial state. Note that the return type of <code>f</code> may change from one iteration to the other, but only while <code>pred</code> returns a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. In other words, <code>decltype(f(stateN))</code> may differ from <code>decltype(f(stateN+1))</code>, but only if <code>pred(f(stateN))</code> returns a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example (purely compile-time condition) </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line">std::vector&lt;int&gt; ints;</div>
<div class="line"><span class="keyword">auto</span> final_state = <a class="code" href="structboost_1_1hana_1_1_logical.html#a4fdaf4c04c0ffd8172004ed37c1d44b7">until</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == 10_c, 0_c, [&amp;](<span class="keyword">auto</span> i) {</div>
<div class="line">    ints.push_back(i);</div>
<div class="line">    <span class="keywordflow">return</span> i + 1_c;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// The state is known at compile-time</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(final_state == 10_c);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ints == std::vector&lt;int&gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});</div>
</div><!-- fragment --> <h2>Example (runtime or <code>constexpr</code> condition) </h2>
<div class="fragment"><div class="line">std::vector&lt;int&gt; ints;</div>
<div class="line"><span class="keywordtype">int</span> final_state = <a class="code" href="structboost_1_1hana_1_1_logical.html#a4fdaf4c04c0ffd8172004ed37c1d44b7">until</a>(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == 10, 0, [&amp;](<span class="keywordtype">int</span> i) {</div>
<div class="line">    ints.push_back(i);</div>
<div class="line">    <span class="keywordflow">return</span> i + 1;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="comment">// The state is known only at runtime</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(final_state == 10);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ints == std::vector&lt;int&gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3c5a578f274b7513e5008eab698fa5bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto not_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Negates a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. </p>
<p>This method returns a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> of the same data type, but whose truth-value is negated. Specifically, <code>not_(x)</code> returns a false-valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> if <code>x</code> is a true-valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>, and a true-valued one otherwise.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a3c5a578f274b7513e5008eab698fa5bc">not_</a>(true_) == false_);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a3c5a578f274b7513e5008eab698fa5bc">not_</a>(<span class="keyword">false</span>) == <span class="keyword">true</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8d0365b860f1383b8077ea86eee79a23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto and_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether all the arguments are true-valued. </p>
<p><code>and_</code> can be called with one argument or more. When called with two arguments, <code>and_</code> uses tag-dispatching to find the right implementation. Otherwise, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(x) == x</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(x, y, ...z) == <a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(x, y), z...)</div>
</div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(true_, true_, true_, true_));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1_logical.html#a8d0365b860f1383b8077ea86eee79a23">and_</a>(true_, <span class="keyword">false</span>, true_, true_));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac5683e17dd3318d3be74e5defb1e7252"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto or_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether any of the arguments is true-valued. </p>
<p><code>or_</code> can be called with one argument or more. When called with two arguments, <code>or_</code> uses tag-dispatching to find the right implementation. Otherwise, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(x) == x</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(x, y, ...z) == <a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(x, y), z...)</div>
</div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(false_, false_, true_));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1_logical.html#ac5683e17dd3318d3be74e5defb1e7252">or_</a>(false_, false_, false_));</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_logical.html">Logical</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
