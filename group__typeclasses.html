<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Boost.Hana: Type classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__typeclasses.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Type classes</div>  </div>
</div><!--header-->
<div class="contents">

<p>General purpose type classes provided by the library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structboost_1_1hana_1_1_applicative"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative">boost::hana::Applicative</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_applicative"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>s are <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>s with the ability to lift values and combine computations.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_applicative">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_applicative"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_comparable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable">boost::hana::Comparable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> type class defines equality and inequality.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_comparable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_boolean"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_boolean">boost::hana::Boolean</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_boolean"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_boolean" title="The Boolean type class defines a boolean algebra). ">Boolean</a></code> type class defines a <a href="http://en.wikipedia.org/wiki/Boolean_algebra_(structure">boolean algebra</a>).  <a href="group__typeclasses.html#structboost_1_1hana_1_1_boolean">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_boolean"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_monad_zero"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad_zero">boost::hana::MonadZero</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_monad_zero"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code>s with a neutral element.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_monad_zero">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_monad_zero"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_pattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pattern">boost::hana::Pattern</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_pattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">...  <a href="group__typeclasses.html#structboost_1_1hana_1_1_pattern">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_pattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_foldable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_foldable">boost::hana::Foldable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_foldable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures that can be folded, i.e. summarized into a single value.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_foldable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_foldable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_functor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor">boost::hana::Functor</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_functor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code> represents types that can be mapped over.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_functor">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_iterable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_iterable">boost::hana::Iterable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_iterable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures allowing external iteration.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_iterable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_iterable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_list"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list">boost::hana::List</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_list"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose index-based sequence.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_list">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_list"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_logical"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical">boost::hana::Logical</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_logical"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> type class is for data types acting like a boolean.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_logical">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_logical"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_monad"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad">boost::hana::Monad</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_monad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code>s are <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>s with the ability to flatten values that were lifted more than once.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_monad">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_monad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_orderable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_orderable">boost::hana::Orderable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_orderable"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_orderable" title="The Orderable type class is used for data types defining a strict weak ordering. ">Orderable</a></code> type class is used for data types defining a <a href="http://en.wikipedia.org/wiki/Strict_weak_ordering">strict weak ordering</a>.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_orderable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_orderable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_pair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair">boost::hana::Pair</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_pair"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container of two elements.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_pair">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_pair"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_record"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_record">boost::hana::Record</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_record"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a> class for record-like user-defined types.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_record">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_record"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_searchable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_searchable">boost::hana::Searchable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_searchable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures that can be searched.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_searchable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_searchable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structboost_1_1hana_1_1_traversable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_traversable">boost::hana::Traversable</a></td></tr>
<tr class="memdesc:structboost_1_1hana_1_1_traversable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures that can be traversed from left to right.  <a href="group__typeclasses.html#structboost_1_1hana_1_1_traversable">More...</a><br /></td></tr>
<tr class="separator:structboost_1_1hana_1_1_traversable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>General purpose type classes provided by the library. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd><ul>
<li>Implement better law checking and check them for all instances in the unit tests. Since we're modularized, it's OK to resort to heavy stuff in the law-checking because it's presumably only done in unit testing contexts.</li>
<li>Provide a way to check type class requirements like <code>Functor f =&gt; Applicative f</code>.</li>
<li>Document requirements for the existing type classes.</li>
<li>Find a better way to provide instances between type classes; consider something like <code>Foldable::instance&lt;Iterable&gt;</code>.</li>
<li>Consider inheriting from a base class even when no mcd is required. That would allow us to <em>not</em> include a useless mcd.</li>
<li>Document the purpose of minimal instances; they are meant to provide an easy to use archetype for testing and their tests are meant to exercise the basic dispatching code of type classes (hence it makes sense to test even the mcd of a minimal instance). In particular, they are not meant to be <em>the</em> minimal instance, which does not exist in general (what does it even mean to be a <em>minimal</em> instance?) </li>
</ul>
</dd></dl>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structboost_1_1hana_1_1_applicative" id="structboost_1_1hana_1_1_applicative"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Applicative</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>s are <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>s with the ability to lift values and combine computations. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a0d7511a7a164af8cc6040052b3fbee51"><td class="memItemLeft" align="right" valign="top">constexpr applicative_detail::ap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a0d7511a7a164af8cc6040052b3fbee51">ap</a></td></tr>
<tr class="memdesc:a0d7511a7a164af8cc6040052b3fbee51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifted application.  <a href="#a0d7511a7a164af8cc6040052b3fbee51">More...</a><br /></td></tr>
<tr class="separator:a0d7511a7a164af8cc6040052b3fbee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418eeb3e706b17eabd5bf0a491d3219e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a418eeb3e706b17eabd5bf0a491d3219e"></a>
template&lt;typename A &gt; </td></tr>
<tr class="memitem:a418eeb3e706b17eabd5bf0a491d3219e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
applicative_detail::lift&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a418eeb3e706b17eabd5bf0a491d3219e">lift</a></td></tr>
<tr class="memdesc:a418eeb3e706b17eabd5bf0a491d3219e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift a value into the functor. <br /></td></tr>
<tr class="separator:a418eeb3e706b17eabd5bf0a491d3219e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a0d7511a7a164af8cc6040052b3fbee51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr applicative_detail::ap ap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lifted application. </p>
<p><code>ap</code> can be called with two arguments or more. Specifically, <code>ap(f, x1, ..., xN)</code> is equivalent to </p><div class="fragment"><div class="line">foldl(<a class="code" href="group__typeclasses.html#a0d7511a7a164af8cc6040052b3fbee51">ap</a>, fmap(curry&lt;N&gt;, f), list(x1, ..., xN));</div>
</div><!-- fragment --><p> where <code>ap(f, x)</code> (called with two arguments only) dispatches to the implementation in the type class. This basically means that applying a <code>N</code>-ary function with <code>ap</code> is equivalent to applying a curried binary function to each argument starting from the left with the <code>ap</code> provided in the type class.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(lift&lt;List&gt;(<span class="charliteral">&#39;a&#39;</span>) == list(<span class="charliteral">&#39;a&#39;</span>));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = _ + <a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>;</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a0d7511a7a164af8cc6040052b3fbee51">ap</a>(lift&lt;List&gt;(f), list(1, 2), list(3, 4, 5))</div>
<div class="line">            ==</div>
<div class="line">        list(</div>
<div class="line">            f(1, 3), f(1, 4), f(1, 5),</div>
<div class="line">            f(2, 3), f(2, 4), f(2, 5)</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Consider giving access to all the arguments to the type class implementation. This is for performance purposes. </dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_comparable" id="structboost_1_1hana_1_1_comparable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Comparable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> type class defines equality and inequality. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa3d0a020ddd527610472c91f5a8cc627"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aa3d0a020ddd527610472c91f5a8cc627">equal</a></td></tr>
<tr class="memdesc:aa3d0a020ddd527610472c91f5a8cc627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> is equal to <code>y</code>.  <a href="#aa3d0a020ddd527610472c91f5a8cc627">More...</a><br /></td></tr>
<tr class="separator:aa3d0a020ddd527610472c91f5a8cc627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6983538356aab75eddf1a7aace6c7925"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6983538356aab75eddf1a7aace6c7925"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a6983538356aab75eddf1a7aace6c7925">not_equal</a></td></tr>
<tr class="memdesc:a6983538356aab75eddf1a7aace6c7925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> is not equal to <code>y</code>. <br /></td></tr>
<tr class="separator:a6983538356aab75eddf1a7aace6c7925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf55eb75a556b3a05bab60cd6812765"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeaf55eb75a556b3a05bab60cd6812765"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aeaf55eb75a556b3a05bab60cd6812765"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aeaf55eb75a556b3a05bab60cd6812765">operator==</a> (T t, U u)</td></tr>
<tr class="memdesc:aeaf55eb75a556b3a05bab60cd6812765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>equal</code>. <br /></td></tr>
<tr class="separator:aeaf55eb75a556b3a05bab60cd6812765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66dcc2f25a479af62d1ec8f88af5be"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae66dcc2f25a479af62d1ec8f88af5be"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aae66dcc2f25a479af62d1ec8f88af5be"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aae66dcc2f25a479af62d1ec8f88af5be">operator!=</a> (T t, U u)</td></tr>
<tr class="memdesc:aae66dcc2f25a479af62d1ec8f88af5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>not_equal</code>. <br /></td></tr>
<tr class="separator:aae66dcc2f25a479af62d1ec8f88af5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="aa3d0a020ddd527610472c91f5a8cc627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto equal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> is equal to <code>y</code>. </p>
<h3>Design choice: arity of <code>equal</code></h3>
<p>It is a valid question whether <code>equal</code> should accept more than 2 arguments and have semantics matching those of Python's <code>==</code>. This is not supported right now for the following reasons:</p>
<ul>
<li>It was not shown to be useful so far in the MPL11.</li>
<li>It does not make sense for <code>not_equal</code> to have an arity of more than 2, so only <code>equal</code> could maybe have those semantics.</li>
<li>Having a binary <code>equal</code> makes it possible to use currying.</li>
<li><code>equal(x, y...)</code> can be implemented as <code>all(x == _, list(y...))</code>, which is pretty straightforward anyway. </li>
</ul>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_boolean" id="structboost_1_1hana_1_1_boolean"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Boolean</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_boolean" title="The Boolean type class defines a boolean algebra). ">Boolean</a></code> type class defines a <a href="http://en.wikipedia.org/wiki/Boolean_algebra_(structure">boolean algebra</a>). </p>
<dl class="section note"><dt>Note</dt><dd>We could define what it means for a <a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_boolean" title="The Boolean type class defines a boolean algebra). ">Boolean</a> to be compile-time and what it means to be runtime. Then, it might be possible to specify some algorithms in term of the runtime-ness of the predicates they use internally. Shooting from the hip, compile-time ness might be the capacity to have a <code>then</code> and an <code>else_</code> branch of different type, plus the insurance to never try to cast the unused branch (that could work hand-in-hand with a <code>lazy</code> feature). <hr/>
</dd></dl>
<h2>Laws</h2>
<p>... </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a3238b7d85470904196c4755376c28706"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3238b7d85470904196c4755376c28706"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a3238b7d85470904196c4755376c28706">complement</a></td></tr>
<tr class="memdesc:a3238b7d85470904196c4755376c28706"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a3238b7d85470904196c4755376c28706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133a70eec55b87b1b3285cbd12fd5992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a133a70eec55b87b1b3285cbd12fd5992"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a133a70eec55b87b1b3285cbd12fd5992">meet</a></td></tr>
<tr class="memdesc:a133a70eec55b87b1b3285cbd12fd5992"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a133a70eec55b87b1b3285cbd12fd5992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f57bdbbaf34b74120e9b7053b82a98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03f57bdbbaf34b74120e9b7053b82a98"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a03f57bdbbaf34b74120e9b7053b82a98">join</a></td></tr>
<tr class="memdesc:a03f57bdbbaf34b74120e9b7053b82a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a03f57bdbbaf34b74120e9b7053b82a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7e83a17c143837783fb9d05dc3a484"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c7e83a17c143837783fb9d05dc3a484"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c7e83a17c143837783fb9d05dc3a484"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a7c7e83a17c143837783fb9d05dc3a484">top</a></td></tr>
<tr class="memdesc:a7c7e83a17c143837783fb9d05dc3a484"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a7c7e83a17c143837783fb9d05dc3a484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105fa230da7924fbed0073c5b9fc56f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a105fa230da7924fbed0073c5b9fc56f5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a105fa230da7924fbed0073c5b9fc56f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a105fa230da7924fbed0073c5b9fc56f5">bottom</a></td></tr>
<tr class="memdesc:a105fa230da7924fbed0073c5b9fc56f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a105fa230da7924fbed0073c5b9fc56f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structboost_1_1hana_1_1_monad_zero" id="structboost_1_1hana_1_1_monad_zero"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::MonadZero</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code>s with a neutral element. </p>
<h2>Minimal complete definition</h2>
<p><code>zero</code></p>
<h2>Laws</h2>
<p>... </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a52bd77cbc25ea1180fcbb2c10c61e988"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52bd77cbc25ea1180fcbb2c10c61e988"></a>
template&lt;typename M &gt; </td></tr>
<tr class="memitem:a52bd77cbc25ea1180fcbb2c10c61e988"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a52bd77cbc25ea1180fcbb2c10c61e988">zero</a></td></tr>
<tr class="memdesc:a52bd77cbc25ea1180fcbb2c10c61e988"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a52bd77cbc25ea1180fcbb2c10c61e988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929370eddd43bb1a4a11b00a7880eadb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a></td></tr>
<tr class="memdesc:a929370eddd43bb1a4a11b00a7880eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">...  <a href="#a929370eddd43bb1a4a11b00a7880eadb">More...</a><br /></td></tr>
<tr class="separator:a929370eddd43bb1a4a11b00a7880eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a929370eddd43bb1a4a11b00a7880eadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>... </p>
<h3>Example</h3>
<p>... </p>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_pattern" id="structboost_1_1hana_1_1_pattern"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Pattern</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>... </p>
<p>Example usage </p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = match(value)</div>
<div class="line">    (pattern1, action1)</div>
<div class="line">    (pattern2, action2)</div>
<div class="line">    (otherwise, action3);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">auto</span> result = match(list(1, 2, 3))</div>
<div class="line">    (_cons(_x, _xs), [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> xs) { ... })</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>A lazy action could be anything that can be called with <code>id</code>; this would allow us to create lazy lambdas on the fly and also to use <code><a class="el" href="group__datatypes.html#a73e14285897797737683aa2a776a6e0e" title="Lifts a normal value to a lazy one. ">lazy()</a></code> when we want to. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a5c3fffc3715d863dacc613e7817315f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c3fffc3715d863dacc613e7817315f9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5c3fffc3715d863dacc613e7817315f9">matches</a></td></tr>
<tr class="memdesc:a5c3fffc3715d863dacc613e7817315f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">... <br /></td></tr>
<tr class="separator:a5c3fffc3715d863dacc613e7817315f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structboost_1_1hana_1_1_foldable" id="structboost_1_1hana_1_1_foldable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Foldable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data structures that can be folded, i.e. summarized into a single value. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a0a5d375abcde2ceed89662df491a2c43"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a0a5d375abcde2ceed89662df491a2c43">foldl</a></td></tr>
<tr class="memdesc:a0a5d375abcde2ceed89662df491a2c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-associative fold of a structure using a binary operation.  <a href="#a0a5d375abcde2ceed89662df491a2c43">More...</a><br /></td></tr>
<tr class="separator:a0a5d375abcde2ceed89662df491a2c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dcc2a64352a571154c2ebd8fd1b37d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ab1dcc2a64352a571154c2ebd8fd1b37d">foldr</a></td></tr>
<tr class="memdesc:ab1dcc2a64352a571154c2ebd8fd1b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-associative fold of a structure using a binary operation.  <a href="#ab1dcc2a64352a571154c2ebd8fd1b37d">More...</a><br /></td></tr>
<tr class="separator:ab1dcc2a64352a571154c2ebd8fd1b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b3683b885c27b5c607fe6f0d2f7356"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a03b3683b885c27b5c607fe6f0d2f7356">foldr1</a></td></tr>
<tr class="memdesc:a03b3683b885c27b5c607fe6f0d2f7356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>foldr</code> that has no base case, and thus may only be applied to non-empty structures.  <a href="#a03b3683b885c27b5c607fe6f0d2f7356">More...</a><br /></td></tr>
<tr class="separator:a03b3683b885c27b5c607fe6f0d2f7356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca4972e61b7ad36ff9fcca9e6131da6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a8ca4972e61b7ad36ff9fcca9e6131da6">foldl1</a></td></tr>
<tr class="memdesc:a8ca4972e61b7ad36ff9fcca9e6131da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>foldl</code> that has no base case, and thus may only be applied to non-empty structures.  <a href="#a8ca4972e61b7ad36ff9fcca9e6131da6">More...</a><br /></td></tr>
<tr class="separator:a8ca4972e61b7ad36ff9fcca9e6131da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb377e43aa7753bb77aa346c67fae0d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a></td></tr>
<tr class="memdesc:a5fb377e43aa7753bb77aa346c67fae0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in a finite structure.  <a href="#a5fb377e43aa7753bb77aa346c67fae0d">More...</a><br /></td></tr>
<tr class="separator:a5fb377e43aa7753bb77aa346c67fae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11341a0d825e7898572c1d22d1efe8f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a11341a0d825e7898572c1d22d1efe8f4">minimum_by</a></td></tr>
<tr class="memdesc:a11341a0d825e7898572c1d22d1efe8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least element of a non-empty structure with respect to a <code>predicate</code>.  <a href="#a11341a0d825e7898572c1d22d1efe8f4">More...</a><br /></td></tr>
<tr class="separator:a11341a0d825e7898572c1d22d1efe8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead74d4a75dd467873fcc9124d06b5f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a></td></tr>
<tr class="memdesc:aead74d4a75dd467873fcc9124d06b5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least element of a non-empty structure.  <a href="#aead74d4a75dd467873fcc9124d06b5f4">More...</a><br /></td></tr>
<tr class="separator:aead74d4a75dd467873fcc9124d06b5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0b4fa3e86674f958b725d44607ec5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f0b4fa3e86674f958b725d44607ec5e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a6f0b4fa3e86674f958b725d44607ec5e">maximum_by</a></td></tr>
<tr class="memdesc:a6f0b4fa3e86674f958b725d44607ec5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest element of a non-empty structure with respect to a <code>predicate</code>. <br /></td></tr>
<tr class="separator:a6f0b4fa3e86674f958b725d44607ec5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a8fde2d3de61959c99e755a81c0a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49a8fde2d3de61959c99e755a81c0a1"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ac49a8fde2d3de61959c99e755a81c0a1">maximum</a></td></tr>
<tr class="memdesc:ac49a8fde2d3de61959c99e755a81c0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest element of a non-empty structure. <br /></td></tr>
<tr class="separator:ac49a8fde2d3de61959c99e755a81c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99a05a203907d1381a00d9e05425ab7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae99a05a203907d1381a00d9e05425ab7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ae99a05a203907d1381a00d9e05425ab7">sum</a></td></tr>
<tr class="memdesc:ae99a05a203907d1381a00d9e05425ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the numbers of a structure. <br /></td></tr>
<tr class="separator:ae99a05a203907d1381a00d9e05425ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37fd8d56461f749d49423c711e4c67a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aa37fd8d56461f749d49423c711e4c67a">product</a></td></tr>
<tr class="memdesc:aa37fd8d56461f749d49423c711e4c67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the numbers of a structure.  <a href="#aa37fd8d56461f749d49423c711e4c67a">More...</a><br /></td></tr>
<tr class="separator:aa37fd8d56461f749d49423c711e4c67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a></td></tr>
<tr class="memdesc:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure for which the <code>predicate</code> is satisfied.  <a href="#ae0a55dd7eb4bd4f587f51ffd8c923e53">More...</a><br /></td></tr>
<tr class="separator:ae0a55dd7eb4bd4f587f51ffd8c923e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3e724580e826eaa39a934eefa2b328"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a></td></tr>
<tr class="memdesc:a0e3e724580e826eaa39a934eefa2b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the elements of a structure as arguments.  <a href="#a0e3e724580e826eaa39a934eefa2b328">More...</a><br /></td></tr>
<tr class="separator:a0e3e724580e826eaa39a934eefa2b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a0a5d375abcde2ceed89662df491a2c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto foldl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left-associative fold of a structure using a binary operation. </p>
<h3>Example 1</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#a0a5d375abcde2ceed89662df491a2c43">foldl</a>(show, <span class="stringliteral">&quot;1&quot;</span>, list(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>)) == <span class="stringliteral">&quot;(((1 + 2) + 3) + 4)&quot;</span>);</div>
</div><!-- fragment --> <h3>Example 2</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> types = type_list&lt;long, float, short, double, float, long, long double&gt;;</div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> count_if_float = [](<span class="keyword">auto</span> n, <span class="keyword">auto</span> type) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(trait&lt;std::is_floating_point&gt;(type), n + 1_c, n);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a0a5d375abcde2ceed89662df491a2c43">foldl</a>(count_if_float, 0_c, types) == 4_c);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab1dcc2a64352a571154c2ebd8fd1b37d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto foldr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right-associative fold of a structure using a binary operation. </p>
<h3>Example 1</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#ab1dcc2a64352a571154c2ebd8fd1b37d">foldr</a>(show, <span class="stringliteral">&quot;4&quot;</span>, list(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <span class="stringliteral">&quot;(1 + (2 + (3 + 4)))&quot;</span>);</div>
</div><!-- fragment --> <h3>Example 2</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> numbers = integer_list&lt;int, 5, -1, 0, -7, -2, 0, -5, 4&gt;;</div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> negatives = integer_list&lt;int, -1, -7, -2, -5&gt;;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> keep_negatives = [](<span class="keyword">auto</span> n, <span class="keyword">auto</span> acc) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(n &lt; 0_c, cons(n, acc), acc);</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#ab1dcc2a64352a571154c2ebd8fd1b37d">foldr</a>(keep_negatives, integer_list&lt;int&gt;, numbers) == negatives);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03b3683b885c27b5c607fe6f0d2f7356"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto foldr1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <code>foldr</code> that has no base case, and thus may only be applied to non-empty structures. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#a03b3683b885c27b5c607fe6f0d2f7356">foldr1</a>(show, list(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <span class="stringliteral">&quot;(1 + (2 + 3))&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8ca4972e61b7ad36ff9fcca9e6131da6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto foldl1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <code>foldl</code> that has no base case, and thus may only be applied to non-empty structures. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#a8ca4972e61b7ad36ff9fcca9e6131da6">foldl1</a>(show, list(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5fb377e43aa7753bb77aa346c67fae0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in a finite structure. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>(list()) == 0);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a5fb377e43aa7753bb77aa346c67fae0d">length</a>(list(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == 3);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a11341a0d825e7898572c1d22d1efe8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto minimum_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the least element of a non-empty structure with respect to a <code>predicate</code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a11341a0d825e7898572c1d22d1efe8f4">minimum_by</a>(<a class="code" href="group___functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(_ &lt; _, sizeof_), type_list&lt;<span class="keywordtype">char</span>[1], <span class="keywordtype">char</span>[2], <span class="keywordtype">char</span>[3]&gt;) == type&lt;<span class="keywordtype">char</span>[1]&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aead74d4a75dd467873fcc9124d06b5f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto minimum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the least element of a non-empty structure. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#aead74d4a75dd467873fcc9124d06b5f4">minimum</a>(integer_list&lt;int, -1, 0, 2, -4, 6, 9&gt;) == int_&lt;-4&gt;);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa37fd8d56461f749d49423c711e4c67a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto product</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of the numbers of a structure. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#aa37fd8d56461f749d49423c711e4c67a">product</a>(range(int_&lt;1&gt;, int_&lt;6&gt;)) == int_&lt;1 * 2 * 3 * 4 * 5&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae0a55dd7eb4bd4f587f51ffd8c923e53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in the structure for which the <code>predicate</code> is satisfied. </p>
<h3>Example 1</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(odd, integer_list&lt;int, 1, 2, 3&gt;) == 2_c);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(odd, integer_list&lt;int&gt;) == 0_c);</div>
</div><!-- fragment --> <h3>Example 2</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> types = type_list&lt;int, char, long, short, char, long, double, long&gt;;</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(trait&lt;std::is_floating_point&gt;, types) == 1_c);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(_ == type&lt;char&gt;, types) == 2_c);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#ae0a55dd7eb4bd4f587f51ffd8c923e53">count</a>(_ == type&lt;void&gt;, types) == 0_c);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0e3e724580e826eaa39a934eefa2b328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unpack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a function with the elements of a structure as arguments. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> cheap_tie = [](<span class="keyword">auto</span>&amp; ...vars) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group___functional.html#ga778b2daa27882e71d28b6f2b38982ddf">partial</a>(<a class="code" href="group__typeclasses.html#a0e3e724580e826eaa39a934eefa2b328">unpack</a>, [&amp;vars...](auto ...values) {</div>
<div class="line">            int dummy[] = {((vars = values), 0)...};</div>
<div class="line">            (<span class="keywordtype">void</span>)dummy;</div>
<div class="line">        });</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordtype">int</span> a = 0;</div>
<div class="line">    <span class="keywordtype">char</span> b = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    <span class="keywordtype">double</span> c = 0;</div>
<div class="line">    cheap_tie(a, b, c)(list(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">    assert(a == 1);</div>
<div class="line">    assert(b == <span class="charliteral">&#39;2&#39;</span>);</div>
<div class="line">    assert(c == 3.3);</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_functor" id="structboost_1_1hana_1_1_functor"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Functor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code> represents types that can be mapped over. </p>
<hr/>
<h2>Laws</h2>
<p>Instances of <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code> must satisfy the following laws: </p><div class="fragment"><div class="line"><a class="code" href="group__typeclasses.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a> <span class="keywordtype">id</span> == <span class="keywordtype">id</span></div>
<div class="line"><a class="code" href="group__typeclasses.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a> (f . g) == <a class="code" href="group__typeclasses.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a> f . <a class="code" href="group__typeclasses.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a> g</div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a84bb505c8405a5cd3003db49f652faa2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a></td></tr>
<tr class="memdesc:a84bb505c8405a5cd3003db49f652faa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <code>f</code> over a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>.  <a href="#a84bb505c8405a5cd3003db49f652faa2">More...</a><br /></td></tr>
<tr class="separator:a84bb505c8405a5cd3003db49f652faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ac27a1807b60b8fa59e6c618cb8ca749f">adjust</a></td></tr>
<tr class="memdesc:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all the elements satisfying the <code>predicate</code> with the given function.  <a href="#ac27a1807b60b8fa59e6c618cb8ca749f">More...</a><br /></td></tr>
<tr class="separator:ac27a1807b60b8fa59e6c618cb8ca749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e73dcc09699c619bcfb006029a8967"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a72e73dcc09699c619bcfb006029a8967">replace</a></td></tr>
<tr class="memdesc:a72e73dcc09699c619bcfb006029a8967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements satisfying the <code>predicate</code> with the given value.  <a href="#a72e73dcc09699c619bcfb006029a8967">More...</a><br /></td></tr>
<tr class="separator:a72e73dcc09699c619bcfb006029a8967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35025921d0fb75c28c2411d207a0da5e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a35025921d0fb75c28c2411d207a0da5e">fill</a></td></tr>
<tr class="memdesc:a35025921d0fb75c28c2411d207a0da5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements with a value.  <a href="#a35025921d0fb75c28c2411d207a0da5e">More...</a><br /></td></tr>
<tr class="separator:a35025921d0fb75c28c2411d207a0da5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a84bb505c8405a5cd3003db49f652faa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps <code>f</code> over a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>. </p>
<h3>Example 1</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str();</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a>(to_string, list(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>, std::string{<span class="stringliteral">&quot;67&quot;</span>})) ==</div>
<div class="line">        list(<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;345&quot;</span>, <span class="stringliteral">&quot;67&quot;</span>)</div>
<div class="line">    );</div>
</div><!-- fragment --> <h3>Example 2</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> types = type_list&lt;void, int(), char[10]&gt;;</div>
<div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> pointers = <a class="code" href="group__typeclasses.html#a84bb505c8405a5cd3003db49f652faa2">fmap</a>(template_&lt;std::add_pointer_t&gt;, types);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(pointers == type_list&lt;<span class="keywordtype">void</span>*, <span class="keywordtype">int</span>(*)(), <span class="keywordtype">char</span>(*)[10]&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(head(pointers) == type&lt;void*&gt;);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac27a1807b60b8fa59e6c618cb8ca749f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto adjust</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update all the elements satisfying the <code>predicate</code> with the given function. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#ac27a1807b60b8fa59e6c618cb8ca749f">adjust</a>(_ &lt; int_&lt;0&gt;, -_, list(-3, int_&lt;0&gt;, 1, int_&lt;-5&gt;)) == list(3, int_&lt;0&gt;, 1, int_&lt;5&gt;)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a72e73dcc09699c619bcfb006029a8967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto replace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all the elements satisfying the <code>predicate</code> with the given value. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a72e73dcc09699c619bcfb006029a8967">replace</a>(_ &lt; int_&lt;0&gt;, <span class="charliteral">&#39;x&#39;</span>, list(-3, int_&lt;0&gt;, 1, int_&lt;-5&gt;)) == list(<span class="charliteral">&#39;x&#39;</span>, int_&lt;0&gt;, 1, <span class="charliteral">&#39;x&#39;</span>)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a35025921d0fb75c28c2411d207a0da5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto fill</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace all the elements with a value. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a35025921d0fb75c28c2411d207a0da5e">fill</a>(<span class="charliteral">&#39;a&#39;</span>, list(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="keyword">nullptr</span>)) == list(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;a&#39;</span>)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_iterable" id="structboost_1_1hana_1_1_iterable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Iterable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data structures allowing external iteration. </p>
<dl class="section note"><dt>Note</dt><dd>In the description of the methods, all indexing is 0-based.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd><ul>
<li>What about infinite <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_iterable" title="Data structures allowing external iteration. ">Iterable</a></code>s?</li>
<li>There are probably tons of laws that must be respected? </li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:adc2675aeee1174a9b337e94f39506bec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc2675aeee1174a9b337e94f39506bec"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#adc2675aeee1174a9b337e94f39506bec">head</a></td></tr>
<tr class="memdesc:adc2675aeee1174a9b337e94f39506bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element of a non-empty iterable. <br /></td></tr>
<tr class="separator:adc2675aeee1174a9b337e94f39506bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15783aae10d4373e2399abe728f3f96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab15783aae10d4373e2399abe728f3f96"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ab15783aae10d4373e2399abe728f3f96">tail</a></td></tr>
<tr class="memdesc:ab15783aae10d4373e2399abe728f3f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new iterable containing all but the first element of a non-empty iterable. <br /></td></tr>
<tr class="separator:ab15783aae10d4373e2399abe728f3f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4193ecf811f29479c60022564afa512a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4193ecf811f29479c60022564afa512a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a4193ecf811f29479c60022564afa512a">is_empty</a></td></tr>
<tr class="memdesc:a4193ecf811f29479c60022564afa512a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the iterable is empty. <br /></td></tr>
<tr class="separator:a4193ecf811f29479c60022564afa512a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e91486be10ef3a19495cb3d3652721"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#af4e91486be10ef3a19495cb3d3652721">at</a></td></tr>
<tr class="memdesc:af4e91486be10ef3a19495cb3d3652721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <code>n</code>th element of an iterable.  <a href="#af4e91486be10ef3a19495cb3d3652721">More...</a><br /></td></tr>
<tr class="separator:af4e91486be10ef3a19495cb3d3652721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5379264e83af65af8802eeec0d49e5f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5379264e83af65af8802eeec0d49e5f0"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5379264e83af65af8802eeec0d49e5f0">last</a></td></tr>
<tr class="memdesc:a5379264e83af65af8802eeec0d49e5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element of a non-empty iterable. <br /></td></tr>
<tr class="separator:a5379264e83af65af8802eeec0d49e5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322ee5c860b93d6bfb5571a028f5e5b2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a322ee5c860b93d6bfb5571a028f5e5b2">drop</a></td></tr>
<tr class="memdesc:a322ee5c860b93d6bfb5571a028f5e5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the first <code>n</code> elements of an iterable and return the rest.  <a href="#a322ee5c860b93d6bfb5571a028f5e5b2">More...</a><br /></td></tr>
<tr class="separator:a322ee5c860b93d6bfb5571a028f5e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3e80f4ae219afb61b12201738d28b8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aab3e80f4ae219afb61b12201738d28b8">drop_while</a></td></tr>
<tr class="memdesc:aab3e80f4ae219afb61b12201738d28b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop elements from an iterable up to, but not including, the first element for which the <code>predicate</code> is not satisfied.  <a href="#aab3e80f4ae219afb61b12201738d28b8">More...</a><br /></td></tr>
<tr class="separator:aab3e80f4ae219afb61b12201738d28b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea270dc46fcf8e1a186e99c3019e551"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea270dc46fcf8e1a186e99c3019e551"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a7ea270dc46fcf8e1a186e99c3019e551">drop_until</a></td></tr>
<tr class="memdesc:a7ea270dc46fcf8e1a186e99c3019e551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>drop_while</code> with a negated <code>predicate</code>. <br /></td></tr>
<tr class="separator:a7ea270dc46fcf8e1a186e99c3019e551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80176fbdfbccc09e902263557eb0984d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a80176fbdfbccc09e902263557eb0984d">for_each</a></td></tr>
<tr class="memdesc:a80176fbdfbccc09e902263557eb0984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an action on each element of the iterable, discarding the result each time.  <a href="#a80176fbdfbccc09e902263557eb0984d">More...</a><br /></td></tr>
<tr class="separator:a80176fbdfbccc09e902263557eb0984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="af4e91486be10ef3a19495cb3d3652721"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto at</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <code>n</code>th element of an iterable. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#af4e91486be10ef3a19495cb3d3652721">at</a>(int_&lt;0&gt;, list(0, <span class="charliteral">&#39;1&#39;</span>, 2.0)) == 0);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#af4e91486be10ef3a19495cb3d3652721">at</a>(int_&lt;1&gt;, list(0, <span class="charliteral">&#39;1&#39;</span>, 2.0)) == <span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#af4e91486be10ef3a19495cb3d3652721">at</a>(int_&lt;2&gt;, list(0, <span class="charliteral">&#39;1&#39;</span>, 2.0)) == 2.0);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a322ee5c860b93d6bfb5571a028f5e5b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto drop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the first <code>n</code> elements of an iterable and return the rest. </p>
<p><code>n</code> must be a non-negative <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> representing the number of elements to be dropped from the iterable. If <code>n</code> is greater than the length of the iterable, the returned iterable is empty.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> xs = list(0, <span class="charliteral">&#39;1&#39;</span>, 2.0);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a322ee5c860b93d6bfb5571a028f5e5b2">drop</a>(int_&lt;0&gt;, xs) == xs);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a322ee5c860b93d6bfb5571a028f5e5b2">drop</a>(int_&lt;1&gt;, xs) == list(<span class="charliteral">&#39;1&#39;</span>, 2.0));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a322ee5c860b93d6bfb5571a028f5e5b2">drop</a>(int_&lt;2&gt;, xs) == list(2.0));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a322ee5c860b93d6bfb5571a028f5e5b2">drop</a>(int_&lt;3&gt;, xs) == list());</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a322ee5c860b93d6bfb5571a028f5e5b2">drop</a>(int_&lt;4&gt;, xs) == list());</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aab3e80f4ae219afb61b12201738d28b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto drop_while</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop elements from an iterable up to, but not including, the first element for which the <code>predicate</code> is not satisfied. </p>
<p>Specifically, <code>drop_while</code> returns an iterable containing all the elements of the original iterable except for those in the range delimited by [<code>head</code>, <code>e</code>), where <code>head</code> is the first element and <code>e</code> is the first element for which the <code>predicate</code> is not satisfied.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#aab3e80f4ae219afb61b12201738d28b8">drop_while</a>(_ &lt; int_&lt;0&gt;, range(int_&lt;-3&gt;, int_&lt;6&gt;))</div>
<div class="line">        ==</div>
<div class="line">        range(int_&lt;0&gt;, int_&lt;6&gt;)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a80176fbdfbccc09e902263557eb0984d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto for_each</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an action on each element of the iterable, discarding the result each time. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    std::stringstream ss;</div>
<div class="line">    <a class="code" href="group__typeclasses.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>(list(0, <span class="charliteral">&#39;1&#39;</span>, <span class="stringliteral">&quot;234&quot;</span>, 5.5), [&amp;](<span class="keyword">auto</span> x) {</div>
<div class="line">        ss &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    assert(ss.str() == <span class="stringliteral">&quot;0 1 234 5.5 &quot;</span>);</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>This should probably be in a future <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_traversable" title="Data structures that can be traversed from left to right. ">Traversable</a></code> type class. </dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_list" id="structboost_1_1hana_1_1_list"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::List</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>General purpose index-based sequence. </p>
<hr/>
<h2>Instance of (as a data type)</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_iterable" title="Data structures allowing external iteration. ">Iterable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_foldable" title="Data structures that can be folded, i.e. summarized into a single value. ">Foldable</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_traversable" title="Data structures that can be traversed from left to right. ">Traversable</a></code>, and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> </p><hr/>
<h2>Laws (as a type class)</h2>
<p>For any two <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code>s <code>x</code> and <code>y</code>, </p><p class="formulaDsp">
\begin{align*} x = y \iff \tt{to&lt;List&gt;(x)} = \tt{to&lt;List&gt;(y)} \end{align*}
</p>
<p> This is basically saying that all <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> instances are isomorphic, and it therefore makes sense to define comparison for any two <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code>s. </p><hr/>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd><ul>
<li>It might be possible to optimize the implementation of homogeneous lists using an array.</li>
<li>How to implement iterate and repeat?</li>
<li>We could provide automatic unit testing for any instance because we have the isomorphisms.</li>
<li>There is a strong relationship between this and <code>MonadPlus</code>. Actually, they might be just the same. Check this out.</li>
<li>Implement the following methods:<ul>
<li><code>intersperse</code>, <code>intercalate</code>, <code>transpose</code>, <code>subsequences</code></li>
<li><code>split_at</code>, <code>span</code>, <code>break</code>, <code>group_by</code>, <code>group</code>, <code>inits</code>, <code>tails</code></li>
</ul>
</li>
<li>Consider implementing the following methods:<ul>
<li><code>nub_by</code>, <code>nub</code>, <code>delete_by</code>, <code>insert</code></li>
<li><code>set_difference_by</code>, <code>set_union_by</code>, <code>set_intersection_by</code> </li>
</ul>
</li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a7d7c9b8e94dfcac46c7427a9b82e3225"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a></td></tr>
<tr class="memdesc:a7d7c9b8e94dfcac46c7427a9b82e3225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code>xs...</code>.  <a href="#a7d7c9b8e94dfcac46c7427a9b82e3225">More...</a><br /></td></tr>
<tr class="separator:a7d7c9b8e94dfcac46c7427a9b82e3225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a></td></tr>
<tr class="memdesc:a30a6926751dfcafbe2bb67738e2da3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two lists together.  <a href="#a30a6926751dfcafbe2bb67738e2da3c4">More...</a><br /></td></tr>
<tr class="separator:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51732ddadf982e47f5757b092294df12"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a></td></tr>
<tr class="memdesc:a51732ddadf982e47f5757b092294df12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to the head of a list.  <a href="#a51732ddadf982e47f5757b092294df12">More...</a><br /></td></tr>
<tr class="separator:a51732ddadf982e47f5757b092294df12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929370eddd43bb1a4a11b00a7880eadb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a></td></tr>
<tr class="memdesc:a929370eddd43bb1a4a11b00a7880eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list containing only the elements satisfying the <code>predicate</code>.  <a href="#a929370eddd43bb1a4a11b00a7880eadb">More...</a><br /></td></tr>
<tr class="separator:a929370eddd43bb1a4a11b00a7880eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733fdb2e8686033466beea8323e53a26"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a733fdb2e8686033466beea8323e53a26">init</a></td></tr>
<tr class="memdesc:a733fdb2e8686033466beea8323e53a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of a non-empty list.  <a href="#a733fdb2e8686033466beea8323e53a26">More...</a><br /></td></tr>
<tr class="separator:a733fdb2e8686033466beea8323e53a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28529f82a678e8814fe6224f626115f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28529f82a678e8814fe6224f626115f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr list_detail::into&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a28529f82a678e8814fe6224f626115f3">into</a></td></tr>
<tr class="memdesc:a28529f82a678e8814fe6224f626115f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> with the given elements in it.  <a href="#a28529f82a678e8814fe6224f626115f3">More...</a><br /></td></tr>
<tr class="separator:a28529f82a678e8814fe6224f626115f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e654b583265053e4dde63fff0c0aea"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04e654b583265053e4dde63fff0c0aea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04e654b583265053e4dde63fff0c0aea"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a04e654b583265053e4dde63fff0c0aea">nil</a></td></tr>
<tr class="memdesc:a04e654b583265053e4dde63fff0c0aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty list. <br /></td></tr>
<tr class="separator:a04e654b583265053e4dde63fff0c0aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b65dd69bb016d647801718e840816"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a788b65dd69bb016d647801718e840816">partition</a></td></tr>
<tr class="memdesc:a788b65dd69bb016d647801718e840816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a list based on a <code>predicate</code>.  <a href="#a788b65dd69bb016d647801718e840816">More...</a><br /></td></tr>
<tr class="separator:a788b65dd69bb016d647801718e840816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a></td></tr>
<tr class="memdesc:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all the permutations of the given list.  <a href="#a45ec7767d19eb7eaabb71ead3796a7f1">More...</a><br /></td></tr>
<tr class="separator:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4471413ccc3835db5e48658683b8aba0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a4471413ccc3835db5e48658683b8aba0">reverse</a></td></tr>
<tr class="memdesc:a4471413ccc3835db5e48658683b8aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a list.  <a href="#a4471413ccc3835db5e48658683b8aba0">More...</a><br /></td></tr>
<tr class="separator:a4471413ccc3835db5e48658683b8aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb039a3d46931ef17fef56c77d8256c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a></td></tr>
<tr class="memdesc:adfb039a3d46931ef17fef56c77d8256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldl</code>, but returns a list of reduced values from the left.  <a href="#adfb039a3d46931ef17fef56c77d8256c">More...</a><br /></td></tr>
<tr class="separator:adfb039a3d46931ef17fef56c77d8256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62411eb57e86f3cb7394f22fd3651355"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a></td></tr>
<tr class="memdesc:a62411eb57e86f3cb7394f22fd3651355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanl</code> that has no starting value argument.  <a href="#a62411eb57e86f3cb7394f22fd3651355">More...</a><br /></td></tr>
<tr class="separator:a62411eb57e86f3cb7394f22fd3651355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb725e66aedc0c19c38b38a00302abf4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a></td></tr>
<tr class="memdesc:abb725e66aedc0c19c38b38a00302abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>foldr</code>, but returns a list of reduced values from the right.  <a href="#abb725e66aedc0c19c38b38a00302abf4">More...</a><br /></td></tr>
<tr class="separator:abb725e66aedc0c19c38b38a00302abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5948df39fe904d509f1bb073d53e3965"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a></td></tr>
<tr class="memdesc:a5948df39fe904d509f1bb073d53e3965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>scanr</code> that has no starting value argument.  <a href="#a5948df39fe904d509f1bb073d53e3965">More...</a><br /></td></tr>
<tr class="separator:a5948df39fe904d509f1bb073d53e3965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95183c155c6180b31d4965aa203957d0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a></td></tr>
<tr class="memdesc:a95183c155c6180b31d4965aa203957d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to the end of a list.  <a href="#a95183c155c6180b31d4965aa203957d0">More...</a><br /></td></tr>
<tr class="separator:a95183c155c6180b31d4965aa203957d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1454689bf6d2264bc428dc1d039db"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a58c1454689bf6d2264bc428dc1d039db">sort</a></td></tr>
<tr class="memdesc:a58c1454689bf6d2264bc428dc1d039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list based on the <code>less</code> strict weak ordering.  <a href="#a58c1454689bf6d2264bc428dc1d039db">More...</a><br /></td></tr>
<tr class="separator:a58c1454689bf6d2264bc428dc1d039db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a></td></tr>
<tr class="memdesc:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list based on the given <code>predicate</code>.  <a href="#a6ed2907b48fcba3dd1059b4b0bfde624">More...</a><br /></td></tr>
<tr class="separator:a6ed2907b48fcba3dd1059b4b0bfde624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20028c5115dcf38063d322f27b4ee1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a></td></tr>
<tr class="memdesc:a2c20028c5115dcf38063d322f27b4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first <code>n</code> elements of a list.  <a href="#a2c20028c5115dcf38063d322f27b4ee1">More...</a><br /></td></tr>
<tr class="separator:a2c20028c5115dcf38063d322f27b4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a></td></tr>
<tr class="memdesc:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements until the <code>predicate</code> is satisfied.  <a href="#a27aa67fa9ffc3d89b23a6dce018013d4">More...</a><br /></td></tr>
<tr class="separator:a27aa67fa9ffc3d89b23a6dce018013d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86916c5c62a42f01f85450b366ef6eff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a></td></tr>
<tr class="memdesc:a86916c5c62a42f01f85450b366ef6eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements while the <code>predicate</code> is satisfied.  <a href="#a86916c5c62a42f01f85450b366ef6eff">More...</a><br /></td></tr>
<tr class="separator:a86916c5c62a42f01f85450b366ef6eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b66272057350060d1c00e00d726ac23"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a3b66272057350060d1c00e00d726ac23"><td class="memTemplItemLeft" align="right" valign="top">constexpr list_detail::unfoldl&lt; L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a3b66272057350060d1c00e00d726ac23">unfoldl</a></td></tr>
<tr class="memdesc:a3b66272057350060d1c00e00d726ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldl</code> for lists.  <a href="#a3b66272057350060d1c00e00d726ac23">More...</a><br /></td></tr>
<tr class="separator:a3b66272057350060d1c00e00d726ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9393472189e8d49e2bc8a9e7730b7b60"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a9393472189e8d49e2bc8a9e7730b7b60"><td class="memTemplItemLeft" align="right" valign="top">constexpr list_detail::unfoldr&lt; L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a9393472189e8d49e2bc8a9e7730b7b60">unfoldr</a></td></tr>
<tr class="memdesc:a9393472189e8d49e2bc8a9e7730b7b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual to <code>foldr</code> for lists.  <a href="#a9393472189e8d49e2bc8a9e7730b7b60">More...</a><br /></td></tr>
<tr class="separator:a9393472189e8d49e2bc8a9e7730b7b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5308d966fbf95d317511a706d6d20a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#abe5308d966fbf95d317511a706d6d20a">unzip</a></td></tr>
<tr class="memdesc:abe5308d966fbf95d317511a706d6d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzip a list of lists.  <a href="#abe5308d966fbf95d317511a706d6d20a">More...</a><br /></td></tr>
<tr class="separator:abe5308d966fbf95d317511a706d6d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a></td></tr>
<tr class="memdesc:a23b6ac9e78577d70b9108a80e6b1534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one list or more.  <a href="#a23b6ac9e78577d70b9108a80e6b1534c">More...</a><br /></td></tr>
<tr class="separator:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a></td></tr>
<tr class="memdesc:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one list or more with a given function.  <a href="#a5eadaf63535ebb8cdd8d9e4c16b9bacd">More...</a><br /></td></tr>
<tr class="separator:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a7d7c9b8e94dfcac46c7427a9b82e3225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto list</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> ...xs) {</div>
<div class="line">        <span class="keyword">auto</span> storage = [=](<span class="keyword">auto</span> f) { <span class="keywordflow">return</span> f(xs...); };</div>
<div class="line">        <span class="keywordflow">return</span> list_detail::list&lt;decltype(storage)&gt;{storage};</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> containing <code>xs...</code>. </p>
<p>The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> data type is a general purpose compile-time heterogeneous sequence.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Consider having <code>list_of&lt;<a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a>&gt;</code>, <code>list_of&lt;<a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a>&gt;</code>, ..., <code>list_of&lt;Anything&gt;</code>, with <code>list == list_of&lt;Anything&gt;</code>. It does not fix the problem of partial type classes (e.g. <code>MplVector</code> is not <em>actually</em> a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code>), but at least we remove <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type_list" title="List containing Types only. ">TypeList</a></code> and <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integer_list" title="List containing Integrals of the same underlying type only. ">IntegerList</a></code>, which are arguably ugly. </dd></dl>

</div>
</div>
<a class="anchor" id="a30a6926751dfcafbe2bb67738e2da3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto concat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate two lists together. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, 4_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a51732ddadf982e47f5757b092294df12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cons</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepend an element to the head of a list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>()) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(1, <a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(<span class="charliteral">&#39;2&#39;</span>, <a class="code" href="group__typeclasses.html#a51732ddadf982e47f5757b092294df12">cons</a>(<span class="stringliteral">&quot;3&quot;</span>, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>()))) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a929370eddd43bb1a4a11b00a7880eadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list containing only the elements satisfying the <code>predicate</code>. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(trait_&lt;std::is_integral&gt;, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2.0, 3, 4.0)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a733fdb2e8686033466beea8323e53a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of a non-empty list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a733fdb2e8686033466beea8323e53a26">init</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>());</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a733fdb2e8686033466beea8323e53a26">init</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>, 4_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;3&quot;</span>));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a28529f82a678e8814fe6224f626115f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr list_detail::into&lt;T&gt; into</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> with the given elements in it. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(unpack(into&lt;List&gt;, just(3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(unpack(into&lt;List&gt;, nothing) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>());</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(unpack(into&lt;List&gt;, std::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a788b65dd69bb016d647801718e840816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition a list based on a <code>predicate</code>. </p>
<p>Specifically, returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> whose first element is a list of the elements satisfying the predicate, and whose second element is a list of the elements that do not satisfy the predicate.</p>
<dl class="section note"><dt>Note</dt><dd>The predicate must return an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>.</dd></dl>
<h3>Example 1</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % int_&lt;2&gt; != int_&lt;0&gt;;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a788b65dd69bb016d647801718e840816">partition</a>(odd, integer_list&lt;int, 1, 2, 3, 4, 5, 6, 7&gt;)</div>
<div class="line">        ==</div>
<div class="line">        pair(</div>
<div class="line">            integer_list&lt;int, 1, 3, 5, 7&gt;,</div>
<div class="line">            integer_list&lt;int, 2, 4, 6&gt;</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment --> <h3>Example 2</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a788b65dd69bb016d647801718e840816">partition</a>(trait&lt;std::is_floating_point&gt;, type_list&lt;void, int, float, char, double&gt;)</div>
<div class="line">        ==</div>
<div class="line">        pair(</div>
<div class="line">            type_list&lt;float, double&gt;,</div>
<div class="line">            type_list&lt;void, int, char&gt;</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a45ec7767d19eb7eaabb71ead3796a7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto permutations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of all the permutations of the given list. </p>
<p>The permutations are not guaranteed to be in any specific order.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> is_permutation_of = curry&lt;2&gt;([](<span class="keyword">auto</span> xs, <span class="keyword">auto</span> perm) {</div>
<div class="line">        <span class="keywordflow">return</span> any(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> == perm, <a class="code" href="group__typeclasses.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a>(xs));</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        all(is_permutation_of(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0)),</div>
<div class="line">            <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;1&#39;</span>, 3.0, 2),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, <span class="charliteral">&#39;1&#39;</span>, 3.0),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, 3.0, <span class="charliteral">&#39;1&#39;</span>),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.0, <span class="charliteral">&#39;1&#39;</span>, 2),</div>
<div class="line">                <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.0, 2, <span class="charliteral">&#39;1&#39;</span>)</div>
<div class="line">            )</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.permutations.time.png" alt="benchmark.list.permutations.time.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>Implementation taken from <a href="http://stackoverflow.com/a/2184129/627587">http://stackoverflow.com/a/2184129/627587</a>.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>We got a performance problem here. Generating the permutations of a list of more than 3 elements starts taking a long time (&gt;6s). </dd></dl>

</div>
</div>
<a class="anchor" id="a4471413ccc3835db5e48658683b8aba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse a list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a4471413ccc3835db5e48658683b8aba0">reverse</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, <span class="charliteral">&#39;2&#39;</span>, 1));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adfb039a3d46931ef17fef56c77d8256c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>foldl</code>, but returns a list of reduced values from the left. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#adfb039a3d46931ef17fef56c77d8256c">scanl</a>(show, 1, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        1,</div>
<div class="line">        <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(((1 + 2) + 3) + 4)&quot;</span></div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanl.time.png" alt="benchmark.list.scanl.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a62411eb57e86f3cb7394f22fd3651355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanl1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <code>scanl</code> that has no starting value argument. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#a62411eb57e86f3cb7394f22fd3651355">scanl1</a>(show, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        1,</div>
<div class="line">        <span class="stringliteral">&quot;(1 + 2)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;((1 + 2) + 3)&quot;</span></div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanl1.time.png" alt="benchmark.list.scanl1.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="abb725e66aedc0c19c38b38a00302abf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>foldr</code>, but returns a list of reduced values from the right. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#abb725e66aedc0c19c38b38a00302abf4">scanr</a>(show, 4, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        <span class="stringliteral">&quot;(1 + (2 + (3 + 4)))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(2 + (3 + 4))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(3 + 4)&quot;</span>,</div>
<div class="line">        4</div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanr.time.png" alt="benchmark.list.scanr.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a5948df39fe904d509f1bb073d53e3965"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scanr1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <code>scanr</code> that has no starting value argument. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> (std::ostringstream{} &lt;&lt; x).str(); };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> show = [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    assert(<a class="code" href="group__typeclasses.html#a5948df39fe904d509f1bb073d53e3965">scanr1</a>(show, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(</div>
<div class="line">        <span class="stringliteral">&quot;(1 + (2 + 3))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;(2 + 3)&quot;</span>,</div>
<div class="line">        <span class="charliteral">&#39;3&#39;</span></div>
<div class="line">    ));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="benchmark.list.scanr1.time.png" alt="benchmark.list.scanr1.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a95183c155c6180b31d4965aa203957d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto snoc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an element to the end of a list. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(), 1) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>), 3.3) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a95183c155c6180b31d4965aa203957d0">snoc</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(), 1), <span class="charliteral">&#39;2&#39;</span>), 3.3) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a58c1454689bf6d2264bc428dc1d039db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a list based on the <code>less</code> strict weak ordering. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1_c, -2_c, 3_c, 0_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(-2_c, 0_c, 1_c, 3_c)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ed2907b48fcba3dd1059b4b0bfde624"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort_by</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a list based on the given <code>predicate</code>. </p>
<p>The predicate must be a <a href="http://en.wikipedia.org/wiki/Strict_weak_ordering#Strict_weak_orderings">strict weak ordering</a>. The sort is guaranteed to be stable.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a6ed2907b48fcba3dd1059b4b0bfde624">sort_by</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>&gt;<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1_c, -2_c, 3_c, 0_c)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3_c, 1_c, 0_c, -2_c)</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c20028c5115dcf38063d322f27b4ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first <code>n</code> elements of a list. </p>
<p><code>n</code> must be a non-negative <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> representing the number of elements to keep. If <code>n</code> is greater than the length of the list, the whole list is returned.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(0_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>());</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(1_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(2_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(3_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2c20028c5115dcf38063d322f27b4ee1">take</a>(4_c, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27aa67fa9ffc3d89b23a6dce018013d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_until</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take elements until the <code>predicate</code> is satisfied. </p>
<p>This is equivalent to <code>take_while</code> with a negated predicate.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a27aa67fa9ffc3d89b23a6dce018013d4">take_until</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> &lt; 2_c, integer_list&lt;int, 3, 2, 1, 0&gt;) == integer_list&lt;int, 3, 2&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a86916c5c62a42f01f85450b366ef6eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_while</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take elements while the <code>predicate</code> is satisfied. </p>
<p>Specifically, returns the longest prefix of a list in which all elements satisfy the given predicate. The predicate must return an <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> &lt; 2_c, integer_list&lt;int, 0, 1, 2, 3&gt;) == integer_list&lt;int, 0, 1&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3b66272057350060d1c00e00d726ac23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr list_detail::unfoldl&lt;L&gt; unfoldl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dual to <code>foldl</code> for lists. </p>
<p>While <code>foldl</code> reduces a list to a summary value, <code>unfoldl</code> builds a list from a seed value and a function. The function takes the initial value and returns <code>nothing</code> if it is done producing the list, and <code>just(P(init, elem))</code> otherwise, where <code>P</code> is an arbitrary <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> constructor and <code>elem</code> is the produced element which is appended to the list and <code>init</code> is the new initial value used in a recursive call to the function.</p>
<p>In some cases, <code>unfoldl</code> can undo a <code>foldl</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="group__typeclasses.html#a3b66272057350060d1c00e00d726ac23">unfoldl</a>(g, foldl(f, z, xs))</div>
</div><!-- fragment --><p> if the following holds </p><div class="fragment"><div class="line">g(f(y, x)) == just(pair(y, x))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x - int_&lt;1&gt;, x)));</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        unfoldl&lt;IntegerList&gt;(f, int_&lt;10&gt;) == integer_list&lt;int, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9393472189e8d49e2bc8a9e7730b7b60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr list_detail::unfoldr&lt;L&gt; unfoldr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dual to <code>foldr</code> for lists. </p>
<p>While <code>foldr</code> reduces a list to a summary value, <code>unfoldr</code> builds a list from a seed value and a function. The function takes the initial value and returns <code>nothing</code> if it is done producing the list, and <code>just(P(elem, init))</code> otherwise, where <code>P</code> is an arbitrary <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> constructor and <code>elem</code> is the produced element which is prepended to the list and <code>init</code> is the new initial value used in a recursive call to the function.</p>
<p>In some cases, <code>unfoldr</code> can undo a <code>foldr</code> operation: </p><div class="fragment"><div class="line"><a class="code" href="group__typeclasses.html#a9393472189e8d49e2bc8a9e7730b7b60">unfoldr</a>(g, foldr(f, z, xs))</div>
</div><!-- fragment --><p> if the following holds </p><div class="fragment"><div class="line">g(f(x, y)) == just(pair(x, y))</div>
<div class="line">g(z) == nothing</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(x == int_&lt;0&gt;, nothing, just(pair(x, x - int_&lt;1&gt;)));</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        unfoldr&lt;IntegerList&gt;(f, int_&lt;10&gt;) == integer_list&lt;int, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&gt;</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe5308d966fbf95d317511a706d6d20a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unzip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unzip a list of lists. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6)))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;4&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;2&#39;</span>, 5.5), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, 6))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#abe5308d966fbf95d317511a706d6d20a">unzip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;4&#39;</span>, 5.5, 6, <span class="stringliteral">&quot;ignored&quot;</span>)))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;4&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;2&#39;</span>, 5.5), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3.3, 6))</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23b6ac9e78577d70b9108a80e6b1534c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip one list or more. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;a&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, 3.3))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;a&#39;</span>, 3.3))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, <span class="charliteral">&#39;a&#39;</span>), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(2, 3.3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(3, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2, 3), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(<span class="charliteral">&#39;a&#39;</span>, 3.3, <span class="charliteral">&#39;c&#39;</span>))</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5eadaf63535ebb8cdd8d9e4c16b9bacd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip_with</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zip one list or more with a given function. </p>
<p>Specifically, returns a list whose i-th element is <code>f(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the i-th element of the k-th list passed as an argument. The returned list stops when the shortest input sequence is exhausted.</p>
<p>In other words, <code>zip_with(f, s1, ..., sn)</code> is a list of the form </p><div class="fragment"><div class="line">f(s1[0], ..., sn[0])</div>
<div class="line">f(s1[1], ..., sn[1])</div>
<div class="line">...</div>
<div class="line">f(s1[k], ..., sn[k])</div>
</div><!-- fragment --><p> where <code>k</code> is the length of the shortest list.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> * <a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a>, <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(1, 2, 3, 4), <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(5, 6, 7, 8, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">        ==</div>
<div class="line">        <a class="code" href="group__typeclasses.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>(5, 12, 21, 32)</div>
<div class="line">    );</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd><ul>
<li>Consider allowing only two lists and achieving the variadic behavior in some other way. This would make it possible to automatically curry <code>zip_with</code>. It might be possible to achieve the variadic behavior with e.g. <a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a> Functors? </li>
</ul>
</dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_logical" id="structboost_1_1hana_1_1_logical"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Logical</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> type class is for data types acting like a boolean. </p>
<hr/>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd><ul>
<li>Use a non-naive implementation for variadic <code>and_</code> and <code>or_</code>.</li>
<li>Consider making this a real boolean algebra.</li>
</ul>
</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>We don't short-circuit right now. Don't forget to change the examples and unit tests when that's implemented. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a06927a2badb729e1522b9030d18234df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06927a2badb729e1522b9030d18234df"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a06927a2badb729e1522b9030d18234df">if_</a></td></tr>
<tr class="memdesc:a06927a2badb729e1522b9030d18234df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally return one of two values based on a condition. <br /></td></tr>
<tr class="separator:a06927a2badb729e1522b9030d18234df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f92ff5d73f8ebd7e9eb61142b2e68e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a></td></tr>
<tr class="memdesc:a97f92ff5d73f8ebd7e9eb61142b2e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally execute one of two branches based on a condition.  <a href="#a97f92ff5d73f8ebd7e9eb61142b2e68e">More...</a><br /></td></tr>
<tr class="separator:a97f92ff5d73f8ebd7e9eb61142b2e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5a578f274b7513e5008eab698fa5bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c5a578f274b7513e5008eab698fa5bc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a3c5a578f274b7513e5008eab698fa5bc">not_</a></td></tr>
<tr class="memdesc:a3c5a578f274b7513e5008eab698fa5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>. <br /></td></tr>
<tr class="separator:a3c5a578f274b7513e5008eab698fa5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c3469073cdefeecc1a6d4cfaf89ca0"><td class="memItemLeft" align="right" valign="top">constexpr _and&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a54c3469073cdefeecc1a6d4cfaf89ca0">and_</a></td></tr>
<tr class="memdesc:a54c3469073cdefeecc1a6d4cfaf89ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the arguments are true-valued.  <a href="#a54c3469073cdefeecc1a6d4cfaf89ca0">More...</a><br /></td></tr>
<tr class="separator:a54c3469073cdefeecc1a6d4cfaf89ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68b6f5ded3c6bcd17a6c69bce0df2df"><td class="memItemLeft" align="right" valign="top">constexpr _or&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ac68b6f5ded3c6bcd17a6c69bce0df2df">or_</a></td></tr>
<tr class="memdesc:ac68b6f5ded3c6bcd17a6c69bce0df2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any of the arguments is true-valued.  <a href="#ac68b6f5ded3c6bcd17a6c69bce0df2df">More...</a><br /></td></tr>
<tr class="separator:ac68b6f5ded3c6bcd17a6c69bce0df2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468ed0f009350af247fe55f999d66bb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a468ed0f009350af247fe55f999d66bb9"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a468ed0f009350af247fe55f999d66bb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a468ed0f009350af247fe55f999d66bb9">operator&amp;&amp;</a> (X x, Y y)</td></tr>
<tr class="memdesc:a468ed0f009350af247fe55f999d66bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>and_</code>. <br /></td></tr>
<tr class="separator:a468ed0f009350af247fe55f999d66bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd259792d32f024662e755212eb9ef3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2cd259792d32f024662e755212eb9ef3"></a>
template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a2cd259792d32f024662e755212eb9ef3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a2cd259792d32f024662e755212eb9ef3">operator||</a> (X x, Y y)</td></tr>
<tr class="memdesc:a2cd259792d32f024662e755212eb9ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>or_</code>. <br /></td></tr>
<tr class="separator:a2cd259792d32f024662e755212eb9ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7927554309add75c94b005d6803a1f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac7927554309add75c94b005d6803a1f6"></a>
template&lt;typename X &gt; </td></tr>
<tr class="memitem:ac7927554309add75c94b005d6803a1f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ac7927554309add75c94b005d6803a1f6">operator!</a> (X x)</td></tr>
<tr class="memdesc:ac7927554309add75c94b005d6803a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>not_</code>. <br /></td></tr>
<tr class="separator:ac7927554309add75c94b005d6803a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a97f92ff5d73f8ebd7e9eb61142b2e68e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto eval_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally execute one of two branches based on a condition. </p>
<p>The selected branch will be invoked with an identity function, wich allows making types and values dependent inside a lambda and achieve a lazy-like behavior. However, type instantiation laziness can only be achieved with <code><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_integral" title="Represents a compile-time value of an integral type. ">Integral</a></code> conditions or equivalent.</p>
<h3>Example (purely compile-time condition)</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> safe_make_unsigned = [](<span class="keyword">auto</span> t) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__typeclasses.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a>(trait&lt;std::is_integral&gt;(t),</div>
<div class="line">            [=](<span class="keyword">auto</span> <span class="keywordtype">id</span>) { <span class="keywordflow">return</span> <a class="code" href="group___functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(template_&lt;std::make_unsigned_t&gt;)(t); },</div>
<div class="line">            <a class="code" href="group___functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(t)</div>
<div class="line">        );</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(safe_make_unsigned(type&lt;void&gt;) == type&lt;void&gt;);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(safe_make_unsigned(type&lt;int&gt;) == type&lt;unsigned int&gt;);</div>
</div><!-- fragment --> <h3>Example (runtime or <code>constexpr</code> condition)</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> safe_divide = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__typeclasses.html#a97f92ff5d73f8ebd7e9eb61142b2e68e">eval_if</a>(y == 0,</div>
<div class="line">            [=](<span class="keyword">auto</span>) { <span class="keywordflow">return</span> 0; },</div>
<div class="line">            [=](<span class="keyword">auto</span> <a class="code" href="group___functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>) { <span class="keywordflow">return</span> <a class="code" href="group___functional.html#gaef38cf34324c8edbd3597ae71811d00d">id</a>(x) / y; }</div>
<div class="line">        );</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(safe_divide(6, 3) == 2);</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(safe_divide(6, 0) == 0);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a54c3469073cdefeecc1a6d4cfaf89ca0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _and and_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether all the arguments are true-valued. </p>
<p><code>and_</code> can be called with one argument or more. When called with two arguments, <code>and_</code> dispatches to the type class implementation. Otherwise, </p><div class="fragment"><div class="line"><a class="code" href="group__typeclasses.html#a54c3469073cdefeecc1a6d4cfaf89ca0">and_</a>(x) == x</div>
<div class="line"><a class="code" href="group__typeclasses.html#a54c3469073cdefeecc1a6d4cfaf89ca0">and_</a>(x, y, ...z) == <a class="code" href="group__typeclasses.html#a54c3469073cdefeecc1a6d4cfaf89ca0">and_</a>(x, <a class="code" href="group__typeclasses.html#a54c3469073cdefeecc1a6d4cfaf89ca0">and_</a>(y, z...))</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a54c3469073cdefeecc1a6d4cfaf89ca0">and_</a>(true_, true_, true_, true_));</div>
<div class="line">    <span class="comment">// BOOST_HANA_STATIC_ASSERT(!and_(true_, false_, &quot;never evaluated&quot;));</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac68b6f5ded3c6bcd17a6c69bce0df2df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _or or_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether any of the arguments is true-valued. </p>
<p><code>or_</code> can be called with one argument or more. When called with two arguments, <code>or_</code> dispatches to the type class implementation. Otherwise, </p><div class="fragment"><div class="line"><a class="code" href="group__typeclasses.html#ac68b6f5ded3c6bcd17a6c69bce0df2df">or_</a>(x) == x</div>
<div class="line"><a class="code" href="group__typeclasses.html#ac68b6f5ded3c6bcd17a6c69bce0df2df">or_</a>(x, y, ...z) == <a class="code" href="group__typeclasses.html#ac68b6f5ded3c6bcd17a6c69bce0df2df">or_</a>(x, <a class="code" href="group__typeclasses.html#ac68b6f5ded3c6bcd17a6c69bce0df2df">or_</a>(y, z...))</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="group__typeclasses.html#ac68b6f5ded3c6bcd17a6c69bce0df2df">or_</a>(false_, false_, false_));</div>
<div class="line">    <span class="comment">// BOOST_HANA_STATIC_ASSERT(or_(false_, true_, &quot;never evaluated&quot;));</span></div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_monad" id="structboost_1_1hana_1_1_monad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Monad</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code>s are <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>s with the ability to flatten values that were lifted more than once. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4df7d83b8aeb3bcf99e5675f69af4090"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4df7d83b8aeb3bcf99e5675f69af4090"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a4df7d83b8aeb3bcf99e5675f69af4090">bind</a></td></tr>
<tr class="memdesc:a4df7d83b8aeb3bcf99e5675f69af4090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function returning a monad to the value(s) inside a monad. <br /></td></tr>
<tr class="separator:a4df7d83b8aeb3bcf99e5675f69af4090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc7efb0044a87a21f663b1a151dac56"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#abfc7efb0044a87a21f663b1a151dac56">then</a></td></tr>
<tr class="memdesc:abfc7efb0044a87a21f663b1a151dac56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially compose two monadic actions, discarding any value produced by the first.  <a href="#abfc7efb0044a87a21f663b1a151dac56">More...</a><br /></td></tr>
<tr class="separator:abfc7efb0044a87a21f663b1a151dac56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45985423d0658e88f0403773146af110"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45985423d0658e88f0403773146af110"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a45985423d0658e88f0403773146af110">flatten</a></td></tr>
<tr class="memdesc:a45985423d0658e88f0403773146af110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten two levels of monadic wrapping into a single level. <br /></td></tr>
<tr class="separator:a45985423d0658e88f0403773146af110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcac3880cd4aa434648994ee694c6ca"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:aebcac3880cd4aa434648994ee694c6ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr monad_detail::tap&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aebcac3880cd4aa434648994ee694c6ca">tap</a></td></tr>
<tr class="memdesc:aebcac3880cd4aa434648994ee694c6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tap inside a monadic chain.  <a href="#aebcac3880cd4aa434648994ee694c6ca">More...</a><br /></td></tr>
<tr class="separator:aebcac3880cd4aa434648994ee694c6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d5e6959ae78bd0ac649e2d955e378e"><td class="memTemplParams" colspan="2">template&lt;typename M , typename F &gt; </td></tr>
<tr class="memitem:a25d5e6959ae78bd0ac649e2d955e378e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a25d5e6959ae78bd0ac649e2d955e378e">operator|</a> (M m, F f)</td></tr>
<tr class="memdesc:a25d5e6959ae78bd0ac649e2d955e378e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>bind</code>.  <a href="#a25d5e6959ae78bd0ac649e2d955e378e">More...</a><br /></td></tr>
<tr class="separator:a25d5e6959ae78bd0ac649e2d955e378e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="abfc7efb0044a87a21f663b1a151dac56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto then</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sequentially compose two monadic actions, discarding any value produced by the first. </p>
<p>This is equivalent to Haskell's <code>&gt;&gt;</code>. </p>

</div>
</div>
<a class="anchor" id="aebcac3880cd4aa434648994ee694c6ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr monad_detail::tap&lt;M&gt; tap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tap inside a monadic chain. </p>
<p>Specifically, <code>tap&lt;M&gt;(f)(x)</code> performs <code>f(x)</code> and returns <code>lift&lt;M&gt;(x)</code>. Combined with the law saying that <code>bind(m, lift&lt;M&gt;) == m</code>, this provides a way of executing an action inside a monadic chain without influencing its result.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    std::stringstream before, after;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> xs = list(1, 2, 3)</div>
<div class="line">        | tap&lt;List&gt;([&amp;](<span class="keyword">auto</span> x) { before &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>; })</div>
<div class="line">        | [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> list(x, -x); }</div>
<div class="line">        | tap&lt;List&gt;([&amp;](<span class="keyword">auto</span> x) { after &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>; });</div>
<div class="line"></div>
<div class="line">    assert(before.str() == <span class="stringliteral">&quot;1 2 3 &quot;</span>);</div>
<div class="line">    assert(after.str() == <span class="stringliteral">&quot;1 -1 2 -2 3 -3 &quot;</span>);</div>
<div class="line">    assert(xs == list(1, -1, 2, -2, 3, -3));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a25d5e6959ae78bd0ac649e2d955e378e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator| </td>
          <td>(</td>
          <td class="paramtype">M&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <code>bind</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This was preferred over <code>&gt;&gt;=</code> because <code>&gt;&gt;=</code> is right associative, which makes it impossible to chain computations. </dd></dl>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_orderable" id="structboost_1_1hana_1_1_orderable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Orderable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_orderable" title="The Orderable type class is used for data types defining a strict weak ordering. ">Orderable</a></code> type class is used for data types defining a <a href="http://en.wikipedia.org/wiki/Strict_weak_ordering">strict weak ordering</a>. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad835070573ed8da3e607eafa824cd7e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad835070573ed8da3e607eafa824cd7e5"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ad835070573ed8da3e607eafa824cd7e5">less</a></td></tr>
<tr class="memdesc:ad835070573ed8da3e607eafa824cd7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> is less than <code>y</code>. <br /></td></tr>
<tr class="separator:ad835070573ed8da3e607eafa824cd7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8012cbd416c2067be764046dcd0c2a23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8012cbd416c2067be764046dcd0c2a23"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a8012cbd416c2067be764046dcd0c2a23">less_equal</a></td></tr>
<tr class="memdesc:a8012cbd416c2067be764046dcd0c2a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> is less than or equal to <code>y</code>. <br /></td></tr>
<tr class="separator:a8012cbd416c2067be764046dcd0c2a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f968a4217ff87b9fdd6c3bbea72bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c9f968a4217ff87b9fdd6c3bbea72bc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a1c9f968a4217ff87b9fdd6c3bbea72bc">greater</a></td></tr>
<tr class="memdesc:a1c9f968a4217ff87b9fdd6c3bbea72bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> is greater than <code>y</code>. <br /></td></tr>
<tr class="separator:a1c9f968a4217ff87b9fdd6c3bbea72bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062300116ac52000449518ec546e65a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a062300116ac52000449518ec546e65a3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a062300116ac52000449518ec546e65a3">greater_equal</a></td></tr>
<tr class="memdesc:a062300116ac52000449518ec546e65a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_logical" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether <code>x</code> is greater than or equal to <code>y</code>. <br /></td></tr>
<tr class="separator:a062300116ac52000449518ec546e65a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10ea2fee24c0a780758f67721bb5bfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af10ea2fee24c0a780758f67721bb5bfa"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#af10ea2fee24c0a780758f67721bb5bfa">min</a></td></tr>
<tr class="memdesc:af10ea2fee24c0a780758f67721bb5bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest of its arguments according to the <code>less</code> ordering. <br /></td></tr>
<tr class="separator:af10ea2fee24c0a780758f67721bb5bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8718f43756efef3953635f34fd67e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fb8718f43756efef3953635f34fd67e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a9fb8718f43756efef3953635f34fd67e">max</a></td></tr>
<tr class="memdesc:a9fb8718f43756efef3953635f34fd67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest of its arguments according to the <code>less</code> ordering. <br /></td></tr>
<tr class="separator:a9fb8718f43756efef3953635f34fd67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc67793cc0d776d85d2d72135c5147d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5fc67793cc0d776d85d2d72135c5147d"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5fc67793cc0d776d85d2d72135c5147d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5fc67793cc0d776d85d2d72135c5147d">operator&lt;</a> (T t, U u)</td></tr>
<tr class="memdesc:a5fc67793cc0d776d85d2d72135c5147d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>less</code>. <br /></td></tr>
<tr class="separator:a5fc67793cc0d776d85d2d72135c5147d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27d042f4f5809c447204b1781f67255"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac27d042f4f5809c447204b1781f67255"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac27d042f4f5809c447204b1781f67255"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ac27d042f4f5809c447204b1781f67255">operator&lt;=</a> (T t, U u)</td></tr>
<tr class="memdesc:ac27d042f4f5809c447204b1781f67255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>less_equal</code>. <br /></td></tr>
<tr class="separator:ac27d042f4f5809c447204b1781f67255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae640ee6e43199763efd8be41adb60cf7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae640ee6e43199763efd8be41adb60cf7"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae640ee6e43199763efd8be41adb60cf7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ae640ee6e43199763efd8be41adb60cf7">operator&gt;</a> (T t, U u)</td></tr>
<tr class="memdesc:ae640ee6e43199763efd8be41adb60cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>greater</code>. <br /></td></tr>
<tr class="separator:ae640ee6e43199763efd8be41adb60cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4a20e687927fa1aaba8ded1151eaa0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d4a20e687927fa1aaba8ded1151eaa0"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6d4a20e687927fa1aaba8ded1151eaa0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a6d4a20e687927fa1aaba8ded1151eaa0">operator&gt;=</a> (T t, U u)</td></tr>
<tr class="memdesc:a6d4a20e687927fa1aaba8ded1151eaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>greater_equal</code>. <br /></td></tr>
<tr class="separator:a6d4a20e687927fa1aaba8ded1151eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structboost_1_1hana_1_1_pair" id="structboost_1_1hana_1_1_pair"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Pair</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Generic container of two elements. </p>
<p>As a type class, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> represents a container of two elements with means to extract each of them separately. Since the instance for <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> is unique up to isomorphism, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> is also a data type instantiating the <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> type class with the only possible instance up to isomorphism.</p>
<h2>Provided instances</h2>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_comparable" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> </p><hr/>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>Provide and document instances for <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_functor" title="Functor represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code>, <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_monad" title="Monads are Applicatives with the ability to flatten values that were lifted more than once...">Monad</a></code> and <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_foldable" title="Data structures that can be folded, i.e. summarized into a single value. ">Foldable</a></code>. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8d15743bd0fcc2cf033ed657e95998c1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a8d15743bd0fcc2cf033ed657e95998c1">pair</a></td></tr>
<tr class="memdesc:a8d15743bd0fcc2cf033ed657e95998c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> with the given elements.  <a href="#a8d15743bd0fcc2cf033ed657e95998c1">More...</a><br /></td></tr>
<tr class="separator:a8d15743bd0fcc2cf033ed657e95998c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6548bd227a06799a2e5abdfd9e9b0b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6548bd227a06799a2e5abdfd9e9b0b9"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a></td></tr>
<tr class="memdesc:ab6548bd227a06799a2e5abdfd9e9b0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element of the pair. <br /></td></tr>
<tr class="separator:ab6548bd227a06799a2e5abdfd9e9b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2111e165329a8ded67dec73f2df4ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d2111e165329a8ded67dec73f2df4ae"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a></td></tr>
<tr class="memdesc:a5d2111e165329a8ded67dec73f2df4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second element of the pair. <br /></td></tr>
<tr class="separator:a5d2111e165329a8ded67dec73f2df4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a8d15743bd0fcc2cf033ed657e95998c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto pair</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <a class="code" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a>, <span class="keyword">auto</span> <a class="code" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> pair_detail::pair&lt;</div>
<div class="line">            decltype(<a class="code" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a>), decltype(<a class="code" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a>)</div>
<div class="line">        &gt;{<a class="code" href="group__typeclasses.html#ab6548bd227a06799a2e5abdfd9e9b0b9">first</a>, <a class="code" href="group__typeclasses.html#a5d2111e165329a8ded67dec73f2df4ae">second</a>};</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Creates a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code> with the given elements. </p>
<p>} </p>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_record" id="structboost_1_1hana_1_1_record"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Record</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_type" title="C++ type represented as a constexpr object. ">Type</a> class for record-like user-defined types. </p>
<p>A record-like type is any type which is fundamentally a <code>struct</code>, regardless of the implementation of its accessors and other similar details.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2014</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/constant.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/detail/constexpr.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/list/instance.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/map.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/pair/instance.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/hana/record/mcd.hpp&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>boost::hana;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The keys can be anything as long as they are compile-time comparable.</span></div>
<div class="line">constexpr <span class="keyword">auto</span> name = constant&lt;decltype(&amp;Person::name), &amp;Person::name&gt;;</div>
<div class="line">constexpr <span class="keyword">auto</span> age = constant&lt;decltype(&amp;Person::age), &amp;Person::age&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>boost { <span class="keyword">namespace </span>hana {</div>
<div class="line">    <span class="keyword">template</span> &lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>Record::instance&lt;Person&gt; : <a class="code" href="structboost_1_1hana_1_1_record_1_1mcd.html">Record::mcd</a> {</div>
<div class="line">        <span class="keyword">static</span> <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> members_impl() {</div>
<div class="line">            <span class="keywordflow">return</span> list(</div>
<div class="line">                pair(name, [](<span class="keyword">auto</span> p) { <span class="keywordflow">return</span> p.name; }),</div>
<div class="line">                pair(age, [](<span class="keyword">auto</span> p) { <span class="keywordflow">return</span> p.age; })</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Person john{<span class="stringliteral">&quot;John&quot;</span>, 30}, bob{<span class="stringliteral">&quot;Bob&quot;</span>, 40};</div>
<div class="line">    assert(equal(john, john));</div>
<div class="line">    assert(not_equal(john, bob));</div>
<div class="line"></div>
<div class="line">    assert(lookup(name, john) == just(<span class="stringliteral">&quot;John&quot;</span>));</div>
<div class="line">    assert(lookup(age, john) == just(30));</div>
<div class="line">    assert(lookup(constant&lt;int, 9&gt;, john) == nothing);</div>
<div class="line"></div>
<div class="line">    assert(to&lt;List&gt;(john) == list(<span class="stringliteral">&quot;John&quot;</span>, 30));</div>
<div class="line">    assert(to&lt;Map&gt;(john) == map(</div>
<div class="line">        pair(name, <span class="stringliteral">&quot;John&quot;</span>),</div>
<div class="line">        pair(age, 30)</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a5ae5ec12bb6524e05cc4750b203c194e"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a5ae5ec12bb6524e05cc4750b203c194e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a5ae5ec12bb6524e05cc4750b203c194e">members</a></td></tr>
<tr class="memdesc:a5ae5ec12bb6524e05cc4750b203c194e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of pairs representing the data structure.  <a href="#a5ae5ec12bb6524e05cc4750b203c194e">More...</a><br /></td></tr>
<tr class="separator:a5ae5ec12bb6524e05cc4750b203c194e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a5ae5ec12bb6524e05cc4750b203c194e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto members</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of pairs representing the data structure. </p>
<p>Specifically, <code>members&lt;R&gt;</code> is a <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_list" title="General purpose index-based sequence. ">List</a></code> of <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_pair" title="Generic container of two elements. ">Pair</a></code>s associating keys to functions, where a pair <code>(k, f)</code> means that the member represented by the key <code>k</code> can be accessed by calling the function <code>f</code> on an object of data type <code>R</code>. </p>

</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_searchable" id="structboost_1_1hana_1_1_searchable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Searchable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data structures that can be searched. </p>
<p><code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_searchable" title="Data structures that can be searched. ">Searchable</a></code>s have a concept of keys and values. Basically, searching is always done on the keys and the result is always the associated value. There is no requirement that the keys and values be different. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a></td></tr>
<tr class="memdesc:a67dd29f7921b76f7d2bd372605f73f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any key of the structure satisfies the <code>predicate</code>.  <a href="#a67dd29f7921b76f7d2bd372605f73f7c">More...</a><br /></td></tr>
<tr class="separator:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc05dc4553467aa0a2235088de41b4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dc05dc4553467aa0a2235088de41b4b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a></td></tr>
<tr class="memdesc:a2dc05dc4553467aa0a2235088de41b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any key of the structure is true-valued. <br /></td></tr>
<tr class="separator:a2dc05dc4553467aa0a2235088de41b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a></td></tr>
<tr class="memdesc:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the keys of the structure satisfy the <code>predicate</code>.  <a href="#a695907e4a3ef7d0e9ab34f5afff709b2">More...</a><br /></td></tr>
<tr class="separator:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd57241c497cbe1a2ce5ac57549080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adadd57241c497cbe1a2ce5ac57549080"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a></td></tr>
<tr class="memdesc:adadd57241c497cbe1a2ce5ac57549080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the keys of the structure are true-valued. <br /></td></tr>
<tr class="separator:adadd57241c497cbe1a2ce5ac57549080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365b793fe547271e48fa719a7f4854d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a9365b793fe547271e48fa719a7f4854d">none</a></td></tr>
<tr class="memdesc:a9365b793fe547271e48fa719a7f4854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether none of the keys of the structure satisfy the <code>predicate</code>.  <a href="#a9365b793fe547271e48fa719a7f4854d">More...</a><br /></td></tr>
<tr class="separator:a9365b793fe547271e48fa719a7f4854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf1dbf83a1d98c62994e207ea18eea8a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a></td></tr>
<tr class="memdesc:abf1dbf83a1d98c62994e207ea18eea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether none of the keys of the structure is true-valued. <br /></td></tr>
<tr class="separator:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a></td></tr>
<tr class="memdesc:a04e413e4acd1dac89e442df2f30f3e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the key occurs in the structure.  <a href="#a04e413e4acd1dac89e442df2f30f3e2d">More...</a><br /></td></tr>
<tr class="separator:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a></td></tr>
<tr class="memdesc:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the value associated to a key satisfying a predicate.  <a href="#a2772d97163d2e2ca3f51b2d16d13ff66">More...</a><br /></td></tr>
<tr class="separator:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e67ada9561f5e1176faab8eb94a064"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82e67ada9561f5e1176faab8eb94a064"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a></td></tr>
<tr class="memdesc:a82e67ada9561f5e1176faab8eb94a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the value associated to the given key. <br /></td></tr>
<tr class="separator:a82e67ada9561f5e1176faab8eb94a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="a67dd29f7921b76f7d2bd372605f73f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether any key of the structure satisfies the <code>predicate</code>. </p>
<h3>Fusion example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(odd, list(1, 2)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="group__typeclasses.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(odd, list(2, 4)));</div>
</div><!-- fragment --> <h3>MPL example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(<a class="code" href="group__typeclasses.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(odd, list(2_c, 4_c))) == decltype_(false_));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(<a class="code" href="group__typeclasses.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(odd, list(1_c, 2_c))) == decltype_(true_));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a695907e4a3ef7d0e9ab34f5afff709b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether all the keys of the structure satisfy the <code>predicate</code>. </p>
<h3>Fusion example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(odd, list(1, 3)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="group__typeclasses.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(odd, list(1, 2)));</div>
</div><!-- fragment --> <h3>MPL example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(<a class="code" href="group__typeclasses.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(odd, list(1_c, 3_c))) == decltype_(true_));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(<a class="code" href="group__typeclasses.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(odd, list(1_c, 2_c))) == decltype_(false_));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9365b793fe547271e48fa719a7f4854d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether none of the keys of the structure satisfy the <code>predicate</code>. </p>
<h3>Fusion example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a9365b793fe547271e48fa719a7f4854d">none</a>(odd, list(2, 4)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="group__typeclasses.html#a9365b793fe547271e48fa719a7f4854d">none</a>(odd, list(1, 2)));</div>
</div><!-- fragment --> <h3>MPL example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(<a class="code" href="group__typeclasses.html#a9365b793fe547271e48fa719a7f4854d">none</a>(odd, list(2_c, 4_c))) == decltype_(true_));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(decltype_(<a class="code" href="group__typeclasses.html#a9365b793fe547271e48fa719a7f4854d">none</a>(odd, list(1_c, 2_c))) == decltype_(false_));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a04e413e4acd1dac89e442df2f30f3e2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto elem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the key occurs in the structure. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(int_&lt;3&gt;, list(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;4&gt;)));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(!<a class="code" href="group__typeclasses.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(int_&lt;0&gt;, list(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;4&gt;)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2772d97163d2e2ca3f51b2d16d13ff66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto find</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the value associated to a key satisfying a predicate. </p>
<p>Specifically, returns <code>just</code> the first value whose key satisfies the <code>predicate</code>, or <code>nothing</code> if there is no such key.</p>
<h3>Example 1</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(trait_&lt;std::is_integral&gt;, list(1.0, 2, <span class="charliteral">&#39;3&#39;</span>)) == just(2));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(trait_&lt;std::is_class&gt;, list(1.0, 2, <span class="charliteral">&#39;3&#39;</span>)) == nothing);</div>
</div><!-- fragment --> <h3>Example 2</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> types = type_list&lt;char, int, unsigned, long, unsigned long&gt;;</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> == type&lt;unsigned&gt;, types) == just(type&lt;unsigned&gt;));</div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(<a class="code" href="group__typeclasses.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(<a class="code" href="group___functional.html#gaba86a38c81e3c99f4076ebfb2b46f7b2">_</a> == type&lt;void&gt;, types) == nothing);</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
<a name="structboost_1_1hana_1_1_traversable" id="structboost_1_1hana_1_1_traversable"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct boost::hana::Traversable</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data structures that can be traversed from left to right. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa208272d253fd6f7f01e61796e5c1450"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aa208272d253fd6f7f01e61796e5c1450"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
traversable_detail::traverse<br class="typebreak" />
&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#aa208272d253fd6f7f01e61796e5c1450">traverse</a></td></tr>
<tr class="memdesc:aa208272d253fd6f7f01e61796e5c1450"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_map" title="A basic associative array requiring unique and Comparable keys. ">Map</a> each element of a structure to an action, evaluate these actions from left to right, and collect the results.  <a href="#aa208272d253fd6f7f01e61796e5c1450">More...</a><br /></td></tr>
<tr class="separator:aa208272d253fd6f7f01e61796e5c1450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1164ae0d9c9b2ffecf8187f2c5125b6e"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a1164ae0d9c9b2ffecf8187f2c5125b6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <br class="typebreak" />
traversable_detail::sequence<br class="typebreak" />
&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__typeclasses.html#a1164ae0d9c9b2ffecf8187f2c5125b6e">sequence</a></td></tr>
<tr class="memdesc:a1164ae0d9c9b2ffecf8187f2c5125b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate each action in the structure from left to right, and collect the results.  <a href="#a1164ae0d9c9b2ffecf8187f2c5125b6e">More...</a><br /></td></tr>
<tr class="separator:a1164ae0d9c9b2ffecf8187f2c5125b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a class="anchor" id="aa208272d253fd6f7f01e61796e5c1450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr traversable_detail::traverse&lt;A&gt; traverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="group__datatypes.html#structboost_1_1hana_1_1_map" title="A basic associative array requiring unique and Comparable keys. ">Map</a> each element of a structure to an action, evaluate these actions from left to right, and collect the results. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <a class="code" href="group__details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> half = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> if_(x % int_&lt;2&gt; == int_&lt;0&gt;,</div>
<div class="line">            just(x / int_&lt;2&gt;),</div>
<div class="line">            nothing</div>
<div class="line">        );</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        traverse&lt;Maybe&gt;(half, list(int_&lt;2&gt;, int_&lt;4&gt;, int_&lt;6&gt;))</div>
<div class="line">        ==</div>
<div class="line">        just(list(int_&lt;1&gt;, int_&lt;2&gt;, int_&lt;3&gt;))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__details.html#gab7f4d2cdacf9c644755995da69af8d4f">BOOST_HANA_STATIC_ASSERT</a>(</div>
<div class="line">        traverse&lt;Maybe&gt;(half, list(int_&lt;2&gt;, int_&lt;3&gt;, int_&lt;6&gt;))</div>
<div class="line">        ==</div>
<div class="line">        nothing</div>
<div class="line">    );</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>We must specify the target <code><a class="el" href="group__typeclasses.html#structboost_1_1hana_1_1_applicative" title="Applicatives are Functors with the ability to lift values and combine computations. ">Applicative</a></code> explicitly because the current data-type system is not powerful enough to express the return type of the function passed to <code>traverse</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1164ae0d9c9b2ffecf8187f2c5125b6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr traversable_detail::sequence&lt;A&gt; sequence</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate each action in the structure from left to right, and collect the results. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">    assert(</div>
<div class="line">        sequence&lt;List&gt;(</div>
<div class="line">            list(list(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;a2&quot;</span>s), list(<span class="stringliteral">&quot;b1&quot;</span>s), list(<span class="stringliteral">&quot;c1&quot;</span>, <span class="stringliteral">&quot;c2&quot;</span>, <span class="stringliteral">&quot;c3&quot;</span>))</div>
<div class="line">        )</div>
<div class="line">        ==</div>
<div class="line">        list(</div>
<div class="line">            list(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c1&quot;</span>s),</div>
<div class="line">            list(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s),</div>
<div class="line">            list(<span class="stringliteral">&quot;a1&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s),</div>
<div class="line"></div>
<div class="line">            list(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c1&quot;</span>s),</div>
<div class="line">            list(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c2&quot;</span>s),</div>
<div class="line">            list(<span class="stringliteral">&quot;a2&quot;</span>s, <span class="stringliteral">&quot;b1&quot;</span>s, <span class="stringliteral">&quot;c3&quot;</span>s)</div>
<div class="line">        )</div>
<div class="line">    );</div>
</div><!-- fragment -->
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
