<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::Searchable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Searchable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1Searchable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Searchable Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> concept represents structures that can be searched. </p>
<p>Intuitively, a <a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> is any structure, finite or infinite, containing elements that can be searched using a predicate. Sometimes, Searchables will associate keys to values; one can search for a key with a predicate, and the value associated to it is returned. This gives rise to map-like data structures. Other times, the elements of the structure that are searched (i.e. those to which the predicate is applied) are the same that are returned, which gives rise to set-like data structures. In general, we will refer to the <em>keys</em> of a <a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> structure as those elements that are used for searching, and to the <em>values</em> of a <a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> as those elements that are returned when a search is successful. As was explained, there is no requirement that both notions differ, and it is often useful to have keys and values coincide (think about <code>std::set</code>).</p>
<p>Some methods like <code>any_of</code>, <code>all_of</code> and <code>none_of</code> allow simple queries to be performed on the keys of the structure, while other methods like <code>find</code> and <code>find_if</code> make it possible to find the value associated to a key. The most specific method should always be used if one cares about performance, because it is usually the case that heavy optimizations can be performed in more specific methods. For example, an associative data structure implemented as a hash table will be much faster to access using <code>find</code> than <code>find_if</code>, because in the second case it will have to do a linear search through all the entries. Similarly, using <code>elem</code> will likely be much faster than <code>any_of</code> with an equivalent predicate.</p>
<blockquote class="doxtable">
<h4>Insight</h4>
<p>In a lazy evaluation context, any <a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be folded, i.e. summarized into a single val...">Foldable</a> can also become a model of <a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> because we can search lazily through the structure with <code>foldr</code>. However, in the context of C++, some Searchables can not be folded; think for example of an infinite set. </p>
</blockquote>
<h2>Laws </h2>
<p>In order for the semantics of the methods to be consistent, some properties must be satisfied by any model of the <a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> concept. Rigorously, for any <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> xs, ys</code> and predicate <code>p</code>, the following laws should be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(xs, p) &lt;=&gt; !<a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(xs, negated p)</div>
<div class="line">              &lt;=&gt; !<a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(xs, p)</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(xs, x) &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(xs, [](auto y) { <span class="keywordflow">return</span> y == x; })</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(xs, x) == <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(xs, [](<span class="keyword">auto</span> y) { <span class="keywordflow">return</span> y == x; })</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(false_)) == nothing</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#aa713b34e28603ea39c8873609fd24801">subset</a>(xs, ys) &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(xs, [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(ys, x); })</div>
</div><!-- fragment --><p>Additionally, if all the keys of the <a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> are <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s, the following laws should be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(xs)  &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(xs, <span class="keywordtype">id</span>)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(xs)  &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(xs, <span class="keywordtype">id</span>)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(xs) &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(xs, <span class="keywordtype">id</span>)</div>
</div><!-- fragment --><h2>Minimal complete definition </h2>
<ol type="1">
<li><code>find_if</code> and <code>any_of</code><br />
According to the above laws, it is possible to implement all the methods pertaining to this concept using only <code>find_if</code> and <code>any_of</code>. When <code>find_if</code> and <code>any_of</code> are provided, the other methods are implemented according to the laws above.</li>
</ol>
<h2>Provided models </h2>
<ol type="1">
<li>For builtin arrays<br />
Builtin arrays whose size is known can be searched as-if they were homogeneous tuples. However, since arrays can only hold objects of a single type and the predicate to <code>find_if</code> must return a compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>, the <code>find_if</code> method is fairly useless. For similar reasons, the <code>find</code> method is also fairly useless.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>We could implement <code>any_of(xs, pred)</code> as <code>is_just(find_if(xs, pred))</code>, and then reduce the minimal complete definition to <code>find_if</code>. However, this is not done because that implementation requires the predicate of <code>any_of</code> to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>, which is more restrictive than what we have right now.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>We should provide a member <code>operator[]</code> equivalent to <code>find</code>. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a2dc05dc4553467aa0a2235088de41b4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a></td></tr>
<tr class="memdesc:a2dc05dc4553467aa0a2235088de41b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any key of the structure satisfies the <code>predicate</code>.  <a href="#a2dc05dc4553467aa0a2235088de41b4b">More...</a><br /></td></tr>
<tr class="separator:a2dc05dc4553467aa0a2235088de41b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a></td></tr>
<tr class="memdesc:a67dd29f7921b76f7d2bd372605f73f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any key of the structure is true-valued.  <a href="#a67dd29f7921b76f7d2bd372605f73f7c">More...</a><br /></td></tr>
<tr class="separator:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd57241c497cbe1a2ce5ac57549080"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a></td></tr>
<tr class="memdesc:adadd57241c497cbe1a2ce5ac57549080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all the keys of the structure satisfy the <code>predicate</code>.  <a href="#adadd57241c497cbe1a2ce5ac57549080">More...</a><br /></td></tr>
<tr class="separator:adadd57241c497cbe1a2ce5ac57549080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a></td></tr>
<tr class="memdesc:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all the keys of the structure are true-valued.  <a href="#a695907e4a3ef7d0e9ab34f5afff709b2">More...</a><br /></td></tr>
<tr class="separator:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a></td></tr>
<tr class="memdesc:abf1dbf83a1d98c62994e207ea18eea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether none of the keys of the structure satisfy the <code>predicate</code>.  <a href="#abf1dbf83a1d98c62994e207ea18eea8a">More...</a><br /></td></tr>
<tr class="separator:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365b793fe547271e48fa719a7f4854d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a></td></tr>
<tr class="memdesc:a9365b793fe547271e48fa719a7f4854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all of the keys of the structure are false-valued.  <a href="#a9365b793fe547271e48fa719a7f4854d">More...</a><br /></td></tr>
<tr class="separator:a9365b793fe547271e48fa719a7f4854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a></td></tr>
<tr class="memdesc:a04e413e4acd1dac89e442df2f30f3e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the key occurs in the structure.  <a href="#a04e413e4acd1dac89e442df2f30f3e2d">More...</a><br /></td></tr>
<tr class="separator:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234e4ee0bd5e0e9e604d6140fde24074"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a234e4ee0bd5e0e9e604d6140fde24074">in</a> = infix(flip(<a class="el" href="structboost_1_1hana_1_1Searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>))</td></tr>
<tr class="memdesc:a234e4ee0bd5e0e9e604d6140fde24074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the key occurs in the structure.  <a href="#a234e4ee0bd5e0e9e604d6140fde24074">More...</a><br /></td></tr>
<tr class="separator:a234e4ee0bd5e0e9e604d6140fde24074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade889e960898a96ac6502c9301827220"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a></td></tr>
<tr class="memdesc:ade889e960898a96ac6502c9301827220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value associated to the first key satisfying a predicate.  <a href="#ade889e960898a96ac6502c9301827220">More...</a><br /></td></tr>
<tr class="separator:ade889e960898a96ac6502c9301827220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a></td></tr>
<tr class="memdesc:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value associated to the given key in a structure.  <a href="#a2772d97163d2e2ca3f51b2d16d13ff66">More...</a><br /></td></tr>
<tr class="separator:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713b34e28603ea39c8873609fd24801"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#aa713b34e28603ea39c8873609fd24801">subset</a></td></tr>
<tr class="memdesc:aa713b34e28603ea39c8873609fd24801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a structure contains a subset of the keys of another structure.  <a href="#aa713b34e28603ea39c8873609fd24801">More...</a><br /></td></tr>
<tr class="separator:aa713b34e28603ea39c8873609fd24801"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a2dc05dc4553467aa0a2235088de41b4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether any key of the structure satisfies the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to be satisfied after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(make&lt;Tuple&gt;(1, 2), odd));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(make&lt;Tuple&gt;(2_c, 4_c), odd));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(make&lt;Tuple&gt;(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_void&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    !<a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(make&lt;Tuple&gt;(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_integral&gt;)</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/searchable/any_of.ctime.png" alt="any_of.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a67dd29f7921b76f7d2bd372605f73f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether any key of the structure is true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(make&lt;Tuple&gt;(<span class="keyword">false</span>, false_, true_)));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(make&lt;Tuple&gt;(<span class="keyword">false</span>, false_, <span class="keyword">true</span>)));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1Searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(make&lt;Tuple&gt;(<span class="keyword">false</span>, false_, false_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adadd57241c497cbe1a2ce5ac57549080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether all the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a false- valued <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(make&lt;Tuple&gt;(1, 3), odd));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(make&lt;Tuple&gt;(3_c, 4_c), odd));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    !<a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(make&lt;Tuple&gt;(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_void&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(make&lt;Tuple&gt;(type&lt;int&gt;, type&lt;char&gt;), trait&lt;std::is_integral&gt;)</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/searchable/all_of.ctime.png" alt="all_of.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a695907e4a3ef7d0e9ab34f5afff709b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether all the keys of the structure are true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s. If the structure is not finite, a false-valued key must appear at a finite "index" in order for this method to finish.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(make&lt;Tuple&gt;(true_, <span class="keyword">true</span>, true_)));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1Searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(make&lt;Tuple&gt;(<span class="keyword">true</span>, false_, true_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abf1dbf83a1d98c62994e207ea18eea8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether none of the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a true- valued <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(make&lt;Tuple&gt;(2_c, 4_c), odd));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(make&lt;Tuple&gt;(1, 2), odd));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    !<a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(make&lt;Tuple&gt;(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_void&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(make&lt;Tuple&gt;(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_integral&gt;)</div>
<div class="line">);</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/searchable/none_of.ctime.png" alt="none_of.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a9365b793fe547271e48fa719a7f4854d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether all of the keys of the structure are false-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(make&lt;Tuple&gt;(<span class="keyword">false</span>, false_, false_)));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1Searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(make&lt;Tuple&gt;(<span class="keyword">false</span>, false_, <span class="keyword">true</span>)));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!<a class="code" href="structboost_1_1hana_1_1Searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(make&lt;Tuple&gt;(<span class="keyword">false</span>, false_, true_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a04e413e4acd1dac89e442df2f30f3e2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto elem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; key) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether the key occurs in the structure. </p>
<p>Specifically, returns whether any of the keys of the structure is equal to the given <code>key</code>. If the structure is not finite, an equal key has to appear at a finite "index" in the structure for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> with the other keys of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(make&lt;Tuple&gt;(2, int_&lt;2&gt;, int_&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>), int_&lt;3&gt;));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(set(1, <span class="charliteral">&#39;2&#39;</span>, type&lt;int&gt;, <span class="stringliteral">&quot;foobar&quot;</span>), type&lt;int&gt;));</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/searchable/elem.ctime.png" alt="elem.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a234e4ee0bd5e0e9e604d6140fde24074"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto in = infix(flip(<a class="el" href="structboost_1_1hana_1_1Searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the key occurs in the structure. </p>
<p>Specifically, this is equivalent to <code>flip(elem)</code>, except that <code>in</code> can also be used in infix notation for increased expressiveness. This function is not a method that can be overriden; it is just a convenience function provided with the concept.</p>
<h2>Example </h2>
<div class="fragment"><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> xs = make&lt;Tuple&gt;(</div>
<div class="line">    int_&lt;1&gt;, type&lt;int&gt;, int_&lt;2&gt;, type&lt;float&gt;, int_&lt;3&gt;, type&lt;void&gt;, type&lt;char&gt;</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    filter(xs, <a class="code" href="structboost_1_1hana_1_1Searchable.html#a234e4ee0bd5e0e9e604d6140fde24074">in</a> ^ make&lt;Tuple&gt;(int_&lt;3&gt;, type&lt;int&gt;, type&lt;void&gt;))</div>
<div class="line">    ==</div>
<div class="line">    make&lt;Tuple&gt;(type&lt;int&gt;, int_&lt;3&gt;, type&lt;void&gt;)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ade889e960898a96ac6502c9301827220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto find_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Finds the value associated to the first key satisfying a predicate. </p>
<p>Specifically, returns <code>just</code> the first value whose key satisfies the <code>predicate</code>, or <code>nothing</code> if there is no such key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. Note that in the current version of the library, the <code>predicate</code> has to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> because <code>find_if</code> returns either a <code>just(...)</code> or <code>nothing</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(make&lt;Tuple&gt;(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), trait&lt;std::is_integral&gt;) == just(2)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(make&lt;Tuple&gt;(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), trait&lt;std::is_class&gt;) == nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> types = tuple_t&lt;char, int, unsigned, long, unsigned long&gt;;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(types, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == type&lt;unsigned&gt;) == just(type&lt;unsigned&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(types, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == type&lt;void&gt;) == nothing</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/searchable/find_if.ctime.png" alt="find_if.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a2772d97163d2e2ca3f51b2d16d13ff66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto find</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; key) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Finds the value associated to the given key in a structure. </p>
<p>Specifically, returns <code>just</code> the first value whose key is equal to the given <code>key</code>, or <code>nothing</code> if there is no such key. Comparison is done with <code>equal</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> with the other keys of the structure. In the current version of the library, the comparison of <code>key</code> with any other key of the structure must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(make&lt;Tuple&gt;(int_&lt;1&gt;, type&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), type&lt;int&gt;) == just(type&lt;int&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(make&lt;Tuple&gt;(int_&lt;1&gt;, type&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), type&lt;void&gt;) == nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> m = make&lt;Map&gt;(</div>
<div class="line">    make&lt;Pair&gt;(1, <span class="charliteral">&#39;x&#39;</span>),</div>
<div class="line">    make&lt;Pair&gt;(type&lt;float&gt;, 3.3),</div>
<div class="line">    make&lt;Pair&gt;(type&lt;char&gt;, type&lt;int&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(m, type&lt;float&gt;) == just(3.3));</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/searchable/find.ctime.png" alt="find.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="aa713b34e28603ea39c8873609fd24801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto subset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether a structure contains a subset of the keys of another structure. </p>
<p>Specifically, <code>subset(xs, ys)</code> is a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether all of the keys of <code>xs</code> are also keys of <code>ys</code>. In particular, this method does <em>not</em> check whether <code>xs</code> is a strict subset of <code>ys</code>, i.e. a subset that is not equal.</p>
<dl class="section note"><dt>Note</dt><dd>This method is tag-dispatched using the data type of the first argument only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to check whether it is a subset of <code>ys</code>.</td></tr>
    <tr><td class="paramname">ys</td><td>The structure to check whether it is a superset of <code>xs</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1Searchable.html#aa713b34e28603ea39c8873609fd24801">subset</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), make&lt;Tuple&gt;(3.3, 1, <span class="charliteral">&#39;2&#39;</span>, <span class="keyword">nullptr</span>)));</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/searchable/subset.ctime.png" alt="subset.ctime.png"/>
</div>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Consider using the data type of both arguments for tag-dispatching. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Searchable.html">Searchable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
